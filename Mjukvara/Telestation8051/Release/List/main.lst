##############################################################################
#                                                                            #
# IAR 8051 C-Compiler V5.20A/386                                             #
# Front End V4.20N                                       19/Sep/104  17:59:49 #
# Global Optimizer V1.04E                                                    #
#                                                                            #
#       Target option =  8051                                                #
#       Memory model  =  large                                               #
#       Source file   =  main.c                                              #
#       List file     =  release\list\main.lst                               #
#       Object file   =  release\obj\main.r03                                #
#       Command line  =  main.c -S -ml -v0 -e -K -u -s9 -RHIGHCODE -gA       #
#                        -IC:\IAR\EW\8051\inc\ -ORelease\Obj\                #
#                        -LRelease\List\ -q -i -t8 -x                        #
#                                                                            #
#                                             (c) Copyright IAR Systems 1996 #
##############################################################################

   \   0000                    NAME    main(18)
   \   0000                    RSEG    HIGHCODE(0)
   \   0000                    RSEG    CSTR(0)
   \   0000                    RSEG    CONST(0)
   \   0000                    COMMON  INTVEC(0)
   \   0000                    RSEG    X_UDATA(0)
   \   0000                    PUBLIC  Append
   \   0000                    $DEFFN  Append(0,0,0,0,32768,0,0,0)
   \   0000                    EXTERN  AskQuestionMsg
   \   0000                    $DEFFN  AskQuestionMsg(32768,0,0,0)
   \   0000                    EXTERN  CategoryHit
   \   0000                    $DEFFN  CategoryHit(32768,0,4,0),myStr2Int
   \   0000                    PUBLIC  ClearLabelList
   \   0000                    $DEFFN  ClearLabelList(0,0,2,0,32768,0,0,0)
   \   0000                    EXTERN  CreateLog
   \   0000                    $DEFFN  CreateLog(32768,0,0,0)
   \   0000                    PUBLIC  DecodeAndPerform
   \   0000                    $DEFFN  DecodeAndPerform(0,0,34,0,32768,0,3,0),strtok,myStrCpy,strtok,
   \   0000                            myStrCmpNoCase,Hello,myStrCmpNoCase,EraseAll,myStrCmpNoCase,StartDynamic,
   \   0000                            myStrCmpNoCase,EraseDynamic,WriteCalenderByte,WriteCalenderByte,myStrCmpNoCase,
   \   0000                            Dir,myStrCmpNoCase,Type,myStrCmpNoCase,TypeA,myStrCmpNoCase,EchoMic,
   \   0000                            myStrCmpNoCase,EchoPhone,myStrCmpNoCase,RecMicFile,myStrCmpNoCase,RecPhoneFile,
   \   0000                            myStrCmpNoCase,WavTone,myStrCmpNoCase,PlayFile,myStrCmpNoCase,MakeDTMFTones,
   \   0000                            myStrCmpNoCase,HangUp,myStrCmpNoCase,LiftPhone,myStrCmpNoCase,myStr2Int,
   \   0000                            WaitFor,myStrCmpNoCase,WriteCalenderByte,myStrCmpNoCase,WriteCalenderByte,
   \   0000                            myStrCmpNoCase,CreateLog,SendStringEOLRS232,myStrCmpNoCase,EnterCode,
   \   0000                            myStrCmpNoCase,myStr2Int,ReadCalenderByte,myLong2HexStr,SendStringEOLRS232,
   \   0000                            SendStringEOLRS232,SendStringEOLRS232,myStrCmpNoCase,myStr2Int,myStr2Int,
   \   0000                            WriteCalenderByte,SendStringEOLRS232,SendStringEOLRS232,myStrCmpNoCase,
   \   0000                            GotoLabel,SendStringEOLRS232,myStrCmpNoCase,myStr2Int,GotoLabel,SendStringEOLRS232,
   \   0000                            myStrCmpNoCase,RecordCallerMessage,myStrCmpNoCase,AskQuestionMsg,myStrCmpNoCase,
   \   0000                            PlayNewMessages,ResetDTMFIndex,myStrCmpNoCase,WaitForCall,myStrCmpNoCase,
   \   0000                            ReadPhoneBookFile,myStrCmpNoCase,LookUpCaller,SendStringRS232,SendStringEOLRS232,
   \   0000                            SendStringRS232,SendRS232,SendStringEOLRS232,myStrCmpNoCase,myStr2Int,
   \   0000                            myStr2Int,SetDPWiper,SendStringRS232,myInt2DecStr,SendStringEOLRS232,
   \   0000                            myStrCmpNoCase,myStr2Int,WriteCalenderByte,SendStringRS232,myInt2DecStr,
   \   0000                            SendStringEOLRS232,myStrCmpNoCase,myStrCmpNoCase,myStrCmpNoCase,myStr2Int,
   \   0000                            ReadDPWiper,SendStringRS232,myInt2DecStr,SendStringEOLRS232,SendStringRS232,
   \   0000                            myInt2DecStr,SendStringEOLRS232,myStrCmpNoCase,myStrCmpNoCase,myStrCmpNoCase,
   \   0000                            myStrCmpNoCase,myStrCmpNoCase,CategoryHit,GotoLabel,myStrCmpNoCase,CategoryHit,
   \   0000                            myStr2Int,SendStringEOLRS232,SendStringEOLRS232,myStrCmpNoCase,PlayMemo,
   \   0000                            myStrCmpNoCase,RecordMemo,myStrCmpNoCase,myStr2Int,WriteCalenderByte
   \   0000                    EXTERN  Dir
   \   0000                    $DEFFN  Dir(32768,0,0,0)
   \   0000                    EXTERN  DispInfoBox
   \   0000                    $DEFFN  DispInfoBox(32768,0,6,0)
   \   0000                    EXTERN  DisplayMenu
   \   0000                    $DEFFN  DisplayMenu(32768,0,3,0)
   \   0000                    EXTERN  EchoMic
   \   0000                    $DEFFN  EchoMic(32768,0,0,0)
   \   0000                    EXTERN  EchoPhone
   \   0000                    $DEFFN  EchoPhone(32768,0,0,0)
   \   0000                    EXTERN  EnterCode
   \   0000                    $DEFFN  EnterCode(32768,0,0,0)
   \   0000                    EXTERN  EraseAll
   \   0000                    $DEFFN  EraseAll(32768,0,0,0)
   \   0000                    EXTERN  EraseDynamic
   \   0000                    $DEFFN  EraseDynamic(32768,0,0,0)
   \   0000                    PUBLIC  ExecuteBatFile
   \   0000                    $DEFFN  ExecuteBatFile(0,0,388,0,32768,0,3,0),fopen,ftell,fgetLine,SendStringEOLRS232,
   \   0000                            InsertLabel,ftell,DecodeAndPerform,SendStringEOLRS232,SendStringRS232,
   \   0000                            myLong2HexStr,SendStringEOLRS232,ClearLabelList,fclose,SendStringEOLRS232
   \   0000                    PUBLIC  FindLabel
   \   0000                    $DEFFN  FindLabel(0,0,4,0,32768,0,3,0),myStrCmpNoCase
   \   0000                    PUBLIC  GotoLabel
   \   0000                    $DEFFN  GotoLabel(0,0,389,0,32768,0,3,0),FindLabel,fgetLine,InsertLabel,
   \   0000                            ftell,FindLabel,ftell,fSetPos
   \   0000                    EXTERN  HangUp
   \   0000                    $DEFFN  HangUp(32768,0,0,0)
   \   0000                    PUBLIC  Hello
   \   0000                    $DEFFN  Hello(0,0,2,0,32768,0,0,0),SendStringEOLRS232
   \   0000                    EXTERN  InitializeCalender
   \   0000                    $DEFFN  InitializeCalender(32768,0,0,0)
   \   0000                    PUBLIC  InitializeComputer1
   \   0000                    $DEFFN  InitializeComputer1(0,0,2,0,32768,0,0,0),SendStringEOLRS232,InitializeLCD,
   \   0000                            SendStringEOLRS232,InitializeFlash,SendStringEOLRS232,InitializeFileSystem,
   \   0000                            SendStringEOLRS232,InitializeWAV,SendStringEOLRS232,InitializeDTMF,SendStringEOLRS232,
   \   0000                            InitializePhone,SendStringEOLRS232,InitializeTimer,SendStringEOLRS232,
   \   0000                            InitializeCalender,SendStringEOLRS232,InitializeKeyboard,SendStringEOLRS232,
   \   0000                            InitializeDPot
   \   0000                    EXTERN  InitializeDPot
   \   0000                    $DEFFN  InitializeDPot(32768,0,0,0)
   \   0000                    EXTERN  InitializeDTMF
   \   0000                    $DEFFN  InitializeDTMF(32768,0,0,0)
   \   0000                    EXTERN  InitializeFileSystem
   \   0000                    $DEFFN  InitializeFileSystem(32768,0,0,0)
   \   0000                    EXTERN  InitializeFlash
   \   0000                    $DEFFN  InitializeFlash(32768,0,0,0)
   \   0000                    EXTERN  InitializeKeyboard
   \   0000                    $DEFFN  InitializeKeyboard(32768,0,0,0)
   \   0000                    EXTERN  InitializeLCD
   \   0000                    $DEFFN  InitializeLCD(32768,0,0,0)
   \   0000                    EXTERN  InitializeLogFile
   \   0000                    $DEFFN  InitializeLogFile(32768,0,0,0)
   \   0000                    EXTERN  InitializePhone
   \   0000                    $DEFFN  InitializePhone(32768,0,0,0)
   \   0000                    EXTERN  InitializePhoneAns
   \   0000                    $DEFFN  InitializePhoneAns(32768,0,0,0)
   \   0000                    PUBLIC  InitializePhoneAnsApp
   \   0000                    $DEFFN  InitializePhoneAnsApp(0,0,2,0,32768,0,0,0),SendStringEOLRS232,
   \   0000                            InitializePhoneAns,SendStringEOLRS232,InitializeLogFile,SendStringEOLRS232,
   \   0000                            SetupBatFile,SendStringEOLRS232,IntitializeMemo
   \   0000                    EXTERN  InitializeRS232
   \   0000                    $DEFFN  InitializeRS232(32768,0,0,0)
   \   0000                    EXTERN  InitializeTimer
   \   0000                    $DEFFN  InitializeTimer(32768,0,0,0)
   \   0000                    EXTERN  InitializeWAV
   \   0000                    $DEFFN  InitializeWAV(32768,0,0,0)
   \   0000                    PUBLIC  InsertLabel
   \   0000                    $DEFFN  InsertLabel(0,0,12,0,32768,0,7,0),ftell,strtok,myStrCmpNoCase,
   \   0000                            myStrCpy,ftell
   \   0000                    EXTERN  IntitializeMemo
   \   0000                    $DEFFN  IntitializeMemo(32768,0,0,0)
   \   0000                    EXTERN  KillTimer
   \   0000                    $DEFFN  KillTimer(32768,0,1,0)
   \   0000                    EXTERN  LiftPhone
   \   0000                    $DEFFN  LiftPhone(32768,0,0,0)
   \   0000                    EXTERN  LookUpCaller
   \   0000                    $DEFFN  LookUpCaller(32768,0,9,0)
   \   0000                    PUBLIC  MainShell
   \   0000                    $DEFFN  MainShell(0,0,392,0,32768,0,0,0),SendRS232,ReceiveLineRS232,fdownLoad,
   \   0000                            fupLoad,DecodeAndPerform,myStrLen,fopen,fclose,ExecuteBatFile,SendStringEOLRS232,
   \   0000                            SendStringRS232,myLong2HexStr,SendStringEOLRS232
   \   0000                    EXTERN  MakeDTMFTones
   \   0000                    $DEFFN  MakeDTMFTones(32768,0,3,0)
   \   0000                    EXTERN  PlayFile
   \   0000                    $DEFFN  PlayFile(32768,0,3,0)
   \   0000                    EXTERN  PlayMemo
   \   0000                    $DEFFN  PlayMemo(32768,0,0,0)
   \   0000                    EXTERN  PlayNewMessages
   \   0000                    $DEFFN  PlayNewMessages(32768,0,0,0)
   \   0000                    EXTERN  ReadCalenderByte
   \   0000                    $DEFFN  ReadCalenderByte(32768,0,4,0)
   \   0000                    EXTERN  ReadDPWiper
   \   0000                    $DEFFN  ReadDPWiper(32768,0,4,0)
   \   0000                    EXTERN  ReadPhoneBookFile
   \   0000                    $DEFFN  ReadPhoneBookFile(32768,0,0,0)
   \   0000                    EXTERN  RecMicFile
   \   0000                    $DEFFN  RecMicFile(32768,0,3,0)
   \   0000                    EXTERN  RecPhoneFile
   \   0000                    $DEFFN  RecPhoneFile(32768,0,3,0)
   \   0000                    EXTERN  ReceiveLineRS232
   \   0000                    $DEFFN  ReceiveLineRS232(32768,0,5,0)
   \   0000                    EXTERN  RecordCallerMessage
   \   0000                    $DEFFN  RecordCallerMessage(32768,0,0,0)
   \   0000                    EXTERN  RecordMemo
   \   0000                    $DEFFN  RecordMemo(32768,0,0,0)
   \   0000                    EXTERN  ResetDTMFIndex
   \   0000                    $DEFFN  ResetDTMFIndex(32768,0,0,0)
   \   0000                    EXTERN  SendRS232
   \   0000                    $DEFFN  SendRS232(32768,0,1,0)
   \   0000                    EXTERN  SendStringEOLRS232
   \   0000                    $DEFFN  SendStringEOLRS232(32768,0,3,0)
   \   0000                    EXTERN  SendStringRS232
   \   0000                    $DEFFN  SendStringRS232(32768,0,3,0)
   \   0000                    EXTERN  SetDPWiper
   \   0000                    $DEFFN  SetDPWiper(32768,0,2,0)
   \   0000                    PUBLIC  SetupBatFile
   \   0000                    $DEFFN  SetupBatFile(0,0,2,0,32768,0,0,0)
   \   0000                    EXTERN  StartDynamic
   \   0000                    $DEFFN  StartDynamic(32768,0,0,0)
   \   0000                    EXTERN  StartTimer
   \   0000                    $DEFFN  StartTimer(32768,0,2,0)
   \   0000                    PUBLIC  T0_int
   \   0000                    $DEFFN  T0_int(512,0,0,0,32768,0,0,0)
   \   0000                    EXTERN  TimedOut
   \   0000                    $DEFFN  TimedOut(32768,0,1,0)
   \   0000                    EXTERN  Type
   \   0000                    $DEFFN  Type(32768,0,0,0)
   \   0000                    EXTERN  TypeA
   \   0000                    $DEFFN  TypeA(32768,0,0,0)
   \   0000                    EXTERN  WaitFor
   \   0000                    $DEFFN  WaitFor(32768,0,2,0)
   \   0000                    EXTERN  WaitForCall
   \   0000                    $DEFFN  WaitForCall(32768,0,0,0)
   \   0000                    EXTERN  WavTone
   \   0000                    $DEFFN  WavTone(32768,0,0,0)
   \   0000                    EXTERN  WriteCalenderByte
   \   0000                    $DEFFN  WriteCalenderByte(32768,0,2,0)
   \   0000                    EXTERN  answerOn
   \   0000                    PUBLIC  batFilePtr
   \   0000                    PUBLIC  batLabelName
   \   0000                    PUBLIC  batLabelPos
   \   0000                    EXTERN  callerCategory
   \   0000                    PUBLIC  commandLine
   \   0000                    PUBLIC  error
   \   0000                    EXTERN  fSetPos
   \   0000                    $DEFFN  fSetPos(32768,0,7,0)
   \   0000                    EXTERN  fclose
   \   0000                    $DEFFN  fclose(32768,0,3,0)
   \   0000                    EXTERN  fdownLoad
   \   0000                    $DEFFN  fdownLoad(32768,0,0,0)
   \   0000                    EXTERN  fgetLine
   \   0000                    $DEFFN  fgetLine(32768,0,8,0)
   \   0000                    EXTERN  fopen
   \   0000                    $DEFFN  fopen(32768,0,6,0)
   \   0000                    EXTERN  ftell
   \   0000                    $DEFFN  ftell(32768,0,3,0)
   \   0000                    EXTERN  fupLoad
   \   0000                    $DEFFN  fupLoad(32768,0,0,0)
   \   0000                    EXTERN  lastPlayed
   \   0000                    PUBLIC  main
   \   0000                    $DEFFN  main(0,0,3,0,32768,0,0,0),InitializeRS232,SendStringEOLRS232,SendStringEOLRS232,
   \   0000                            InitializeComputer1,DispInfoBox,DisplayMenu,SendStringEOLRS232,StartTimer,
   \   0000                            TimedOut,KillTimer,SendStringEOLRS232,InitializePhoneAnsApp,ExecuteBatFile,
   \   0000                            DispInfoBox,MainShell
   \   0000                    PUBLIC  msg
   \   0000                    PUBLIC  myInt2DecStr
   \   0000                    $DEFFN  myInt2DecStr(0,0,5,0,32768,0,5,0),myStrCpy,myStrCpy
   \   0000                    PUBLIC  myInt2DecStr00
   \   0000                    $DEFFN  myInt2DecStr00(0,0,4,0,32768,0,4,0),myStrCpy
   \   0000                    PUBLIC  myLong2HexStr
   \   0000                    $DEFFN  myLong2HexStr(0,0,3,0,32768,0,7,0)
   \   0000                    PUBLIC  myStr2Int
   \   0000                    $DEFFN  myStr2Int(0,0,2,0,32768,0,3,0)
   \   0000                    PUBLIC  myStrCmpNoCase
   \   0000                    $DEFFN  myStrCmpNoCase(0,0,2,0,32768,0,6,0)
   \   0000                    PUBLIC  myStrCpy
   \   0000                    $DEFFN  myStrCpy(0,0,2,0,32768,0,6,0)
   \   0000                    PUBLIC  myStrLen
   \   0000                    $DEFFN  myStrLen(0,0,2,0,32768,0,3,0)
   \   0000                    PUBLIC  nrCommandParameters
   \   0000                    EXTERN  numSignals
   \   0000                    EXTERN  receivedDTMF
   \   0000                    EXTERN  speakerVolume
   \   0000                    EXTERN  strtok
   \   0000                    $DEFFN  strtok(32768,0,6,0)
   \   0000                    PUBLIC  timeout
   \   0000                    EXTERN  ?SL_SHR_L01
   \   0000                    EXTERN  ?L_CMP_L01
   \   0000                    EXTERN  ?LD_A_R567_L17
   \   0000                    EXTERN  ?ST_A_R123_L17
   \   0000                    EXTERN  ?LD_A_R567_DISP_L17
   \   0000                    EXTERN  ?ST_A_R123_DISP_L17
   \   0000                    EXTERN  ?ST_A_R567_DISP_L17
   \   0000                    EXTERN  ?LD_R4567_R123_DISP_L17
   \   0000                    EXTERN  ?MOVE_LONG_CR12_DPTR_L17
   \   0000                    EXTERN  ?STO_R0123_DPTR_L20
   \   0000                    EXTERN  ?STO_R4567_DPTR_L20
   \   0000                    EXTERN  ?LD_R0123_XDPTR_L20
   \   0000                    EXTERN  ?LD_R4567_XDPTR_L20
   \   0000                    EXTERN  ?LD_R0123_CDPTR_L20
   \   0000                    EXTERN  ?CL8051L_5_20_L17
   \   0000                    RSEG    HIGHCODE
      1          /*************************************************************
      2          Fil:            $Id: main.c,v 1.6 2003/11/24 22:44:36 Gemensam Exp $
      3          
      4          Beskrivning:    Bootning och kommandotolk för TeleStation applikationen
      5          
      6          Skapad:         99-09-19
      7          
      8          Ändrad:         $Date: 2003/11/24 22:44:36 $
      9          
     10          Ägare:          Fredrik Hoffman
     11          
     12          
     13          Att göra:
     14          
     15          *   Fel felmeddelande 0x14 om man skriver TYPE (utan filnamn) eftersom nollan 
     16              i parameter två stämmer med nollan i filnamnet på en ledig  filstruktur, fixa!
     17          
     18          Revisionshistoria:
     19                                          $Log: main.c,v $
     20                                          Revision 1.6  2003/11/24 22:44:36  Gemensam
     21                                          Fixed PPD, not working yet,
     22                                          New command: speaker volume.
     23                                          Version 0301.
     24                                          
     25                                          Revision 1.5  2003/11/20 22:08:53  Gemensam
     26                                          Various declarations changes.
     27                                          Still version 0200.
     28                                          
     29                                          Revision 1.4  2003/11/18 19:17:35  Gemensam
     30                                          Added menu option of setting speaker volume (untested)
     31                                          Completely changed header files
     32                                          Version 0200.
     33                                          
     34                                          Revision 1.3  2003/11/13 22:35:44  Gemensam
     35                                          Added watchdog reset at GotoLabel, FindLabel and InsertLabel.
     36                                          Added global variable to contain speaker volume, Default volume set to 50.
     37                                          Version 1.1
     38                                          
     39                                          Revision 1.2  2003/11/10 22:44:46  Gemensam
     40                                          Added header information
     41                                          
     42          
     43          *************************************************************/
     44                                  
     45          //////////////////////
     46          // Inkluderingar
     47          
     48          #include <io517a.h>
      1          /*                     - IO517A.H -
      2          
      3             Special header for the Siemens SAB 80C517A/83C517A-5 processors.
      4          
      5             Version 5.20 [IMAF]
      6          
      7          */
      8          
      9          #pragma language=extended
     10          
     11          /* Pre-defined SFR byte addresses: */
     12          
     13          /* CPU */
     14          sfr     ACC    = 0xE0;
     15          sfr     B      = 0xF0;
     16          sfr     SP     = 0x81;
     17          sfr     DPL    = 0x82;
     18          sfr     DPH    = 0x83;
     19          sfr     DPSEL  = 0x92;
     20          sfr     PSW    = 0xD0;
     21          sfr     XPAGE  = 0x91;
     22          sfr     SYSCON = 0xB1;
     23          
     24          /* Timer 0/Timer 1 */
     25          sfr     TCON   = 0x88;
     26          sfr     TMOD   = 0x89;
     27          sfr     TL0    = 0x8A;
     28          sfr     TL1    = 0x8B;
     29          sfr     TH0    = 0x8C;
     30          sfr     TH1    = 0x8D;
     31          
     32          /* CCU */
     33          sfr     CCEN   = 0xC1;
     34          sfr     CC4EN  = 0xC9;
     35          sfr     CCL1   = 0xC2;
     36          sfr     CCH1   = 0xC3;
     37          sfr     CCL2   = 0xC4;
     38          sfr     CCH2   = 0xC5;
     39          sfr     CCL3   = 0xC6;
     40          sfr     CCH3   = 0xC7;
     41          sfr     CCL4   = 0xCE;
     42          sfr     CCH4   = 0xCF;
     43          sfr     CMEN   = 0xF6;
     44          sfr     CML0   = 0xD2;
     45          sfr     CMH0   = 0xD3;
     46          sfr     CML1   = 0xD4;
     47          sfr     CMH1   = 0xD5;
     48          sfr     CML2   = 0xD6;
     49          sfr     CMH2   = 0xD7;
     50          sfr     CML3   = 0xE2;
     51          sfr     CMH3   = 0xE3;
     52          sfr     CML4   = 0xE4;
     53          sfr     CMH4   = 0xE5;
     54          sfr     CML5   = 0xE6;
     55          sfr     CMH5   = 0xE7;
     56          sfr     CML6   = 0xF2;
     57          sfr     CMH6   = 0xF3;
     58          sfr     CML7   = 0xF4;
     59          sfr     CMH7   = 0xF5;
     60          sfr     CMSEL  = 0xF7;
     61          sfr     CRCL   = 0xCA;
     62          sfr     CRCH   = 0xCB;
     63          sfr     CTCON  = 0xE1;
     64          sfr     CTRELL = 0xDE;
     65          sfr     CTRELH = 0xDF;
     66          sfr     TL2    = 0xCC;
     67          sfr     TH2    = 0xCD;
     68          sfr     T2CON  = 0xC8;
     69          sfr     COMSETL= 0xA1;
     70          sfr     COMSETH= 0xA2;
     71          sfr     COMCLRL= 0xA3;
     72          sfr     COMCLRH= 0xA4;
     73          sfr     SETMSK = 0xA5;
     74          sfr     CLRMSK = 0xA6;
     75          
     76          /* Ports */
     77          sfr     P0     = 0x80;
     78          sfr     P1     = 0x90;
     79          sfr     P2     = 0xA0;
     80          sfr     P3     = 0xB0;
     81          sfr     P4     = 0xE8;
     82          sfr     P5     = 0xF8;
     83          sfr     P6     = 0xFA;
     84          sfr     P7     = 0xDB;        /* Analog/Digital Input */
     85          sfr     P8     = 0xDD;        /* Analog/Digital Input, 4 Bit */
     86          
     87          /* Serial Channels */
     88          sfr     PCON   = 0x87;
     89          sfr     S0CON  = 0x98;
     90          sfr     S0BUF  = 0x99;
     91          sfr     S1CON  = 0x9B;
     92          sfr     S1BUF  = 0x9C;
     93          sfr     S0RELL = 0xAA;
     94          sfr     S0RELH = 0xBA;
     95          sfr     S1RELL = 0x9D;
     96          sfr     S1RELH = 0xBB;
     97          
     98          /* A/D Converter */
     99          sfr     ADCON0 = 0xD8;
    100          sfr     ADCON1 = 0xDC;
    101          sfr     ADDATH = 0xD9;
    102          sfr     ADDATL = 0xDA;
    103          
    104          /* MUL/DIV Unit */
    105          sfr     ARCON  = 0xEF;
    106          sfr     MD0    = 0xE9;
    107          sfr     MD1    = 0xEA;
    108          sfr     MD2    = 0xEB;
    109          sfr     MD3    = 0xEC;
    110          sfr     MD4    = 0xED;
    111          sfr     MD5    = 0xEE;
    112          
    113          /* Interrupt System */
    114          sfr     IEN0   = 0xA8;
    115          sfr     IP0    = 0xA9;
    116          sfr     IEN1   = 0xB8;
    117          sfr     IP1    = 0xB9;
    118          sfr     IEN2   = 0x9A;
    119          sfr     IRCON0 = 0xC0;
    120          sfr     IRCON1 = 0xD1;
    121          
    122          
    123          /* Watchdog */
    124          sfr     WDTREL = 0x86;
    125          
    126          
    127          /* Pre-defined SFR bit addresses */
    128          
    129          /*========ADCON0=======*/
    130          
    131          bit     BD     = 0xDF;
    132          bit     CLK    = 0xDE;
    133          bit     ADEX   = 0xDD;
    134          bit     BSY    = 0xDC;
    135          bit     ADM    = 0xDB;
    136          bit     MX2    = 0xDA;
    137          bit     MX1    = 0xD9;
    138          bit     MX0    = 0xD8;
    139          
    140          
    141          /*========IRCON0=======*/
    142          
    143          bit     EXF2   = 0xC7;
    144          bit     TF2    = 0xC6;
    145          bit     IEX6   = 0xC5;
    146          bit     IEX5   = 0xC4;
    147          bit     IEX4   = 0xC3;
    148          bit     IEX3   = 0xC2;
    149          bit     IEX2   = 0xC1;
    150          bit     IADC   = 0xC0;
    151          
    152          /*========T2CON=======*/
    153          
    154          bit     T2PS   = 0xCF;
    155          bit     I3FR   = 0xCE;
    156          bit     I2FR   = 0xCD;
    157          bit     T2R1   = 0xCC;
    158          bit     T2R0   = 0xCB;
    159          bit     T2CM   = 0xCA;
    160          bit     T2I1   = 0xC9;
    161          bit     T2I0   = 0xC8;
    162          
    163          /*========PSW=========*/
    164          
    165          bit     CY     = 0xD7;
    166          bit     AC     = 0xD6;
    167          bit     F0     = 0xD5;
    168          bit     RS1    = 0xD4;
    169          bit     RS0    = 0xD3;
    170          bit     OV     = 0xD2;
    171          bit     F1     = 0xD1;
    172          bit     P      = 0xD0;
    173          
    174          /*========TCON========*/
    175          
    176          bit     TF1    = 0x8F;
    177          bit     TR1    = 0x8E;
    178          bit     TF0    = 0x8D;
    179          bit     TR0    = 0x8C;
    180          bit     IE1    = 0x8B;
    181          bit     IT1    = 0x8A;
    182          bit     IE0    = 0x89;
    183          bit     IT0    = 0x88;
    184          
    185          /*========IEN0========*/
    186          
    187          bit     EAL    = 0xAF;
    188          bit     WDT    = 0xAE;
    189          bit     ET2    = 0xAD;
    190          bit     ES0    = 0xAC;
    191          bit     ET1    = 0xAB;
    192          bit     EX1    = 0xAA;
    193          bit     ET0    = 0xA9;
    194          bit     EX0    = 0xA8;
    195          
    196          /*========IEN1========*/
    197          
    198          bit     EXEN2  = 0xBF;
    199          bit     SWDT   = 0xBE;
    200          bit     EX6    = 0xBD;
    201          bit     EX5    = 0xBC;
    202          bit     EX4    = 0xBB;
    203          bit     EX3    = 0xBA;
    204          bit     EX2    = 0xB9;
    205          bit     EADC   = 0xB8;
    206          
    207          /*========P3=========*/
    208          
    209          bit     RD     = 0xB7;
    210          bit     WR     = 0xB6;
    211          bit     T1     = 0xB5;
    212          bit     T0     = 0xB4;
    213          bit     INT1   = 0xB3;
    214          bit     INT0   = 0xB2;
    215          bit     TXD    = 0xB1;
    216          bit     RXD    = 0xB0;
    217          
    218          /*========S0CON========*/
    219          
    220          bit     SM0    = 0x9F;
    221          bit     SM1    = 0x9E;
    222          bit     SM20   = 0x9D;
    223          bit     REN0   = 0x9C;
    224          bit     TB80   = 0x9B;
    225          bit     RB80   = 0x9A;
    226          bit     TI0    = 0x99;
    227          bit     RI0    = 0x98;
    228          
    229          
    230          /* Interrupt Vector Definitions */
    231          
    232          interrupt [0x03] void EX0_int (void);     /* External Interrupt 0 */
    233          
    234          interrupt [0x0B] void T0_int (void);      /* Timer 0 Overflow */
    235          
    236          interrupt [0x13] void EX1_int (void);     /* External Interrupt 1 */
    237          
    238          interrupt [0x1B] void T1_int (void);      /* Timer 1 Overflow */
    239          
    240          interrupt [0x23] void SCON0_int (void);   /* Serial Port 0 */
    241          
    242          interrupt [0x2B] void T2_int (void);      /* Timer 2 Overflow */
    243          
    244          interrupt [0x2B] void T2EX_int (void);    /* Negative Transition on T2EX */
    245          
    246          interrupt [0x43] void ADC_int (void);     /* ADC Interrupt */
    247          
    248          interrupt [0x4B] void EX2_int (void);     /* External Interrupt 2 */
    249          
    250          interrupt [0x53] void EX3_int (void);     /* External Interrupt 3 */
    251          
    252          interrupt [0x5B] void EX4_int (void);     /* External Interrupt 4 */
    253          
    254          interrupt [0x63] void EX5_int (void);     /* External Interrupt 5 */
    255          
    256          interrupt [0x6B] void EX6_int (void);     /* External Interrupt 6 */
    257          
    258          interrupt [0x83] void SCON1_int (void);   /* Serial Port 1 */
    259          
    260          interrupt [0x93] void ICMP_int (void);    /* Compare match interrupt */
    261          
    262          interrupt [0x9B] void CT_int (void);      /* Compare Timer Overflow */
    263          
    264          interrupt [0xA3] void ICS_int (void);     /* COMSET interrupt */
    265          
    266          interrupt [0xAB] void ICR_int (void);     /* COMCLR interrupt */
    267          
    268          
     49          #include <stdio.h>
      1          /*                      - STDIO.H -
      2          
      3             Subset of ANSI standard I/O function declarations.
      4          
      5             Version: 3.30 04/Nov/94 IHAW
      6          
      7          
      8          */
      9          
     10          #ifndef _STDIO_INCLUDED
     11          #define _STDIO_INCLUDED
     12          
     13          #ifndef NULL
     14          #define NULL    (void *) 0
     15          #endif
     16          
     17          #ifndef EOF
     18          #define EOF     (-1)
     19          #endif
     20          
     21          #ifndef size_t
     22          #if     sizeof((char*)0 - (char*)0) <= sizeof(int)
     23          #define size_t  unsigned int
     24          #else
     25          #define size_t  unsigned long 
     26          #endif
     27          #endif
     28          
     29          /* ===
     30          
     31          #if __TID__ & 0x8000
     32          #pragma function=intrinsic(0)
     33          #endif
     34          
     35          === */
     36          
     37          #ifndef MEMORY_ATTRIBUTE
     38          #define MEMORY_ATTRIBUTE
     39          #endif
     40          
     41          MEMORY_ATTRIBUTE int    puts(const char *__s);
     42          MEMORY_ATTRIBUTE int    putchar(int __value);
     43          MEMORY_ATTRIBUTE int    getchar(void);
     44          MEMORY_ATTRIBUTE int    sprintf(char *__s,const char *__format,...);
     45          MEMORY_ATTRIBUTE int    printf(const char *__format,...);
     46          MEMORY_ATTRIBUTE int    scanf(const char *__format,...);
     47          MEMORY_ATTRIBUTE int    sscanf(const char *__s, const char *__format,...);
     48          MEMORY_ATTRIBUTE char   *gets(char *__s);
     49          
     50          #if __TID__ & 0x8000
     51          #pragma function=default
     52          #endif
     53          
     54          #endif
     55          
     56          
     57          
     50          #include <stdlib.h>
      1          /*                      - STDLIB.H -
      2          
      3             The ANSI-defined 'standard' functions.
      4          
      5             Version: 3.30 04/Nov/94 IHAW
      6          
      7          $Name: V3_33B $
      8          $Log: stdlib.h $
      9          Revision 1.3  1996/06/07 07:11:26  matsp
     10          
     11          Revision 1.2  1996/01/26 16:13:20  matsp
     12          A lot. Converted to Source Integrity
     13          Revision 1.2  1996/01/26 17:13:18  MATSP
     14          Revision 1.4  1996/01/26 16:07:29  MATSP
     15          Revision 1.3  1995/12/04 09:04:11  MATSP
     16          RAND_MAX changed from 32768 to 32767.
     17          */
     18          
     19          #ifndef _STDLIB_INCLUDED
     20          #define _STDLIB_INCLUDED
     21          
     22          #ifndef size_t
     23          #if sizeof((char *)0 - (char *)0) <= sizeof(int)
     24          #define size_t          unsigned int
     25          #else
     26          #define size_t          unsigned long
     27          #endif
     28          #endif
     29          
     30          #ifndef NULL
     31          #define NULL    (void*) 0 
     32          #endif
     33          
     34          typedef struct
     35                  {
     36                    int   quot;
     37                    int   rem;
     38                  } div_t;
     39          
     40          typedef struct
     41                  {
     42                    long int      quot;
     43                    long int      rem;
     44                  } ldiv_t;
     45          
     46          
     47          #define RAND_MAX        32767
     48          
     49          #define EXIT_SUCCESS    0
     50          #define EXIT_FAILURE    1
     51          
     52          #define MB_CUR_MAX      1
     53          
     54          #if __TID__ & 0x8000
     55          #pragma function=intrinsic(0)
     56          #endif
     57          
     58          #ifndef MEMORY_ATTRIBUTE
     59          #define MEMORY_ATTRIBUTE
     60          #endif
     61          
     62          #ifndef PTR_ATTRIBUTE
     63          #define PTR_ATTRIBUTE
     64          #endif
     65          
     66          MEMORY_ATTRIBUTE void   *malloc(size_t __size);
     67          
     68          MEMORY_ATTRIBUTE void   free(void *__ptr);
     69          
     70          MEMORY_ATTRIBUTE void   exit(int __status);
     71          
     72          MEMORY_ATTRIBUTE void   *calloc(unsigned int __nelem, size_t __elsize);
     73          
     74          MEMORY_ATTRIBUTE void   *realloc(void *__ptr, size_t __size);
     75          
     76          MEMORY_ATTRIBUTE int atoi (const char *__nptr);
     77          
     78          MEMORY_ATTRIBUTE long atol (const char *__nptr);
     79          
     80          MEMORY_ATTRIBUTE double atof (const char *__nptr);
     81          
     82          MEMORY_ATTRIBUTE double strtod(const char *__nptr, char **__endptr);
     83          
     84          MEMORY_ATTRIBUTE long int strtol(const char *__nptr, char **__endptr, int __base);
     85          
     86          MEMORY_ATTRIBUTE unsigned long int strtoul(const char *__nptr, char **__endptr, int __base);
     87          
     88          MEMORY_ATTRIBUTE int rand(void);
     89          
     90          MEMORY_ATTRIBUTE void srand(unsigned int __seed);
     91          
     92          MEMORY_ATTRIBUTE void abort(void);
     93          
     94          MEMORY_ATTRIBUTE int abs(int __j);
     95          
     96          MEMORY_ATTRIBUTE div_t div(int __numer, int __denom);
     97          
     98          MEMORY_ATTRIBUTE long int labs(long int __j);
     99          
    100          MEMORY_ATTRIBUTE ldiv_t ldiv(long int __numer, long int __denom);
    101          
    102          MEMORY_ATTRIBUTE void *bsearch(const void *__key, const void *__base,
    103                                  size_t __nmemb, size_t __size,
    104                                  int (*__compar) (const void *, const void *));
    105          
    106          MEMORY_ATTRIBUTE void qsort(void *__base, size_t __nmemb, size_t __size,
    107                                  int (*__compar) (const void *, const void *));
    108          
    109          #if __TID__ & 0x8000
    110          #pragma function=default
    111          #endif
    112          
    113          #endif
    114          
     51          #include <string.h> 
      1          /*                       - STRING.H -
      2          
      3             The ANSI 'string' function declarations.
      4                     
      5             Version: 3.30 04/Nov/94 IHAW
      6                             
      7          */
      8          
      9          #ifndef _STRING_INCLUDED
     10          #define _STRING_INCLUDED
     11          
     12          #ifndef NULL
     13          #define NULL    (void*)0     /* changed from char* 93.01.21 ICLM */
     14          #endif
     15          
     16          #ifndef size_t
     17          #if sizeof((char *)0 - (char *)0) <= sizeof(int)
     18          #define size_t          unsigned int
     19          #else
     20          #define size_t          unsigned long
     21          #endif
     22          #endif
     23          
     24          #if __TID__ & 0x8000
     25          #pragma function=intrinsic(0)
     26          #endif
     27          
     28          #ifndef MEMORY_ATTRIBUTE
     29          #define MEMORY_ATTRIBUTE
     30          #endif
     31          
     32          MEMORY_ATTRIBUTE void *memcpy(void *s1, const void *s2, size_t n);
     33          
     34          MEMORY_ATTRIBUTE void *memmove(void *s1, const void *s2, size_t n);
     35          
     36          MEMORY_ATTRIBUTE void *memchr(const void *s, int c, size_t n);
     37          
     38          MEMORY_ATTRIBUTE void *memset(void *s, int c, size_t n);
     39          
     40          MEMORY_ATTRIBUTE int memcmp(const void *s1, const void *s2, size_t n);
     41          
     42          MEMORY_ATTRIBUTE char *strchr(const char *s, int c);
     43          
     44          MEMORY_ATTRIBUTE int strcmp(const char *s1, const char *s2);
     45          
     46          MEMORY_ATTRIBUTE int strncmp(const char *s1, const char *s2, size_t n);
     47          
     48          MEMORY_ATTRIBUTE int strcoll(const char *s1, const char *s2);
     49          
     50          MEMORY_ATTRIBUTE size_t strlen(const char *s);
     51          
     52          MEMORY_ATTRIBUTE size_t strcspn(const char *s1, const char *s2);
     53          
     54          MEMORY_ATTRIBUTE size_t strspn(const char *s1, const char *s2);
     55          
     56          MEMORY_ATTRIBUTE char *strpbrk(const char *s1, const char *s2);
     57          
     58          MEMORY_ATTRIBUTE char *strrchr(const char *s, int c);
     59          
     60          MEMORY_ATTRIBUTE char *strstr(const char *s1, const char *s2);
     61          
     62          MEMORY_ATTRIBUTE char *strcat(char *s1, const char *s2);
     63          
     64          MEMORY_ATTRIBUTE char *strncat(char *s1, const char *s2, size_t n);
     65          
     66          MEMORY_ATTRIBUTE char *strcpy(char *s1, const char *s2);
     67          
     68          MEMORY_ATTRIBUTE char *strncpy(char *s1, const char *s2, size_t n);
     69          
     70          MEMORY_ATTRIBUTE char *strerror(int errnum);
     71          
     72          MEMORY_ATTRIBUTE char *strtok(char *s1, const char *s2);
     73          
     74          MEMORY_ATTRIBUTE size_t strxfrm(char *s1, const char *s2, size_t n);
     75          
     76          #if __TID__ & 0x8000
     77          #pragma function=default
     78          #endif
     79          
     80          #endif
     81          
     82          
     52          #include "commands.h"
      1          /**************************************************************
      2          Fil:            $Id: Commands.h,v 1.5 2003/11/24 22:44:35 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/24 22:44:35 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Commands.h,v $
      8                                          Revision 1.5  2003/11/24 22:44:35  Gemensam
      9                                          Fixed PPD, not working yet,
     10                                          New command: speaker volume.
     11                                          Version 0301.
     12                                          
     13                                          Revision 1.4  2003/11/20 22:08:52  Gemensam
     14                                          Various declarations changes.
     15                                          Still version 0200.
     16                                          
     17                                          Revision 1.3  2003/11/13 22:39:01  Gemensam
     18                                          Added watchdog reset at GotoLabel, FindLabel and InsertLabel.
     19                                          Added global variable to contain speaker volume, Default volume set to 50.
     20                                          Version 1.1
     21                                          
     22                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     23                                          Added header information
     24                                          
     25          
     26          ***************************************************************/
     27          
     28          #ifndef _COMMANDS_INCLUDED_
     29          #define _COMMANDS_INCLUDED_
     30          
     31          //Module main
     32          #define    CM_HELLO     "HELLO"
     33          #define    CM_TESTHW    "TEST"
     34          #define    CM_ID        "ID"
     35          #define    CM_ERASE     "ERASE"
     36          
     37          //Module Program
     38          #define CM_PROGRAM      "PROGRAM"
     39          
     40          //Module FileSystem
     41          #define CM_READSPARE    "READSPARE"
     42          #define CM_READSPARE2   "RS2"
     43          #define CM_DIR          "DIR"
     44          #define CM_WRITEFILE1   "WF1"
     45          #define CM_WRITEFILE2   "WF2"
     46          #define CM_WRITEFILE3   "WF3"
     47          #define CM_READFILE1    "RF1"
     48          #define CM_READFILE2    "RF2"
     49          #define CM_READFILE3    "RF3"
     50          #define CM_CREATELONG   "CL"
     51          #define CM_DOWNLOAD     "DL" 
     52          #define CM_UPLOAD       "UL" 
     53          #define CM_TYPE         "TYPE" 
     54          #define CM_TYPEA        "TYPEA" 
     55          #define CM_CREATEDYNAMIC "CREATEDYNAMIC" 
     56          #define CM_ERASEDYNAMIC "ERASEDYNAMIC" 
     57           
     58          
     59          
     60          //Module WAV
     61          #define CM_ECHO_MIC     "ECHOMIC"
     62          #define CM_ECHO_PHONE   "ECHOPHONE"
     63          #define CM_REC_MIC      "RECMIC"
     64          #define CM_REC_PHONE    "RECPHONE"
     65          #define CM_TONE         "TONE"
     66          #define CM_PLAY         "PLAY" 
     67          #define CM_REC_PORT     "RECPORT" 
     68           
     69          
     70          //Module DTMF
     71          #define CM_DTMF         "DTMF"
     72          #define CM_WAIT_DTMF    "WAITDTMF"
     73          
     74          //Module Phone
     75          #define CM_HANG_UP      "PD"
     76          #define CM_LIFT_PHONE   "PU"
     77          #define CM_WAIT_RING    "WAITRING"
     78          #define CM_READ_PB      "READPB"
     79          #define CM_LOOKUP_PB    "LOOKUP"
     80           
     81          
     82          //Module Timer
     83          #define CM_WAIT_FOR     "WAITFOR"
     84          
     85          
     86          //BAT-file handlning
     87          #define CM_GOTO_LABEL   "GOTO"
     88          
     89          //Calender funktioner
     90          #define CM_READ_CALENDER_BYTE   "RC"
     91          #define CM_WRITE_CALENDER_BYTE  "WC"
     92           
     93          //PhoneAns funktioner
     94          #define CM_RECMSG           "RECMSG"
     95          #define CM_QUESTION         "QUESTION"
     96          #define CM_WAITCALL         "WAITCALL"
     97          #define CM_ANS_ON           "ANSON"
     98          #define CM_ANS_OFF          "ANSOFF"
     99          #define CM_CRE_LOG          "CREATELOG"
    100          #define CM_ENTER_CODE       "ENTERCODE"
    101          #define CM_PLAYNEW          "PLAYNEW"
    102          #define CM_GOTO_CAT_EQUAL   "BRACATEQU"
    103          #define CM_CATJMP           "CATJUMP"
    104          #define CM_TESTCATJMP       "TCJ"
    105          #define CM_PLAYMEMO         "PLAYMEMO"
    106          #define CM_RECMEMO          "RECMEMO"
    107          #define CM_SETSIGNALS       "SETSIGNALS"
    108          
    109          //LCD funktioner
    110          #define CM_LCD_SET      "SETLCD" 
    111          
    112          //Dpot funktioner
    113          #define CM_SETWIPER         "SETWIPER"
    114          #define CM_SETDPREG         "SETDPREG"
    115          #define CM_TRFTOWIPER       "TRFTOWIPER"
    116          #define CM_READWIPER        "READWIPER"
    117          #define CM_DATAH            "D1"
    118          #define CM_DATAL            "D0"
    119          #define CM_CLKH             "C1"
    120          #define CM_CLKL             "C0"
    121          #define CM_SPEAKVOL         "SPEAKVOL"
    122           
    123          #endif
     53          #include "ErrorCodes.h"
      1          /***********************************************
      2          Fil:            $Id: ErrorCodes.h,v 1.3 2003/11/20 22:08:52 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:52 $
      5          
      6          Revisionshistoria:
      7                                          $Log: ErrorCodes.h,v $
      8                                          Revision 1.3  2003/11/20 22:08:52  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     13                                          Added header information
     14                                          
     15          
     16          
     17          ***********************************************/
     18          
     19          #ifndef _ERRORCODES_INCLUDED_
     20          #define _ERRORCODES_INCLUDED_
     21          
     22          
     23          //Felkoder
     24          
     25          //Generellt
     26          #define EM_NOERROR          0x00
     27          
     28          
     29          
     30          //Filsystem
     31          #define EM_FILEEXISTS       0x10
     32          #define EM_FILENOTEXISTS    0x11
     33          #define EM_OUTOFFILEMEMORY  0x12
     34          #define EM_TOOMANYFILES     0x13
     35          #define EM_FILEOPEN         0x14
     36          #define EM_FILENOTOPEN      0x15
     37          #define EM_FILEREADONLY     0x16
     38          #define EM_FILEWRITEONLY    0x17
     39          #define EM_WRITEFILEOPEN    0x18
     40          
     41          //Phone
     42          #define EM_TOOMANYTIMERS    0x19
     43          
     44          //BAtfiles
     45          #define EM_TOOMANYBATFILES  0x20
     46          #define EM_REDEFLABELATTEMPT    0x21
     47          #define EM_TOOMANYLABELS    0x22
     48          #define EM_NOLABEL          0x23
     49          
     50          
     51          //PhoneAns
     52          #define EM_PARAMETER_SYNTAX    0x24
     53          
     54          #endif
     54          #include "FileSystem.h"
      1          /**************************************************************************************
      2          Fil:            $Id: FileSystem.h,v 1.4 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Kommentarer:    Filhuvudet befinner sig i "Spare" arean tillhörande filens första sida. Huvudet består 
      7                                          av 16 bytes enligt följande lista:
      8                                          0       Huvud       0xAA = Legalt filhuvud, annat tillsvidare odefinierat
      9                                          1-4     Fillängd    Pos 1 = MSB, pos 4 = LSB
     10                                          5-12    Filtitel    Enl "Titel.ext". Om titeln är mindre än 8 tecken avslutas det med nollor
     11                                          13-15   Filext      Enl "Titel.ext". Om ext är mindre än 3 tecken avslutas det med nollor
     12          
     13                                          En nolla skriven i fileName[0] indikerar att
     14                                          filstrukturen är ledig.
     15                  
     16          Revisionshistoria:
     17                                          $Log: FileSystem.h,v $
     18                                          Revision 1.4  2003/11/20 22:08:53  Gemensam
     19                                          Various declarations changes.
     20                                          Still version 0200.
     21                                          
     22                                          Revision 1.3  2003/11/18 19:17:36  Gemensam
     23                                          Added menu option of setting speaker volume (untested)
     24                                          Completely changed header files
     25                                          Version 0200.
     26                                          
     27                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     28                                          Added header information
     29                                          
     30          
     31          **************************************************************************************/
     32          
     33          #ifndef _FILESYSTEM_INCLUDED_
     34          #define _FILESYSTEM_INCLUDED_
     35          
     36          ///////////////////////////////////
     37          // Definitioner
     38          
     39          #define FS_MAXFILES         8 
     40          #define FS_FILENAMELENGTH   13
     41          #define FS_FLASHSIZE        0x800000
     42          
     43          #define OFF            0
     44          #define READY        1
     45          #define NEMPTY        2
     46          #define WRITING        3
     47          #define OCCUPIED    4
     48          
     49          #define CLE     P4.0                                //Command Latch Enable
     50          #define ALE     P4.1                                //Address Latch Enable
     51          #define WP      P4.2                                //Write Protect
     52          #define SE      P4.3                                //Spare Enable
     53          //#define CE      P4.4                                //Chip Enable
     54          #define FBUSY   P4.5                                //Busy
     55          
     56          #define FREG (*(unsigned char xdata *) 0xE000)
     57          #define FLASH (*(unsigned char xdata *) 0xB000) 
     58          
     59          ///////////////////////////////////
     60          // Strukturer
     61          
     62          struct ST_FILE_HEAD {
     63              unsigned long   length;
     64              char            name[FS_FILENAMELENGTH];
     65          };
     66          #define FILE_HEAD struct ST_FILE_HEAD
     67          
     68          
     69          struct ST_FILE {
     70              char            fileName[FS_FILENAMELENGTH];
     71              unsigned long   startAddress;
     72              unsigned long   length; 
     73              unsigned long   offset; 
     74              char            write;
     75              char            append;
     76          };
     77          #define FILE struct ST_FILE 
     78          
     79          
     80          
     81          ///////////////////////////////////
     82          // Funktioner och procedurer
     83          
     84          extern void            InitializeFileSystem( void );
     85          extern void            InitializeFlash( void );
     86          extern void            SetupReadSeq( void );
     87          extern unsigned char   ReadFLASH( void );
     88          extern void            TerminateReadSeq( void );
     89          extern void            GetDeviceIDRS232(void);
     90          extern void            SetupWriteSeq( void );
     91          extern void            WriteFLASH(unsigned char);
     92          extern void            TerminateWriteSeq( void );
     93          extern void            PerformWriteSeq( void );
     94          extern void            EraseBlock( void );
     95          extern void            WriteFileHead(const char* name, long size);
     96          extern FILE*           fopen(const char* name, const char* def);
     97          extern FILE*               fopenA(const char* name, long maxSize, long offset);
     98          extern void            fputc(FILE* filePtr, char c);
     99          extern void            fputLine(FILE* filePtr, const char* str);
    100          extern void            fupLoad( void );
    101          extern int             fgetc(FILE* filePtr);
    102          extern void            fgetLine(FILE* filePtr, char* str, int maxLen);
    103          extern void            fdownLoad( void );
    104          extern void            fclose(FILE* filePtr);
    105          extern long            ftell(FILE* filePtr);
    106          //void            Rewind(FILE* filePtr);
    107          extern void            fSetPos(FILE* filePtr, long offset);
    108          extern void            ReleaseCurrFile( void );
    109          extern void            EraseAll( void );
    110          extern void            StartDynamic( void );
    111          extern void            EraseDynamic( void );
    112          extern char                        MemUsage( void );
    113          extern void                        Dir( void );
    114          extern void                        Type( void );
    115          extern void                        TypeA( void );
    116          
    117          #endif
     55          #include "Phone.h"
      1          /********************************************************
      2          Fil:            $Id: Phone.h,v 1.6 2003/12/26 16:17:01 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/12/26 16:17:01 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Phone.h,v $
      8                                          Revision 1.6  2003/12/26 16:17:01  Gemensam
      9                                          Reinstate 500 ms wait for hang up detection to settle (if not PPD is used).
     10                                          Fixed PPD detection by decreasing phone volume from 63 to 15.
     11                                          Version 0304.
     12                                          
     13                                          Revision 1.5  2003/11/29 22:36:00  Gemensam
     14                                          Fixed problem with to short pulse width on PPD.
     15                                          Ver 0302.
     16                                          
     17                                          Revision 1.4  2003/11/24 22:44:36  Gemensam
     18                                          Fixed PPD, not working yet,
     19                                          New command: speaker volume.
     20                                          Version 0301.
     21                                          
     22                                          Revision 1.3  2003/11/23 21:40:03  Gemensam
     23                                          Parallell phone detection included.
     24                                          Removed obsolete #define's regarding LCD interface.
     25                                          Ver 0300
     26                                          
     27                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
     28                                          Various declarations changes.
     29                                          Still version 0200.
     30                                          
     31                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     32                                          Added menu option of setting speaker volume (untested)
     33                                          Completely changed header files
     34                                          Version 0200.
     35                                          
     36                                          
     37          
     38          ********************************************************/
     39          
     40          #ifndef _PHONE_INCLUDED_
     41          #define _PHONE_INCLUDED_
     42          
     43          ///////////////////////////////////
     44          // Definitioner
     45          
     46          //PS = Phone Signals
     47          #define PS_RV                                           P1.2
     48          #define PS_LC                                           P1.7
     49          #define PS_LCD                                          P1.1
     50          #define PS_PPD                                          P1.0
     51          
     52          #define WRS_POS_EDGE_TRIGG          10
     53          #define WRS_NEG_EDGE_TRIGG          10
     54          #define WRS_POST_SIGNAL_LIMIT       20
     55          #define WRS_SIGNAL_MIN_INTERVALL    300
     56          #define WRS_SIGNAL_MAX_INTERVALL    600
     57          
     58          /* Examples of timeouts
     59          Lift phone:             Play:
     60          1E5                             11
     61          209                             163
     62          20C                             11
     63          200                             4
     64          216                             E8      
     65          1F3                             F5
     66          */
     67          
     68          #define P_PPD_PW                                        0x190
     69          #define P_RIPPLE_FILTER_TIMEOUT         10
     70          
     71          #define DEFAULT_PHONE_OUT_VOLUME        15
     72          
     73          ///////////////////////////////////
     74          // Strukturer
     75          
     76          
     77          ///////////////////////////////////
     78          // Funktioner och procedurer
     79          
     80          extern void    InitializePhone( void );
     81          extern void    HangUp( void );
     82          extern void    LiftPhone( void );
     83          
     84          #ifdef  __PPD_ON__
     85          extern void        ClearPPDRipple( void );
     86          #endif
     87          
     88          extern void    MonitorRingSignal( void );
     89          extern int         WaitForRingSignals(int  nSignals);
     90          
     91          #endif
     56          #include "Calender.h"
      1          /********************************************************
      2          Fil:            $Id: Calender.h,v 1.4 2003/11/20 22:08:52 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:52 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Calender.h,v $
      8                                          Revision 1.4  2003/11/20 22:08:52  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.3  2003/11/18 19:17:35  Gemensam
     13                                          Added menu option of setting speaker volume (untested)
     14                                          Completely changed header files
     15                                          Version 0200.
     16                                          
     17                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     18                                          Added header information
     19                                          
     20          
     21          ********************************************************/
     22          
     23          #ifndef _CALENDER_INCLUDED_
     24          #define _CALENDER_INCLUDED_
     25          
     26          ///////////////////////////////////
     27          // Definitioner
     28          
     29          // Non-volatile variabler:
     30          #define NV_ANSWERING_ON 0x08
     31          #define NV_NUM_SIGNALS  0x09
     32          #define NV_PLAYED_MS    0x0A
     33          #define NV_PLAYED_LS    0x0B
     34          #define NV_SPEAKER_VOL  0x0C
     35          //Max adress är 0x3F
     36          
     37          #define SDA    P3.0
     38          #define SCL    P3.1
     39          //#define SDA    P1.5
     40          //#define SCL    P1.6
     41          
     42          
     43          ///////////////////////////////////
     44          // Strukturer
     45          
     46          struct ST_TIME {
     47              char    seconds;
     48              char    minutes;
     49              char    hours;
     50          };
     51          #define TIME struct ST_TIME
     52          
     53          
     54          struct ST_DATE {
     55              char    day;
     56              char    date;
     57              char    month;
     58              char    year;
     59          };
     60          #define DATE struct ST_DATE
     61          
     62          ///////////////////////////////////
     63          // Funktioner och procedurer
     64          
     65          extern void    InitializeCalender( void );
     66          extern char    WOCB(char dat);
     67          extern char    ROCB(char ack);
     68          extern char    WriteCalenderByte(char address, char dat);
     69          extern char    ReadCalenderByte(char address, char* dat);
     70          extern void    GetTimeNow(TIME* tptr);
     71          extern void    GetDateNow(DATE* tptr);
     72          extern void    CreateTimeString(TIME* tptr, char* str);
     73          extern void    CreateDateString(DATE* tptr, char* str);
     74          extern void    CreateDateString2(DATE* tptr, char* str);
     75           
     76          
     77          ///////////////////////////
     78          // Variabler
     79          
     80          
     81          
     82          
     83           
     84          #endif
     57          #include "DPOT.h"
      1          /*************************************************************
      2          Fil:            $Id: DPot.h,v 1.2 2003/11/20 22:08:52 Gemensam Exp $
      3          
      4          Beskrivning:    Header fil till DPot.c
      5          
      6          Skapad:         03-11-17
      7          
      8          Ändrad:         $Date: 2003/11/20 22:08:52 $
      9          
     10          Ägare:          Fredrik Hoffman
     11          
     12          
     13          Att göra:
     14          
     15          Kommentarer:
     16          
     17              Varje pot har fyra nonvolatile register. Dessa definieras härmed enligt följande:
     18              *   0 = Zero Wiper  = 0
     19              *   1 = Variable Wiper  = ?
     20              *   2 = Oanvänd = X
     21              *   3 = Full Wiper = 255
     22              Vid initialiseringen skall värden för Zero och Full skrivas in i NV-registererna
     23              Sedan skall Wiper på alla pottar sättas till Zero.
     24          
     25          Revisionshistoria:
     26                                          $Log: DPot.h,v $
     27                                          Revision 1.2  2003/11/20 22:08:52  Gemensam
     28                                          Various declarations changes.
     29                                          Still version 0200.
     30                                          
     31                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     32                                          Added menu option of setting speaker volume (untested)
     33                                          Completely changed header files
     34                                          Version 0200.
     35                                          
     36          
     37          *************************************************************/
     38          
     39          #ifndef _DPOT_INCLUDED_
     40          #define _DPOT_INCLUDED_
     41          
     42          ///////////////////////////////////
     43          // Definitioner
     44          
     45          #define DPCL    P3.3
     46          #define DPDA    P3.4
     47           
     48          #define POT_PHONE_OUT   0x00
     49          #define POT_PHONE_IN    0x03
     50          #define POT_SPEAKER     0x01
     51          #define POT_DTMF        0x02
     52          
     53          #define DEFAULT_SPEAKER_VOLUME  50
     54          
     55          ///////////////////////////////////
     56          // Funktioner och procedurer
     57          
     58          extern void    InitializeDPot( void );
     59          extern void    RPWait( void );
     60          extern char    WOEPB(char dat);
     61          extern char    ROEPB(char ack);
     62          extern char    SetDPWiper(char pot, char value);
     63          extern char    ReadDPWiper(char pot, char* dat);
     64           
     65          extern void    SpeakerVolume(char volume);
     66          extern void    PhoneInVolume(char volume);
     67          extern void    PhoneOutVolume(char volume);
     68          extern void    DTMFVolume(char volume);
     69          
     70          #endif
     58          #include "main.h"
      1          /*************************************************************
      2          Fil:            $Id: Main.h,v 1.10 2003/12/26 16:17:01 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/12/26 16:17:01 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Main.h,v $
      8                                          Revision 1.10  2003/12/26 16:17:01  Gemensam
      9                                          Reinstate 500 ms wait for hang up detection to settle (if not PPD is used).
     10                                          Fixed PPD detection by decreasing phone volume from 63 to 15.
     11                                          Version 0304.
     12                                          
     13                                          Revision 1.9  2003/12/09 20:52:49  Gemensam
     14                                          Commented out PPD detection since the HW not work yet.
     15                                          Ver 0302.
     16                                          
     17                                          Revision 1.8  2003/11/29 22:35:59  Gemensam
     18                                          Fixed problem with to short pulse width on PPD.
     19                                          Ver 0302.
     20                                          
     21                                          Revision 1.7  2003/11/24 22:44:36  Gemensam
     22                                          Fixed PPD, not working yet,
     23                                          New command: speaker volume.
     24                                          Version 0301.
     25                                          
     26                                          Revision 1.6  2003/11/23 21:40:03  Gemensam
     27                                          Parallell phone detection included.
     28                                          Removed obsolete #define's regarding LCD interface.
     29                                          Ver 0300
     30                                          
     31                                          Revision 1.5  2003/11/23 20:29:34  Gemensam
     32                                          Complete and tested volume setting in options menu.
     33                                          Ver 0201
     34                                          
     35                                          Revision 1.4  2003/11/20 22:08:53  Gemensam
     36                                          Various declarations changes.
     37                                          Still version 0200.
     38                                          
     39                                          Revision 1.3  2003/11/18 19:17:36  Gemensam
     40                                          Added menu option of setting speaker volume (untested)
     41                                          Completely changed header files
     42                                          Version 0200.
     43                                          
     44                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     45                                          Added header information
     46                                          
     47          *************************************************************/
     48          
     49          #ifndef _MAIN_INCLUDED_
     50          #define _MAIN_INCLUDED_
     51          
     52          #include "FileSystem.h"
      1          /**************************************************************************************
      2          Fil:            $Id: FileSystem.h,v 1.4 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Kommentarer:    Filhuvudet befinner sig i "Spare" arean tillhörande filens första sida. Huvudet består 
      7                                          av 16 bytes enligt följande lista:
      8                                          0       Huvud       0xAA = Legalt filhuvud, annat tillsvidare odefinierat
      9                                          1-4     Fillängd    Pos 1 = MSB, pos 4 = LSB
     10                                          5-12    Filtitel    Enl "Titel.ext". Om titeln är mindre än 8 tecken avslutas det med nollor
     11                                          13-15   Filext      Enl "Titel.ext". Om ext är mindre än 3 tecken avslutas det med nollor
     12          
     13                                          En nolla skriven i fileName[0] indikerar att
     14                                          filstrukturen är ledig.
     15                  
     16          Revisionshistoria:
     17                                          $Log: FileSystem.h,v $
     18                                          Revision 1.4  2003/11/20 22:08:53  Gemensam
     19                                          Various declarations changes.
     20                                          Still version 0200.
     21                                          
     22                                          Revision 1.3  2003/11/18 19:17:36  Gemensam
     23                                          Added menu option of setting speaker volume (untested)
     24                                          Completely changed header files
     25                                          Version 0200.
     26                                          
     27                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     28                                          Added header information
     29                                          
     30          
     31          **************************************************************************************/
     32          
     33          #ifndef _FILESYSTEM_INCLUDED_
     34          #define _FILESYSTEM_INCLUDED_
     35          
     36          ///////////////////////////////////
     37          // Definitioner
     38          
     39          #define FS_MAXFILES         8 
     40          #define FS_FILENAMELENGTH   13
     41          #define FS_FLASHSIZE        0x800000
     42          
     43          #define OFF            0
     44          #define READY        1
     45          #define NEMPTY        2
     46          #define WRITING        3
     47          #define OCCUPIED    4
     48          
     49          #define CLE     P4.0                                //Command Latch Enable
     50          #define ALE     P4.1                                //Address Latch Enable
     51          #define WP      P4.2                                //Write Protect
     52          #define SE      P4.3                                //Spare Enable
     53          //#define CE      P4.4                                //Chip Enable
     54          #define FBUSY   P4.5                                //Busy
     55          
     56          #define FREG (*(unsigned char xdata *) 0xE000)
     57          #define FLASH (*(unsigned char xdata *) 0xB000) 
     58          
     59          ///////////////////////////////////
     60          // Strukturer
     61          
     62          struct ST_FILE_HEAD {
     63              unsigned long   length;
     64              char            name[FS_FILENAMELENGTH];
     65          };
     66          #define FILE_HEAD struct ST_FILE_HEAD
     67          
     68          
     69          struct ST_FILE {
     70              char            fileName[FS_FILENAMELENGTH];
     71              unsigned long   startAddress;
     72              unsigned long   length; 
     73              unsigned long   offset; 
     74              char            write;
     75              char            append;
     76          };
     77          #define FILE struct ST_FILE 
     78          
     79          
     80          
     81          ///////////////////////////////////
     82          // Funktioner och procedurer
     83          
     84          extern void            InitializeFileSystem( void );
     85          extern void            InitializeFlash( void );
     86          extern void            SetupReadSeq( void );
     87          extern unsigned char   ReadFLASH( void );
     88          extern void            TerminateReadSeq( void );
     89          extern void            GetDeviceIDRS232(void);
     90          extern void            SetupWriteSeq( void );
     91          extern void            WriteFLASH(unsigned char);
     92          extern void            TerminateWriteSeq( void );
     93          extern void            PerformWriteSeq( void );
     94          extern void            EraseBlock( void );
     95          extern void            WriteFileHead(const char* name, long size);
     96          extern FILE*           fopen(const char* name, const char* def);
     97          extern FILE*               fopenA(const char* name, long maxSize, long offset);
     98          extern void            fputc(FILE* filePtr, char c);
     99          extern void            fputLine(FILE* filePtr, const char* str);
    100          extern void            fupLoad( void );
    101          extern int             fgetc(FILE* filePtr);
    102          extern void            fgetLine(FILE* filePtr, char* str, int maxLen);
    103          extern void            fdownLoad( void );
    104          extern void            fclose(FILE* filePtr);
    105          extern long            ftell(FILE* filePtr);
    106          //void            Rewind(FILE* filePtr);
    107          extern void            fSetPos(FILE* filePtr, long offset);
    108          extern void            ReleaseCurrFile( void );
    109          extern void            EraseAll( void );
    110          extern void            StartDynamic( void );
    111          extern void            EraseDynamic( void );
    112          extern char                        MemUsage( void );
    113          extern void                        Dir( void );
    114          extern void                        Type( void );
    115          extern void                        TypeA( void );
    116          
    117          #endif
     53          
     54          
     55          ///////////////////////////////////
     56          // Definitioner
     57          
     58          #define VERSION_MENU_STRING     "Telestation 3.5       (c) 2004-09-19 FRHA"
     59          
     60          #define CM_PARSIZE              24
     61          #define CM_NRPAR                16
     62          
     63          #define MAX_LABEL_LEN   8
     64          #define MAX_LABELS      64
     65          
     66          // Nedan var ett försök till multipla bat-filer, kanske införs senare
     67          /*
     68          #define MAX_BATFILES    8
     69          */
     70          
     71          ///////////////////////////////////
     72          // Strukturer
     73          
     74          // Nedan var ett försök till multipla bat-filer, kanske införs senare
     75          /*
     76          struct ST_Label {
     77              char    name[MAX_LABEL_LEN];
     78              long    pos;
     79          };
     80          #define Label struct ST_Label
     81           
     82          struct ST_BatFileObj {
     83              FILE*       fp;                 //Filpekare till bat-filen
     84              Label*      labels;             //Pekare till lista med ingående labels
     85              char        labelIndex;         //Pekar på nästa lediga label
     86              BatFileObj* caller;             //Den batfil som kallade på denna. Om användaren gav kommandot 
     87                                              //skall den inehålla NULL
     88              char        occupied;           //1 om detta objekt används, 0 annars
     89          };    
     90          #define BatFileObj struct ST_BatFileObj
     91          */
     92          
     93          ///////////////////////////////////
     94          // Funktioner och procedurer
     95          
     96          extern void    InitializeComputer1( void );
     97          extern void    InitializePhoneAnsApp( void );
     98          extern void    MainShell( void );
     99          extern char    DecodeAndPerform(const char* cmdStr);
    100          //int     MainCommandInterper(char c);
    101          extern void    Hello( void );
    102          extern void    TestHW( void );
    103          extern void    FlashID( void );
    104          extern void    Erase( void );
    105          extern void    BackRead( void );
    106          extern void    ReadSpare( void );
    107          extern void    WF1( void );
    108          extern void    WF2( void );
    109          extern void    WF3( void );
    110          extern void    RF1( void );
    111          extern void    RF2( void );
    112          extern void    RF3( void );
    113          extern void    CreateLong( void );
    114          extern void    ReadSpare2( void );
    115          extern void    Append( void );
    116          
    117          extern void    SetupBatFile( void );
    118          extern void    ClearLabelList( void );
    119          extern void    ExecuteBatFile(const char* batFileName);
    120          extern char    InsertLabel(const char* name, long pos);
    121          extern int     FindLabel(const char *name);
    122          extern char    GotoLabel(const char* name);
    123          
    124          extern void    myStrCpy(char* dest, const char* src);
    125          extern int     myStrLen(char* str);
    126          extern void    myLong2HexStr(long v, char* str);
    127          extern void    myInt2DecStr(int v, char* str);
    128          extern void    myInt2DecStr00(char v, char* str);
    129          extern int     myStr2Int(const char* str);
    130          extern char    myStrCmpNoCase(const char* s1, const char* s2);
    131          
    132          // Nedan var ett försök till multipla bat-filer, kanske införs senare
    133          /*
    134          void    SetupBatFile( void );
    135          void    ClearLabelList( void );
    136          void    ClearLabelList(Label* list);
    137          BatFileObj*    VacantBatFileObj(FILE* fp);
    138          void    ExecuteBatFile(const char* batFileName);
    139          char    InsertLabel(const char* name, long pos);
    140          char    FindLabel(const char *name, Label* l);
    141          char    GotoLabel(const char* name);
    142          */
    143          
    144          ///////////////////////////
    145          // Globala variabler
    146          
    147          
    148          ///////////////////////////
    149          // Lokala variabler
    150          
    151          
    152          #endif
     59          #include "RS232.h"
      1          /********************************************************
      2          Fil:            $Id: RS232.h,v 1.2 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Revisionshistoria:
      7                                          $Log: RS232.h,v $
      8                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     13                                          Added menu option of setting speaker volume (untested)
     14                                          Completely changed header files
     15                                          Version 0200.
     16                                          
     17                                          
     18          
     19          ********************************************************/
     20          
     21          #ifndef _RS232_INCLUDED_
     22          #define _RS232_INCLUDED_
     23          
     24          ///////////////////////////////////
     25          // Definitioner
     26          
     27          
     28          ///////////////////////////////////
     29          // Strukturer
     30          
     31          
     32          ///////////////////////////////////
     33          // Funktioner och procedurer
     34          
     35          extern void             InitializeRS232( void );
     36          extern void             SendRS232(char tecken);
     37          extern void             SendStringRS232(const char *str);
     38          extern void             SendStringEOLRS232(const char *str);
     39          extern char             WaitAndReceiveRS232( void );
     40          extern char             WaitAndReceiveTimeout( void );
     41          extern int      ReceiveLineRS232(char* str, int maxLen);
     42          
     43          #endif
     60          #include "WAV.h"
      1          /********************************************************
      2          Fil:            $Id: wav.h,v 1.1 2003/11/23 20:29:34 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/23 20:29:34 $
      5          
      6          Revisionshistoria:
      7                                          $Log: wav.h,v $
      8                                          Revision 1.1  2003/11/23 20:29:34  Gemensam
      9                                          Complete and tested volume setting in options menu.
     10                                          Ver 0201
     11                                          
     12                                          
     13          
     14          ********************************************************/
     15          
     16          #ifndef _WAV_INCLUDED_
     17          #define _WAV_INCLUDED_
     18          
     19          ///////////////////////////////////
     20          // Definitioner
     21          
     22          #define WS_NO_OP        0x00
     23          #define WS_REC          0x01
     24          #define WS_PLAY         0x02
     25          #define WS_ECHO         0x03
     26          #define WS_TONE         0x04
     27          #define WS_PORT1        0x05
     28           
     29          #define DAC0 (*(unsigned char xdata *) 0xA000)
     30          #define DAC1 (*(unsigned char xdata *) 0xA001)
     31          #define DAC2 (*(unsigned char xdata *) 0xA002)
     32          #define DAC3 (*(unsigned char xdata *) 0xA003)
     33          
     34          #define WAVBUFSIZE  512
     35          
     36          //#define SPEAKER_ON  P1.5 = 1
     37          //#define SPEAKER_OFF  P1.5 = 0
     38          
     39          ///////////////////////////////////
     40          // Strukturer
     41          
     42          
     43          ///////////////////////////////////
     44          // Funktioner och procedurer
     45          
     46          extern void    InitializeWAV( void );
     47          extern void    SetupMic( void );
     48          extern void    SetupPhoneIn( void );
     49          extern void    RecMicFile(const char* fileName);
     50          extern void    RecPhoneFile(const char* fileName);
     51          extern void    RecFile(const char* fileName);
     52          extern void    PlayFile(const char* fileName);
     53          extern void    EchoMic( void );
     54          extern void    EchoPhone( void );
     55          extern void    Echo( void );
     56          extern void    WavTone( void );
     57           
     58          #endif
     61          #include "DTMF.h"
      1          /*************************************************************
      2          Fil:            $Id: DTMF.h,v 1.2 2003/11/20 22:08:52 Gemensam Exp $
      3          
      4          Beskrivning:    Header fil till DTMF.c
      5          
      6          Skapad:         03-11-18
      7          
      8          Ändrad:         $Date: 2003/11/20 22:08:52 $
      9          
     10          Ägare:          Fredrik Hoffman
     11          
     12          
     13          Att göra:
     14          
     15          Revisionshistoria:
     16                                          $Log: DTMF.h,v $
     17                                          Revision 1.2  2003/11/20 22:08:52  Gemensam
     18                                          Various declarations changes.
     19                                          Still version 0200.
     20                                          
     21                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     22                                          Added menu option of setting speaker volume (untested)
     23                                          Completely changed header files
     24                                          Version 0200.
     25                                          
     26          
     27          *************************************************************/
     28          
     29          #ifndef _DTMF_INCLUDED_
     30          #define _DTMF_INCLUDED_
     31          
     32          ///////////////////////////////////
     33          // Definitioner
     34          
     35          #define DTMF_TRANS      (*(unsigned char xdata *) 0x9000)
     36          #define DTMF_READ       (*(unsigned char xdata *) 0x9000)
     37          #define DTMF_CONTROL    (*(unsigned char xdata *) 0x9001)
     38          #define DTMF_STATUS     (*(unsigned char xdata *) 0x9001)
     39           
     40          ///////////////////////////////////
     41          // Funktioner och procedurer
     42          
     43          extern void    InitializeDTMF( void );
     44          extern void    MakeDTMFTones(const char *tones);
     45          extern char    DecodeDTMF(char c);
     46          extern char    DecodeReceivedDTMF( void );
     47          extern void    ResetDTMFIndex( void );
     48          extern char    GetNextDTMF( void );
     49           
     50          #endif
     62          #include "Phone.h"
      1          /********************************************************
      2          Fil:            $Id: Phone.h,v 1.6 2003/12/26 16:17:01 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/12/26 16:17:01 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Phone.h,v $
      8                                          Revision 1.6  2003/12/26 16:17:01  Gemensam
      9                                          Reinstate 500 ms wait for hang up detection to settle (if not PPD is used).
     10                                          Fixed PPD detection by decreasing phone volume from 63 to 15.
     11                                          Version 0304.
     12                                          
     13                                          Revision 1.5  2003/11/29 22:36:00  Gemensam
     14                                          Fixed problem with to short pulse width on PPD.
     15                                          Ver 0302.
     16                                          
     17                                          Revision 1.4  2003/11/24 22:44:36  Gemensam
     18                                          Fixed PPD, not working yet,
     19                                          New command: speaker volume.
     20                                          Version 0301.
     21                                          
     22                                          Revision 1.3  2003/11/23 21:40:03  Gemensam
     23                                          Parallell phone detection included.
     24                                          Removed obsolete #define's regarding LCD interface.
     25                                          Ver 0300
     26                                          
     27                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
     28                                          Various declarations changes.
     29                                          Still version 0200.
     30                                          
     31                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     32                                          Added menu option of setting speaker volume (untested)
     33                                          Completely changed header files
     34                                          Version 0200.
     35                                          
     36                                          
     37          
     38          ********************************************************/
     39          
     40          #ifndef _PHONE_INCLUDED_
     41          #define _PHONE_INCLUDED_
     42          
     43          ///////////////////////////////////
     44          // Definitioner
     45          
     46          //PS = Phone Signals
     47          #define PS_RV                                           P1.2
     48          #define PS_LC                                           P1.7
     49          #define PS_LCD                                          P1.1
     50          #define PS_PPD                                          P1.0
     51          
     52          #define WRS_POS_EDGE_TRIGG          10
     53          #define WRS_NEG_EDGE_TRIGG          10
     54          #define WRS_POST_SIGNAL_LIMIT       20
     55          #define WRS_SIGNAL_MIN_INTERVALL    300
     56          #define WRS_SIGNAL_MAX_INTERVALL    600
     57          
     58          /* Examples of timeouts
     59          Lift phone:             Play:
     60          1E5                             11
     61          209                             163
     62          20C                             11
     63          200                             4
     64          216                             E8      
     65          1F3                             F5
     66          */
     67          
     68          #define P_PPD_PW                                        0x190
     69          #define P_RIPPLE_FILTER_TIMEOUT         10
     70          
     71          #define DEFAULT_PHONE_OUT_VOLUME        15
     72          
     73          ///////////////////////////////////
     74          // Strukturer
     75          
     76          
     77          ///////////////////////////////////
     78          // Funktioner och procedurer
     79          
     80          extern void    InitializePhone( void );
     81          extern void    HangUp( void );
     82          extern void    LiftPhone( void );
     83          
     84          #ifdef  __PPD_ON__
     85          extern void        ClearPPDRipple( void );
     86          #endif
     87          
     88          extern void    MonitorRingSignal( void );
     89          extern int         WaitForRingSignals(int  nSignals);
     90          
     91          #endif
     63          #include "Timer.h"
      1          /********************************************************
      2          Fil:            $Id: Timer.h,v 1.2 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Timer.h,v $
      8                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     13                                          Added menu option of setting speaker volume (untested)
     14                                          Completely changed header files
     15                                          Version 0200.
     16                                          
     17                                          
     18          
     19          ********************************************************/
     20          
     21          #ifndef _TIMER_INCLUDED_
     22          #define _TIMER_INCLUDED_
     23          
     24          ///////////////////////////////////
     25          // Definitioner
     26          
     27          #define TM_MAX_TIMERS   5
     28          
     29          ///////////////////////////////////
     30          // Strukturer
     31          
     32          
     33          ///////////////////////////////////
     34          // Funktioner och procedurer
     35          
     36          extern void    InitializeTimer( void );
     37          extern char    StartTimer(unsigned int tenMillisecTimeout);
     38          extern void    KillTimer(char  timerIndex);
     39          extern char    TimedOut(char timerIndex);
     40          extern void    WaitFor(unsigned int tenMillisec);
     41           
     42          #endif
     64          #include "PhoneAns.h"
      1          /********************************************************
      2          Fil:            $Id: PhoneAns.h,v 1.2 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Revisionshistoria:
      7                                          $Log: PhoneAns.h,v $
      8                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     13                                          Added menu option of setting speaker volume (untested)
     14                                          Completely changed header files
     15                                          Version 0200.
     16                                          
     17                                          
     18          
     19          ********************************************************/
     20          
     21          #ifndef _PHONEANS_INCLUDED_
     22          #define _PHONEANS_INCLUDED_
     23          
     24          #include "Main.h"
      1          /*************************************************************
      2          Fil:            $Id: Main.h,v 1.10 2003/12/26 16:17:01 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/12/26 16:17:01 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Main.h,v $
      8                                          Revision 1.10  2003/12/26 16:17:01  Gemensam
      9                                          Reinstate 500 ms wait for hang up detection to settle (if not PPD is used).
     10                                          Fixed PPD detection by decreasing phone volume from 63 to 15.
     11                                          Version 0304.
     12                                          
     13                                          Revision 1.9  2003/12/09 20:52:49  Gemensam
     14                                          Commented out PPD detection since the HW not work yet.
     15                                          Ver 0302.
     16                                          
     17                                          Revision 1.8  2003/11/29 22:35:59  Gemensam
     18                                          Fixed problem with to short pulse width on PPD.
     19                                          Ver 0302.
     20                                          
     21                                          Revision 1.7  2003/11/24 22:44:36  Gemensam
     22                                          Fixed PPD, not working yet,
     23                                          New command: speaker volume.
     24                                          Version 0301.
     25                                          
     26                                          Revision 1.6  2003/11/23 21:40:03  Gemensam
     27                                          Parallell phone detection included.
     28                                          Removed obsolete #define's regarding LCD interface.
     29                                          Ver 0300
     30                                          
     31                                          Revision 1.5  2003/11/23 20:29:34  Gemensam
     32                                          Complete and tested volume setting in options menu.
     33                                          Ver 0201
     34                                          
     35                                          Revision 1.4  2003/11/20 22:08:53  Gemensam
     36                                          Various declarations changes.
     37                                          Still version 0200.
     38                                          
     39                                          Revision 1.3  2003/11/18 19:17:36  Gemensam
     40                                          Added menu option of setting speaker volume (untested)
     41                                          Completely changed header files
     42                                          Version 0200.
     43                                          
     44                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     45                                          Added header information
     46                                          
     47          *************************************************************/
     48          
     49          #ifndef _MAIN_INCLUDED_
     50          #define _MAIN_INCLUDED_
     51          
     52          #include "FileSystem.h"
     53          
     54          
     55          ///////////////////////////////////
     56          // Definitioner
     57          
     58          #define VERSION_MENU_STRING     "Telestation 3.5       (c) 2004-09-19 FRHA"
     59          
     60          #define CM_PARSIZE              24
     61          #define CM_NRPAR                16
     62          
     63          #define MAX_LABEL_LEN   8
     64          #define MAX_LABELS      64
     65          
     66          // Nedan var ett försök till multipla bat-filer, kanske införs senare
     67          /*
     68          #define MAX_BATFILES    8
     69          */
     70          
     71          ///////////////////////////////////
     72          // Strukturer
     73          
     74          // Nedan var ett försök till multipla bat-filer, kanske införs senare
     75          /*
     76          struct ST_Label {
     77              char    name[MAX_LABEL_LEN];
     78              long    pos;
     79          };
     80          #define Label struct ST_Label
     81           
     82          struct ST_BatFileObj {
     83              FILE*       fp;                 //Filpekare till bat-filen
     84              Label*      labels;             //Pekare till lista med ingående labels
     85              char        labelIndex;         //Pekar på nästa lediga label
     86              BatFileObj* caller;             //Den batfil som kallade på denna. Om användaren gav kommandot 
     87                                              //skall den inehålla NULL
     88              char        occupied;           //1 om detta objekt används, 0 annars
     89          };    
     90          #define BatFileObj struct ST_BatFileObj
     91          */
     92          
     93          ///////////////////////////////////
     94          // Funktioner och procedurer
     95          
     96          extern void    InitializeComputer1( void );
     97          extern void    InitializePhoneAnsApp( void );
     98          extern void    MainShell( void );
     99          extern char    DecodeAndPerform(const char* cmdStr);
    100          //int     MainCommandInterper(char c);
    101          extern void    Hello( void );
    102          extern void    TestHW( void );
    103          extern void    FlashID( void );
    104          extern void    Erase( void );
    105          extern void    BackRead( void );
    106          extern void    ReadSpare( void );
    107          extern void    WF1( void );
    108          extern void    WF2( void );
    109          extern void    WF3( void );
    110          extern void    RF1( void );
    111          extern void    RF2( void );
    112          extern void    RF3( void );
    113          extern void    CreateLong( void );
    114          extern void    ReadSpare2( void );
    115          extern void    Append( void );
    116          
    117          extern void    SetupBatFile( void );
    118          extern void    ClearLabelList( void );
    119          extern void    ExecuteBatFile(const char* batFileName);
    120          extern char    InsertLabel(const char* name, long pos);
    121          extern int     FindLabel(const char *name);
    122          extern char    GotoLabel(const char* name);
    123          
    124          extern void    myStrCpy(char* dest, const char* src);
    125          extern int     myStrLen(char* str);
    126          extern void    myLong2HexStr(long v, char* str);
    127          extern void    myInt2DecStr(int v, char* str);
    128          extern void    myInt2DecStr00(char v, char* str);
    129          extern int     myStr2Int(const char* str);
    130          extern char    myStrCmpNoCase(const char* s1, const char* s2);
    131          
    132          // Nedan var ett försök till multipla bat-filer, kanske införs senare
    133          /*
    134          void    SetupBatFile( void );
    135          void    ClearLabelList( void );
    136          void    ClearLabelList(Label* list);
    137          BatFileObj*    VacantBatFileObj(FILE* fp);
    138          void    ExecuteBatFile(const char* batFileName);
    139          char    InsertLabel(const char* name, long pos);
    140          char    FindLabel(const char *name, Label* l);
    141          char    GotoLabel(const char* name);
    142          */
    143          
    144          ///////////////////////////
    145          // Globala variabler
    146          
    147          
    148          ///////////////////////////
    149          // Lokala variabler
    150          
    151          
    152          #endif
     25          #include "Calender.h"
      1          /********************************************************
      2          Fil:            $Id: Calender.h,v 1.4 2003/11/20 22:08:52 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:52 $
      5          
      6          Revisionshistoria:
      7                                          $Log: Calender.h,v $
      8                                          Revision 1.4  2003/11/20 22:08:52  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.3  2003/11/18 19:17:35  Gemensam
     13                                          Added menu option of setting speaker volume (untested)
     14                                          Completely changed header files
     15                                          Version 0200.
     16                                          
     17                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     18                                          Added header information
     19                                          
     20          
     21          ********************************************************/
     22          
     23          #ifndef _CALENDER_INCLUDED_
     24          #define _CALENDER_INCLUDED_
     25          
     26          ///////////////////////////////////
     27          // Definitioner
     28          
     29          // Non-volatile variabler:
     30          #define NV_ANSWERING_ON 0x08
     31          #define NV_NUM_SIGNALS  0x09
     32          #define NV_PLAYED_MS    0x0A
     33          #define NV_PLAYED_LS    0x0B
     34          #define NV_SPEAKER_VOL  0x0C
     35          //Max adress är 0x3F
     36          
     37          #define SDA    P3.0
     38          #define SCL    P3.1
     39          //#define SDA    P1.5
     40          //#define SCL    P1.6
     41          
     42          
     43          ///////////////////////////////////
     44          // Strukturer
     45          
     46          struct ST_TIME {
     47              char    seconds;
     48              char    minutes;
     49              char    hours;
     50          };
     51          #define TIME struct ST_TIME
     52          
     53          
     54          struct ST_DATE {
     55              char    day;
     56              char    date;
     57              char    month;
     58              char    year;
     59          };
     60          #define DATE struct ST_DATE
     61          
     62          ///////////////////////////////////
     63          // Funktioner och procedurer
     64          
     65          extern void    InitializeCalender( void );
     66          extern char    WOCB(char dat);
     67          extern char    ROCB(char ack);
     68          extern char    WriteCalenderByte(char address, char dat);
     69          extern char    ReadCalenderByte(char address, char* dat);
     70          extern void    GetTimeNow(TIME* tptr);
     71          extern void    GetDateNow(DATE* tptr);
     72          extern void    CreateTimeString(TIME* tptr, char* str);
     73          extern void    CreateDateString(DATE* tptr, char* str);
     74          extern void    CreateDateString2(DATE* tptr, char* str);
     75           
     76          
     77          ///////////////////////////
     78          // Variabler
     79          
     80          
     81          
     82          
     83           
     84          #endif
     26          
     27          ///////////////////////////////////
     28          // Definitioner
     29          
     30          #define MS_LOG          0x01
     31          #define MS_MENU         0x02
     32          #define MS_TIMEDATE     0x03
     33          #define MS_ERASEQST     0x04
     34          #define MS_MEMO         0x05
     35          
     36          #define PB_MAXENTRIES   512
     37          #define PB_POSTSIZE     32
     38          
     39          ///////////////////////////////////
     40          // Strukturer
     41          
     42          
     43          ///////////////////////////////////
     44          // Funktioner och procedurer
     45          
     46          extern void    InitializePhoneAns( void );
     47          extern void    WaitForCall( void );
     48          extern void    CorrectDate(char changedDate);
     49          extern void    RecordCallerMessage( void );
     50          extern void    AskQuestionMsg( void );
     51          extern void    EnterCode( void );
     52          extern void    SetupUpQLabels( void );
     53          extern void    LabelCopy(char* dest, const char* src);
     54          extern void    CreateUniqueFilename(char* str);
     55          extern void    ShowTimeDateSet( void );
     56          extern void    ShowEraseQuest( void );
     57          extern void    ReadPhoneBookFile( void );
     58          extern void    LookUpCaller(char* number, char* name,  char* category);
     59          extern void    IntitializeMemo( void );
     60          extern void    RecordMemo( void );
     61          extern void    PlayMemo( void );
     62          extern void    CreateMemoFileName(int index, char* str);
     63          extern char    CategoryHit(char* str, char category);
     64          
     65          #endif
     65          #include "LCD.h"
      1          /********************************************************
      2          Fil:            $Id: LCD.h,v 1.4 2003/11/23 21:40:03 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/23 21:40:03 $
      5          
      6          Revisionshistoria:
      7                                          $Log: LCD.h,v $
      8                                          Revision 1.4  2003/11/23 21:40:03  Gemensam
      9                                          Parallell phone detection included.
     10                                          Removed obsolete #define's regarding LCD interface.
     11                                          Ver 0300
     12                                          
     13                                          Revision 1.3  2003/11/23 20:29:34  Gemensam
     14                                          Complete and tested volume setting in options menu.
     15                                          Ver 0201
     16                                          
     17                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
     18                                          Various declarations changes.
     19                                          Still version 0200.
     20                                          
     21                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     22                                          Added menu option of setting speaker volume (untested)
     23                                          Completely changed header files
     24                                          Version 0200.
     25                                          
     26                                          
     27          
     28          ********************************************************/
     29          
     30          #ifndef _LCD_INCLUDED_
     31          #define _LCD_INCLUDED_
     32          
     33          ///////////////////////////////////
     34          // Definitioner
     35          
     36          #define LCD_DATA      (*(unsigned char xdata *) 0x8000)
     37          #define LCD_INSTR     (*(unsigned char xdata *) 0x8001)
     38          #define LCD_BUSY      (*(unsigned char xdata *) 0x8001)
     39          
     40          #define DISPBUFFERSIZE  50
     41          // DISPBUFFERSIZE är antalet samtal i dispBuffer (samtalsindexerat)
     42          #define DISPCALLSIZE  40
     43          // DISPCALLSIZE är antalet byte per samtalsrad
     44           
     45          #define LCD_CHAR_PER_ROW        42
     46          
     47          #define MENU_LEFT_COLUMN        4
     48          
     49          #define MENU_ITEM_SPKR_VOL      0
     50          #define MENU_ITEM_ANS_ONOFF     1
     51          #define MENU_ITEM_MEMO          2
     52          #define MENU_ITEM_TIMEDATE      3
     53          #define MENU_ITEM_NUMSIG        4
     54          #define MENU_ITEM_ERASE         5
     55          #define MENU_NUM_OF_ITEMS       6
     56          
     57          
     58          ///////////////////////////////////
     59          // Strukturer
     60          
     61          
     62          ///////////////////////////////////
     63          // Funktioner och procedurer
     64          
     65          extern void    InitializeLCD( void );
     66          extern void    ClearDisp( void );
     67          extern void    DispString(char* str);
     68          extern void    SetLCDReg(char regNr, char d);
     69          extern void    LogCursorAt(int newCursorPos, char updateAlways);
     70          extern void    FillDispBuffer(void);
     71          extern void    DispInfoBox(char* str1, char* str2);
     72          extern void    DisplayMenu(char* menuStr);
     73          extern void    DispMemUsage( void );
     74          extern void    OptionCursorAt(int  newCursorPos);
     75          extern void    DispOptionsMenu(char answerOn, char numSignals);
     76          extern void    DispSetTimeDate(char cursor, char year, char month, char day, char hour, char minute);
     77          extern void    DispSetTimeDateHead( void );
     78          extern void    DispEraseQuest( void );
     79          extern void    DispMemoScreen( void );
     80          
     81          #endif
     66          #include "Keyboard.h"
      1          /*************************************************************
      2          Fil:            $Id: Keyboard.h,v 1.2 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Beskrivning:    Header fil till Keyboard.c
      5          
      6          Skapad:         03-11-18
      7          
      8          Ändrad:         $Date: 2003/11/20 22:08:53 $
      9          
     10          Ägare:          Fredrik Hoffman
     11          
     12          
     13          Att göra:
     14          
     15          Kommentarer:
     16          
     17          Revisionshistoria:
     18                                          $Log: Keyboard.h,v $
     19                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
     20                                          Various declarations changes.
     21                                          Still version 0200.
     22                                          
     23                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     24                                          Added menu option of setting speaker volume (untested)
     25                                          Completely changed header files
     26                                          Version 0200.
     27                                          
     28          
     29          *************************************************************/
     30          
     31          #ifndef _KEYBOARD_INCLUDED_
     32          #define _KEYBOARD_INCLUDED_
     33          
     34          ///////////////////////////////////
     35          // Definitioner
     36          
     37          #define KEYBOARD    (*(unsigned char xdata *) 0xC000)
     38          #define KEY_CLK     P1.6
     39          #define KEY_IRQ     P1.4
     40          
     41          #define KS_IDLE         0x00
     42          #define KS_WAITFIRST    0x01
     43          #define KS_WAITMULTI    0x02
     44          
     45          #define FIRST_KEY_TIMEOUT   10
     46          #define MULTI_KEY_TIMEOUT   2
     47           
     48          
     49          ///////////////////////////////////
     50          // Funktioner och procedurer
     51          
     52          extern void    InitializeKeyboard( void );
     53          extern void    KeyboardOn( void );
     54          extern void    KeyboardOff( void );
     55           
     56          #endif
     67          #include "Logfile.h"
      1          /********************************************************
      2          Fil:            $Id: LogFile.h,v 1.2 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Revisionshistoria:
      7                                          $Log: LogFile.h,v $
      8                                          Revision 1.2  2003/11/20 22:08:53  Gemensam
      9                                          Various declarations changes.
     10                                          Still version 0200.
     11                                          
     12                                          Revision 1.1  2003/11/18 19:17:36  Gemensam
     13                                          Added menu option of setting speaker volume (untested)
     14                                          Completely changed header files
     15                                          Version 0200.
     16                                          
     17                                          
     18          
     19          ********************************************************/
     20          
     21          #ifndef _LOGFILE_INCLUDED_
     22          #define _LOGFILE_INCLUDED_
     23          
     24          #include "FileSystem.h"
      1          /**************************************************************************************
      2          Fil:            $Id: FileSystem.h,v 1.4 2003/11/20 22:08:53 Gemensam Exp $
      3          
      4          Ändrad:         $Date: 2003/11/20 22:08:53 $
      5          
      6          Kommentarer:    Filhuvudet befinner sig i "Spare" arean tillhörande filens första sida. Huvudet består 
      7                                          av 16 bytes enligt följande lista:
      8                                          0       Huvud       0xAA = Legalt filhuvud, annat tillsvidare odefinierat
      9                                          1-4     Fillängd    Pos 1 = MSB, pos 4 = LSB
     10                                          5-12    Filtitel    Enl "Titel.ext". Om titeln är mindre än 8 tecken avslutas det med nollor
     11                                          13-15   Filext      Enl "Titel.ext". Om ext är mindre än 3 tecken avslutas det med nollor
     12          
     13                                          En nolla skriven i fileName[0] indikerar att
     14                                          filstrukturen är ledig.
     15                  
     16          Revisionshistoria:
     17                                          $Log: FileSystem.h,v $
     18                                          Revision 1.4  2003/11/20 22:08:53  Gemensam
     19                                          Various declarations changes.
     20                                          Still version 0200.
     21                                          
     22                                          Revision 1.3  2003/11/18 19:17:36  Gemensam
     23                                          Added menu option of setting speaker volume (untested)
     24                                          Completely changed header files
     25                                          Version 0200.
     26                                          
     27                                          Revision 1.2  2003/11/10 22:44:45  Gemensam
     28                                          Added header information
     29                                          
     30          
     31          **************************************************************************************/
     32          
     33          #ifndef _FILESYSTEM_INCLUDED_
     34          #define _FILESYSTEM_INCLUDED_
     35          
     36          ///////////////////////////////////
     37          // Definitioner
     38          
     39          #define FS_MAXFILES         8 
     40          #define FS_FILENAMELENGTH   13
     41          #define FS_FLASHSIZE        0x800000
     42          
     43          #define OFF            0
     44          #define READY        1
     45          #define NEMPTY        2
     46          #define WRITING        3
     47          #define OCCUPIED    4
     48          
     49          #define CLE     P4.0                                //Command Latch Enable
     50          #define ALE     P4.1                                //Address Latch Enable
     51          #define WP      P4.2                                //Write Protect
     52          #define SE      P4.3                                //Spare Enable
     53          //#define CE      P4.4                                //Chip Enable
     54          #define FBUSY   P4.5                                //Busy
     55          
     56          #define FREG (*(unsigned char xdata *) 0xE000)
     57          #define FLASH (*(unsigned char xdata *) 0xB000) 
     58          
     59          ///////////////////////////////////
     60          // Strukturer
     61          
     62          struct ST_FILE_HEAD {
     63              unsigned long   length;
     64              char            name[FS_FILENAMELENGTH];
     65          };
     66          #define FILE_HEAD struct ST_FILE_HEAD
     67          
     68          
     69          struct ST_FILE {
     70              char            fileName[FS_FILENAMELENGTH];
     71              unsigned long   startAddress;
     72              unsigned long   length; 
     73              unsigned long   offset; 
     74              char            write;
     75              char            append;
     76          };
     77          #define FILE struct ST_FILE 
     78          
     79          
     80          
     81          ///////////////////////////////////
     82          // Funktioner och procedurer
     83          
     84          extern void            InitializeFileSystem( void );
     85          extern void            InitializeFlash( void );
     86          extern void            SetupReadSeq( void );
     87          extern unsigned char   ReadFLASH( void );
     88          extern void            TerminateReadSeq( void );
     89          extern void            GetDeviceIDRS232(void);
     90          extern void            SetupWriteSeq( void );
     91          extern void            WriteFLASH(unsigned char);
     92          extern void            TerminateWriteSeq( void );
     93          extern void            PerformWriteSeq( void );
     94          extern void            EraseBlock( void );
     95          extern void            WriteFileHead(const char* name, long size);
     96          extern FILE*           fopen(const char* name, const char* def);
     97          extern FILE*               fopenA(const char* name, long maxSize, long offset);
     98          extern void            fputc(FILE* filePtr, char c);
     99          extern void            fputLine(FILE* filePtr, const char* str);
    100          extern void            fupLoad( void );
    101          extern int             fgetc(FILE* filePtr);
    102          extern void            fgetLine(FILE* filePtr, char* str, int maxLen);
    103          extern void            fdownLoad( void );
    104          extern void            fclose(FILE* filePtr);
    105          extern long            ftell(FILE* filePtr);
    106          //void            Rewind(FILE* filePtr);
    107          extern void            fSetPos(FILE* filePtr, long offset);
    108          extern void            ReleaseCurrFile( void );
    109          extern void            EraseAll( void );
    110          extern void            StartDynamic( void );
    111          extern void            EraseDynamic( void );
    112          extern char                        MemUsage( void );
    113          extern void                        Dir( void );
    114          extern void                        Type( void );
    115          extern void                        TypeA( void );
    116          
    117          #endif
     25          
     26          ///////////////////////////////////
     27          // Definitioner
     28          
     29          #define MS_LOG          0x01
     30          #define MS_MENU         0x02
     31          #define MS_TIMEDATE     0x03
     32          #define MS_ERASEQST     0x04
     33          
     34          ///////////////////////////////////
     35          // Strukturer
     36          
     37          
     38          ///////////////////////////////////
     39          // Funktioner och procedurer
     40          
     41          extern void    InitializeLogFile( void );
     42          extern void    CreateLog( void );
     43          extern void    LogMessage(const char* str1, const char* str2);
     44          extern char    BuildCallerList( void );
     45          extern char    FindCall(FILE* fp, int index);
     46          extern char    FindNextCall(FILE* fp);
     47          extern void    GetCallInformation(FILE* fp, char* phoneNumber, char* time, int* noOfMessages);
     48          extern char    PlayThisCall(int callIndex);
     49          extern void    PlayNewMessages( void );
     50          
     51          #endif
     68          
     69          
     70          //////////////////////
     71          // Globala variabler
     72          
     73          extern xdata int        lastPlayed;                     //Kronologindexerad
     74          extern xdata char       receivedDTMF;           //Innehåller den senaste mottagna DTMF-signalen
     75                                                                                          //från avbrottsrutinen. Om inget tagits emot sätts
     76                                                                                          //den till 0. För att få ett användbart värde skall
     77                                                                                          //funktionen DecodeDTMF() köras.
     78          extern xdata char       answerOn;
     79          extern xdata char   callerCategory;
     80          extern xdata char   numSignals;
     81          extern xdata char       speakerVolume;
     82          
     83          xdata char                      commandLine[CM_PARSIZE][CM_NRPAR];      //Här lagras kommandot och alla parametrar
     84                                                                                          //Varje kommando/parameter får vara max cmParSize tecken
     85                                                                                          //Till varje kommando kan cmNrPar-1 kopplas
     86          xdata int                       nrCommandParameters;//Här anges antal strängar kommandot bygger upp (dvs
     87                                                                                                                          //antal parametrar + 1 för kommandot
     88          xdata int                       error;                          //Error-kod, se definitioner ovan
     89          xdata char                      msg[100];
     90          xdata char                      timeout;                        //Tidsmätningsvariabel
     91          xdata FILE*                     batFilePtr;
     92          xdata char                      batLabelName[MAX_LABELS][MAX_LABEL_LEN];
     93          xdata long                      batLabelPos[MAX_LABELS];
     94          
     95          // Nedan var ett försök till multipla bat-filer, kanske införs senare
     96          /*
     97          BatFileObj* currentBatFile;
     98          BatFileObj  batFiles[MAX_BATFILES];
     99          Label       labelList0[MAX_LABELS];
    100          Label       labelList1[MAX_LABELS];
    101          Label       labelList2[MAX_LABELS];
    102          Label       labelList3[MAX_LABELS];
    103          Label       labelList4[MAX_LABELS];
    104          Label       labelList5[MAX_LABELS];
    105          Label       labelList6[MAX_LABELS];
    106          Label       labelList7[MAX_LABELS];
    107          */
    108          
    109          
    110          //////////////////////
    111          // Lokala variabler
    112          
    113          
    114          //////////////////////
    115          // Kod
    116          
    117          void main( void ) 
    118          {   
   \   0000            main:
   \   0000  900000            MOV     DPTR,#$LOCBX main+1
   \   0003  D0E0              POP     ACC
   \   0005  F0                MOVX    @DPTR,A
   \   0006  A3                INC     DPTR
   \   0007  D0E0              POP     ACC
   \   0009  F0                MOVX    @DPTR,A
    119              xdata char    timer;
    120          
    121          //-------------------------------------------
    122          // Initialisering av serieport 1 (RS232-porten)
    123          
    124              InitializeRS232();
   \   000A  120000            LCALL   $REFFN InitializeRS232
    125          
    126              if ((IP0 & 1<<6) == 0) {
   \   000D  E5A9              MOV     A,169
   \   000F  20E60B            JB      ACC.6,?0001
   \   0012            ?0000:
    127                  SendStringEOLRS232("The SuperComputer and FRHA welcomes you, ver2");
   \   0012  7D00              MOV     R5,#LOW(?0002)
   \   0014  7E00              MOV     R6,#HIGH(?0002)
   \   0016  7F02              MOV     R7,#2
   \   0018  120000            LCALL   $REFFN SendStringEOLRS232
    128              } else {
   \   001B  8009              SJMP    ?0003
   \   001D            ?0001:
    129                  SendStringEOLRS232("Dogged!!!!!");
   \   001D  7D2E              MOV     R5,#LOW(?0004)
   \   001F  7E00              MOV     R6,#HIGH(?0004)
   \   0021  7F02              MOV     R7,#2
   \   0023  120000            LCALL   $REFFN SendStringEOLRS232
   \   0026            ?0003:
    130              }
    131           
    132              InitializeComputer1();
   \   0026  120000            LCALL   $REFFN InitializeComputer1
    133          
    134              DispInfoBox("Waiting for", "terminal wakeup...");
   \   0029  7F02              MOV     R7,#2
   \   002B  900000            MOV     DPTR,#$PRMBX DispInfoBox+3
   \   002E  EF                MOV     A,R7
   \   002F  F0                MOVX    @DPTR,A
   \   0030  A3                INC     DPTR
   \   0031  7400              MOV     A,#HIGH(?0006)
   \   0033  F0                MOVX    @DPTR,A
   \   0034  A3                INC     DPTR
   \   0035  7446              MOV     A,#LOW(?0006)
   \   0037  F0                MOVX    @DPTR,A
   \   0038  7D3A              MOV     R5,#LOW(?0005)
   \   003A  7E00              MOV     R6,#HIGH(?0005)
   \   003C  120000            LCALL   $REFFN DispInfoBox
    135              DisplayMenu(VERSION_MENU_STRING);
   \   003F  7D59              MOV     R5,#LOW(?0007)
   \   0041  7E00              MOV     R6,#HIGH(?0007)
   \   0043  7F02              MOV     R7,#2
   \   0045  120000            LCALL   $REFFN DisplayMenu
    136          
    137              SendStringEOLRS232("Send char for prompt...");
   \   0048  7D83              MOV     R5,#LOW(?0008)
   \   004A  7E00              MOV     R6,#HIGH(?0008)
   \   004C  7F02              MOV     R7,#2
   \   004E  120000            LCALL   $REFFN SendStringEOLRS232
    138              
    139              timer = StartTimer(500);
   \   0051  7D01              MOV     R5,#1
   \   0053  7CF4              MOV     R4,#244
   \   0055  120000            LCALL   $REFFN StartTimer
   \   0058  EC                MOV     A,R4
   \   0059  900000            MOV     DPTR,#$LOCBX main
   \   005C  F0                MOVX    @DPTR,A
   \   005D            ?0010:
    140              while ((!TimedOut(timer)) && (!(S1CON & 0x01))) {
   \   005D  900000            MOV     DPTR,#$LOCBX main
   \   0060  E0                MOVX    A,@DPTR
   \   0061  FC                MOV     R4,A
   \   0062  120000            LCALL   $REFFN TimedOut
   \   0065  BC000B            CJNE    R4,#0,?0009
   \   0068  E59B              MOV     A,155
   \   006A  20E006            JB      ACC.0,?0009
   \   006D            ?0013:
   \   006D            ?0012:
   \   006D            ?0011:
    141                  WDT = 1;
   \   006D  D2AE              SETB    IE.6
    142                  SWDT = 1;
   \   006F  D2BE              SETB    IP.6
   \   0071  80EA              SJMP    ?0010
   \   0073            ?0009:
    143              }
    144              KillTimer(timer);
   \   0073  900000            MOV     DPTR,#$LOCBX main
   \   0076  E0                MOVX    A,@DPTR
   \   0077  FC                MOV     R4,A
   \   0078  120000            LCALL   $REFFN KillTimer
    145              
    146              if (!(S1CON & 0x01)) {
   \   007B  E59B              MOV     A,155
   \   007D  20E015            JB      ACC.0,?0015
   \   0080            ?0014:
    147                  SendStringEOLRS232("Running phone answer application");
   \   0080  7D9B              MOV     R5,#LOW(?0016)
   \   0082  7E00              MOV     R6,#HIGH(?0016)
   \   0084  7F02              MOV     R7,#2
   \   0086  120000            LCALL   $REFFN SendStringEOLRS232
    148                          InitializePhoneAnsApp();
   \   0089  120000            LCALL   $REFFN InitializePhoneAnsApp
    149                  ExecuteBatFile("ans.bat");
   \   008C  7DBC              MOV     R5,#LOW(?0017)
   \   008E  7E00              MOV     R6,#HIGH(?0017)
   \   0090  7F02              MOV     R7,#2
   \   0092  120000            LCALL   $REFFN ExecuteBatFile
   \   0095            ?0015:
    150              }
    151              S1CON &= ~(1);                                   //Nollar mottagnings-interrupt-flagga          
   \   0095  539BFE            ANL     155,#254
    152              DispInfoBox("TeleStation is under", "terminal control");
   \   0098  7F02              MOV     R7,#2
   \   009A  900000            MOV     DPTR,#$PRMBX DispInfoBox+3
   \   009D  EF                MOV     A,R7
   \   009E  F0                MOVX    @DPTR,A
   \   009F  A3                INC     DPTR
   \   00A0  7400              MOV     A,#HIGH(?0019)
   \   00A2  F0                MOVX    @DPTR,A
   \   00A3  A3                INC     DPTR
   \   00A4  74D9              MOV     A,#LOW(?0019)
   \   00A6  F0                MOVX    @DPTR,A
   \   00A7  7DC4              MOV     R5,#LOW(?0018)
   \   00A9  7E00              MOV     R6,#HIGH(?0018)
   \   00AB  120000            LCALL   $REFFN DispInfoBox
    153              MainShell();
    154          }
   \   00AE  120000            LCALL   $REFFN MainShell
   \   00B1  900000            MOV     DPTR,#$LOCBX main+1
   \   00B4  E0                MOVX    A,@DPTR
   \   00B5  F8                MOV     R0,A
   \   00B6  A3                INC     DPTR
   \   00B7  E0                MOVX    A,@DPTR
   \   00B8  C0E0              PUSH    ACC
   \   00BA  E8                MOV     A,R0
   \   00BB  C0E0              PUSH    ACC
   \   00BD  22                RET
    155          
    156          void    InitializeComputer1( void )
    157          {
   \   00BE            InitializeComputer1:
   \   00BE  900000            MOV     DPTR,#$LOCBX InitializeComputer1
   \   00C1  D0E0              POP     ACC
   \   00C3  F0                MOVX    @DPTR,A
   \   00C4  A3                INC     DPTR
   \   00C5  D0E0              POP     ACC
   \   00C7  F0                MOVX    @DPTR,A
    158          
    159          //-------------------------------------------
    160          // Initialisering av Watchdog
    161              WDTREL = 0x80;      //Sätter watchdog:en till max
   \   00C8  758680            MOV     134,#128
    162              
    163          //-------------------------------------------
    164          // Initiering av Timer 0. Timer 0 används för att mäta korta tidsförlopp. 
    165          // Exempelvis för att ge timeout om ett kommando skickas till mätattrappen 
    166          // men inget svar kommer.
    167          
    168          //  Tx0 ges enl:
    169          //      Önskad tid till timeout: t
    170          //      Kristallens klockfrekvens: f
    171          //      Tx0 = 65536 - t*f/12
    172          
    173          
    174           
    175              TMOD = 0x71;        //Timer0 16-timer, Timer1 disabled
   \   00CB  758971            MOV     TMOD,#113
    176              TR0 = 0;            //Stannar Timer0
   \   00CE  C28C              CLR     TCON.4
    177              ET0 = 1;            //Enable Timer 0 interrupt
   \   00D0  D2A9              SETB    IE.1
    178              timeout = 0;
   \   00D2  E4                CLR     A
   \   00D3  9001E8            MOV     DPTR,#timeout
   \   00D6  F0                MOVX    @DPTR,A
    179           
    180          
    181          //-------------------------------------------
    182          // Initialisering av LCD
    183          
    184              SendStringEOLRS232("LCD init...");
   \   00D7  7DEA              MOV     R5,#LOW(?0020)
   \   00D9  7E00              MOV     R6,#HIGH(?0020)
   \   00DB  7F02              MOV     R7,#2
   \   00DD  120000            LCALL   $REFFN SendStringEOLRS232
    185              InitializeLCD();
   \   00E0  120000            LCALL   $REFFN InitializeLCD
    186          
    187          //-------------------------------------------
    188          // Initialisering av FLASH
    189          
    190              SendStringEOLRS232("Flash init...");
   \   00E3  7DF6              MOV     R5,#LOW(?0021)
   \   00E5  7E00              MOV     R6,#HIGH(?0021)
   \   00E7  7F02              MOV     R7,#2
   \   00E9  120000            LCALL   $REFFN SendStringEOLRS232
    191              InitializeFlash();
   \   00EC  120000            LCALL   $REFFN InitializeFlash
    192              
    193          //-------------------------------------------
    194          // Initialisering av Filsystem
    195          
    196              SendStringEOLRS232("Filesys init...");
   \   00EF  7D04              MOV     R5,#LOW(?0022)
   \   00F1  7E01              MOV     R6,#HIGH(?0022)
   \   00F3  7F02              MOV     R7,#2
   \   00F5  120000            LCALL   $REFFN SendStringEOLRS232
    197              InitializeFileSystem();
   \   00F8  120000            LCALL   $REFFN InitializeFileSystem
    198          
    199          //-------------------------------------------
    200          // Initialisering av WAV-modulen (ljud in- och uppspelning)
    201          
    202              SendStringEOLRS232("WAV init...");
   \   00FB  7D14              MOV     R5,#LOW(?0023)
   \   00FD  7E01              MOV     R6,#HIGH(?0023)
   \   00FF  7F02              MOV     R7,#2
   \   0101  120000            LCALL   $REFFN SendStringEOLRS232
    203              InitializeWAV();
   \   0104  120000            LCALL   $REFFN InitializeWAV
    204          
    205          //-------------------------------------------
    206          // Initialisering av DTMF-modulen (tongenerering och tonavkodning)
    207          
    208              SendStringEOLRS232("DTMF init...");
   \   0107  7D20              MOV     R5,#LOW(?0024)
   \   0109  7E01              MOV     R6,#HIGH(?0024)
   \   010B  7F02              MOV     R7,#2
   \   010D  120000            LCALL   $REFFN SendStringEOLRS232
    209              InitializeDTMF();
   \   0110  120000            LCALL   $REFFN InitializeDTMF
    210          
    211          //-------------------------------------------
    212          // Initialisering av Phone-modulen
    213          
    214              SendStringEOLRS232("Phone init...");
   \   0113  7D2D              MOV     R5,#LOW(?0025)
   \   0115  7E01              MOV     R6,#HIGH(?0025)
   \   0117  7F02              MOV     R7,#2
   \   0119  120000            LCALL   $REFFN SendStringEOLRS232
    215              InitializePhone();
   \   011C  120000            LCALL   $REFFN InitializePhone
    216              
    217          //-------------------------------------------
    218          // Initialisering av timer
    219          
    220              SendStringEOLRS232("Timer init...");
   \   011F  7D3B              MOV     R5,#LOW(?0026)
   \   0121  7E01              MOV     R6,#HIGH(?0026)
   \   0123  7F02              MOV     R7,#2
   \   0125  120000            LCALL   $REFFN SendStringEOLRS232
    221              InitializeTimer();
   \   0128  120000            LCALL   $REFFN InitializeTimer
    222          
    223          //-------------------------------------------
    224          // Initialisering av calender
    225          
    226              SendStringEOLRS232("Calender init...");
   \   012B  7D49              MOV     R5,#LOW(?0027)
   \   012D  7E01              MOV     R6,#HIGH(?0027)
   \   012F  7F02              MOV     R7,#2
   \   0131  120000            LCALL   $REFFN SendStringEOLRS232
    227              InitializeCalender();
   \   0134  120000            LCALL   $REFFN InitializeCalender
    228          
    229          //-------------------------------------------
    230          // Initialisering av keyboard
    231          
    232              SendStringEOLRS232("Keyboard init...");
   \   0137  7D5A              MOV     R5,#LOW(?0028)
   \   0139  7E01              MOV     R6,#HIGH(?0028)
   \   013B  7F02              MOV     R7,#2
   \   013D  120000            LCALL   $REFFN SendStringEOLRS232
    233              InitializeKeyboard();
   \   0140  120000            LCALL   $REFFN InitializeKeyboard
    234          
    235          //-------------------------------------------
    236          // Initialisering av DPot
    237          
    238              SendStringEOLRS232("DPOT init...");
   \   0143  7D6B              MOV     R5,#LOW(?0029)
   \   0145  7E01              MOV     R6,#HIGH(?0029)
   \   0147  7F02              MOV     R7,#2
   \   0149  120000            LCALL   $REFFN SendStringEOLRS232
    239              InitializeDPot();
   \   014C  120000            LCALL   $REFFN InitializeDPot
    240          //-------------------------------------------
    241          // Initialisering av variabler
    242          
    243              error = EM_NOERROR;
   \   014F  900182            MOV     DPTR,#error
   \   0152  E4                CLR     A
   \   0153  F0                MOVX    @DPTR,A
   \   0154  A3                INC     DPTR
   \   0155  F0                MOVX    @DPTR,A
    244          
    245          //-------------------------------------------
    246          // Initialisering av avbrottsprioriteringar
    247           
    248          /*
    249          Avbrottskällor:
    250          
    251          *    SERIAL1 RS232
    252          *    TIMER1        Samplingsklocka, skall gå i 8000 Hz. Matas med fosc/12,
    253                          auto reload (dvs mode 2), reloadvärde 256 - 116 = 140
    254          *    TIMER2        Realtidsklocka uppdateras varje 100 millisekund.
    255                          Matas med fosc/24, automatic reload med värdet 65536 - 46080 = 19456
    256          *    INT0        DTMF
    257          
    258          Prioritetsgrupper:
    259          
    260          Grupp 1: INT0 SERIAL1
    261          Grupp 4: TIMER1
    262          Grupp 6: TIMER2
    263          
    264          Följande prioritet skall gälla:
    265          Högsta prio:    Grupp 4
    266          Mellan prio:    Grupp 1
    267          Lägsta prio:    Grupp 6
    268          */
    269          
    270              EAL = 1;            //Möjliggör avbrottshantering
   \   0156  D2AF              SETB    IE.7
    271          //    EAL = 0;            //Omöjliggör avbrottshantering
    272          
    273          }
   \   0158  900000            MOV     DPTR,#$LOCBX InitializeComputer1
   \   015B  E0                MOVX    A,@DPTR
   \   015C  F8                MOV     R0,A
   \   015D  A3                INC     DPTR
   \   015E  E0                MOVX    A,@DPTR
   \   015F  C0E0              PUSH    ACC
   \   0161  E8                MOV     A,R0
   \   0162  C0E0              PUSH    ACC
   \   0164  22                RET
    274          
    275          
    276          void    InitializePhoneAnsApp( void )
    277          {
   \   0165            InitializePhoneAnsApp:
   \   0165  900000            MOV     DPTR,#$LOCBX InitializePhoneAnsApp
   \   0168  D0E0              POP     ACC
   \   016A  F0                MOVX    @DPTR,A
   \   016B  A3                INC     DPTR
   \   016C  D0E0              POP     ACC
   \   016E  F0                MOVX    @DPTR,A
    278          //-------------------------------------------
    279          // Initialisering av PhoneAns
    280           
    281              SendStringEOLRS232("Phone Answering init...");
   \   016F  7D78              MOV     R5,#LOW(?0030)
   \   0171  7E01              MOV     R6,#HIGH(?0030)
   \   0173  7F02              MOV     R7,#2
   \   0175  120000            LCALL   $REFFN SendStringEOLRS232
    282              InitializePhoneAns();
   \   0178  120000            LCALL   $REFFN InitializePhoneAns
    283          
    284          //-------------------------------------------
    285          // Initialisering av LogFile
    286          
    287              SendStringEOLRS232("Log file init...");
   \   017B  7D90              MOV     R5,#LOW(?0031)
   \   017D  7E01              MOV     R6,#HIGH(?0031)
   \   017F  7F02              MOV     R7,#2
   \   0181  120000            LCALL   $REFFN SendStringEOLRS232
    288              InitializeLogFile();    
   \   0184  120000            LCALL   $REFFN InitializeLogFile
    289               
    290          //-------------------------------------------
    291          // Initialisering av Bat-fil hantering
    292          
    293              SendStringEOLRS232("Batch file init...");
   \   0187  7DA1              MOV     R5,#LOW(?0032)
   \   0189  7E01              MOV     R6,#HIGH(?0032)
   \   018B  7F02              MOV     R7,#2
   \   018D  120000            LCALL   $REFFN SendStringEOLRS232
    294              SetupBatFile();
   \   0190  120000            LCALL   $REFFN SetupBatFile
    295          
    296          //-------------------------------------------
    297          // Initialisering av Memo-fil hantering
    298          
    299              SendStringEOLRS232("Memo file init...");
   \   0193  7DB4              MOV     R5,#LOW(?0033)
   \   0195  7E01              MOV     R6,#HIGH(?0033)
   \   0197  7F02              MOV     R7,#2
   \   0199  120000            LCALL   $REFFN SendStringEOLRS232
    300              IntitializeMemo();
    301          
   \   019C  120000            LCALL   $REFFN IntitializeMemo
    302          }
   \   019F  900000            MOV     DPTR,#$LOCBX InitializePhoneAnsApp
   \   01A2  E0                MOVX    A,@DPTR
   \   01A3  F8                MOV     R0,A
   \   01A4  A3                INC     DPTR
   \   01A5  E0                MOVX    A,@DPTR
   \   01A6  C0E0              PUSH    ACC
   \   01A8  E8                MOV     A,R0
   \   01A9  C0E0              PUSH    ACC
   \   01AB  22                RET
    303          
    304          void    MainShell( void )
    305          //Väntar på en ny kommandorad (initierad av ett "Enter"-tecken.
    306          //Läser kommandoraden och bygger upp "commandLine" därefter. Tolkar 
    307          //och exekverar sedan kommandot.
    308          {
   \   01AC            MainShell:
   \   01AC  900000            MOV     DPTR,#$LOCBX MainShell+390
   \   01AF  D0E0              POP     ACC
   \   01B1  F0                MOVX    @DPTR,A
   \   01B2  A3                INC     DPTR
   \   01B3  D0E0              POP     ACC
   \   01B5  F0                MOVX    @DPTR,A
    309              xdata char    cmdStr[CM_PARSIZE*CM_NRPAR];
    310              xdata int     len;
    311              xdata FILE*   cmdFile;
    312              xdata char    sysCom = 0;
   \   01B6  E4                CLR     A
   \   01B7  900000            MOV     DPTR,#$LOCBX MainShell+389
   \   01BA  F0                MOVX    @DPTR,A
   \   01BB            ?0035:
    313              
    314              while (1) {   
    315                  if (!sysCom) SendRS232('>');
   \   01BB  900000            MOV     DPTR,#$LOCBX MainShell+389
   \   01BE  E0                MOVX    A,@DPTR
   \   01BF  7005              JNZ     ?0038
   \   01C1            ?0037:
   \   01C1  7C3E              MOV     R4,#62
   \   01C3  120000            LCALL   $REFFN SendRS232
   \   01C6            ?0038:
    316                  
    317                  sysCom = 0;
   \   01C6  E4                CLR     A
   \   01C7  900000            MOV     DPTR,#$LOCBX MainShell+389
   \   01CA  F0                MOVX    @DPTR,A
    318           
    319                  if (ReceiveLineRS232(cmdStr, CM_PARSIZE*CM_NRPAR) > 0) {
   \   01CB  900000            MOV     DPTR,#$PRMBX ReceiveLineRS232+3
   \   01CE  04                INC     A
   \   01CF  F0                MOVX    @DPTR,A
   \   01D0  A3                INC     DPTR
   \   01D1  03                RR      A
   \   01D2  F0                MOVX    @DPTR,A
   \   01D3  7D00              MOV     R5,#LOW $LOCBX MainShell
   \   01D5  7E00              MOV     R6,#HIGH $LOCBX MainShell
   \   01D7  7F01              MOV     R7,#1
   \   01D9  120000            LCALL   $REFFN ReceiveLineRS232
   \   01DC  D3                SETB    C
   \   01DD  EC                MOV     A,R4
   \   01DE  9400              SUBB    A,#0
   \   01E0  ED                MOV     A,R5
   \   01E1  6480              XRL     A,#128
   \   01E3  9480              SUBB    A,#128
   \   01E5  4029              JC      ?0040
   \   01E7            ?0039:
    320                      if (cmdStr[0] == 0x1B) {
   \   01E7  900000            MOV     DPTR,#$LOCBX MainShell
   \   01EA  E0                MOVX    A,@DPTR
   \   01EB  B41B22            CJNE    A,#27,?0042
   \   01EE            ?0041:
    321                          if (cmdStr[1] == 'D') {
   \   01EE  900000            MOV     DPTR,#$LOCBX MainShell+1
   \   01F1  E0                MOVX    A,@DPTR
   \   01F2  B4440B            CJNE    A,#68,?0044
   \   01F5            ?0043:
    322                              fdownLoad();   
   \   01F5  120000            LCALL   $REFFN fdownLoad
    323                              sysCom = 1;
   \   01F8  7401              MOV     A,#1
   \   01FA  900000            MOV     DPTR,#$LOCBX MainShell+389
   \   01FD  F0                MOVX    @DPTR,A
   \   01FE  8010              SJMP    ?0045
   \   0200            ?0044:
    324                          } else if (cmdStr[1] == 'U') {
   \   0200  900000            MOV     DPTR,#$LOCBX MainShell+1
   \   0203  E0                MOVX    A,@DPTR
   \   0204  B45509            CJNE    A,#85,?0047
   \   0207            ?0046:
    325                              fupLoad();
   \   0207  120000            LCALL   $REFFN fupLoad
    326                              sysCom = 1;
   \   020A  7401              MOV     A,#1
   \   020C  900000            MOV     DPTR,#$LOCBX MainShell+389
   \   020F  F0                MOVX    @DPTR,A
   \   0210            ?0047:
   \   0210            ?0045:
   \   0210            ?0042:
   \   0210            ?0040:
    327                          }
    328                      }
    329                  }
    330                  
    331                  if (!sysCom) {
   \   0210  900000            MOV     DPTR,#$LOCBX MainShell+389
   \   0213  E0                MOVX    A,@DPTR
   \   0214  6003              JZ      $+5
   \   0216  020335            LJMP    ?0049
   \   0219            ?0048:
    332                      if (!DecodeAndPerform(cmdStr)) {
   \   0219  7D00              MOV     R5,#LOW $LOCBX MainShell
   \   021B  7E00              MOV     R6,#HIGH $LOCBX MainShell
   \   021D  7F01              MOV     R7,#1
   \   021F  120000            LCALL   $REFFN DecodeAndPerform
   \   0222  BC0002            CJNE    R4,#0,$+5
   \   0225  8003              SJMP    $+5
   \   0227  0202F3            LJMP    ?0051
   \   022A            ?0050:
    333                          len = myStrLen(commandLine[0]);
   \   022A  7D00              MOV     R5,#LOW(commandLine)
   \   022C  7E00              MOV     R6,#HIGH(commandLine)
   \   022E  7F01              MOV     R7,#1
   \   0230  120000            LCALL   $REFFN myStrLen
    334                          commandLine[0][len++] = '.';
   \   0233  EC                MOV     A,R4
   \   0234  FE                MOV     R6,A
   \   0235  ED                MOV     A,R5
   \   0236  FF                MOV     R7,A
   \   0237  CC                XCH     A,R4
   \   0238  2401              ADD     A,#1
   \   023A  CC                XCH     A,R4
   \   023B  CD                XCH     A,R5
   \   023C  3400              ADDC    A,#0
   \   023E  CD                XCH     A,R5
   \   023F  EE                MOV     A,R6
   \   0240  2400              ADD     A,#LOW(commandLine)
   \   0242  F582              MOV     DPL,A
   \   0244  EF                MOV     A,R7
   \   0245  3400              ADDC    A,#HIGH(commandLine)
   \   0247  F583              MOV     DPH,A
   \   0249  742E              MOV     A,#46
   \   024B  F0                MOVX    @DPTR,A
    335                          commandLine[0][len++] = 'B';
   \   024C  EC                MOV     A,R4
   \   024D  FE                MOV     R6,A
   \   024E  ED                MOV     A,R5
   \   024F  FF                MOV     R7,A
   \   0250  CC                XCH     A,R4
   \   0251  2401              ADD     A,#1
   \   0253  CC                XCH     A,R4
   \   0254  CD                XCH     A,R5
   \   0255  3400              ADDC    A,#0
   \   0257  CD                XCH     A,R5
   \   0258  EE                MOV     A,R6
   \   0259  2400              ADD     A,#LOW(commandLine)
   \   025B  F582              MOV     DPL,A
   \   025D  EF                MOV     A,R7
   \   025E  3400              ADDC    A,#HIGH(commandLine)
   \   0260  F583              MOV     DPH,A
   \   0262  7442              MOV     A,#66
   \   0264  F0                MOVX    @DPTR,A
    336                          commandLine[0][len++] = 'A';
   \   0265  EC                MOV     A,R4
   \   0266  FE                MOV     R6,A
   \   0267  ED                MOV     A,R5
   \   0268  FF                MOV     R7,A
   \   0269  CC                XCH     A,R4
   \   026A  2401              ADD     A,#1
   \   026C  CC                XCH     A,R4
   \   026D  CD                XCH     A,R5
   \   026E  3400              ADDC    A,#0
   \   0270  CD                XCH     A,R5
   \   0271  EE                MOV     A,R6
   \   0272  2400              ADD     A,#LOW(commandLine)
   \   0274  F582              MOV     DPL,A
   \   0276  EF                MOV     A,R7
   \   0277  3400              ADDC    A,#HIGH(commandLine)
   \   0279  F583              MOV     DPH,A
   \   027B  7441              MOV     A,#65
   \   027D  F0                MOVX    @DPTR,A
    337                          commandLine[0][len++] = 'T';
   \   027E  EC                MOV     A,R4
   \   027F  FE                MOV     R6,A
   \   0280  ED                MOV     A,R5
   \   0281  FF                MOV     R7,A
   \   0282  CC                XCH     A,R4
   \   0283  2401              ADD     A,#1
   \   0285  CC                XCH     A,R4
   \   0286  CD                XCH     A,R5
   \   0287  3400              ADDC    A,#0
   \   0289  CD                XCH     A,R5
   \   028A  EE                MOV     A,R6
   \   028B  2400              ADD     A,#LOW(commandLine)
   \   028D  F582              MOV     DPL,A
   \   028F  EF                MOV     A,R7
   \   0290  3400              ADDC    A,#HIGH(commandLine)
   \   0292  F583              MOV     DPH,A
   \   0294  7454              MOV     A,#84
   \   0296  F0                MOVX    @DPTR,A
    338                          commandLine[0][len++] = 0x00;
   \   0297  EC                MOV     A,R4
   \   0298  FE                MOV     R6,A
   \   0299  ED                MOV     A,R5
   \   029A  FF                MOV     R7,A
   \   029B  CC                XCH     A,R4
   \   029C  2401              ADD     A,#1
   \   029E  CC                XCH     A,R4
   \   029F  CD                XCH     A,R5
   \   02A0  3400              ADDC    A,#0
   \   02A2  CD                XCH     A,R5
   \   02A3  900000            MOV     DPTR,#$LOCBX MainShell+384
   \   02A6  ED                MOV     A,R5
   \   02A7  F0                MOVX    @DPTR,A
   \   02A8  A3                INC     DPTR
   \   02A9  EC                MOV     A,R4
   \   02AA  F0                MOVX    @DPTR,A
   \   02AB  EE                MOV     A,R6
   \   02AC  2400              ADD     A,#LOW(commandLine)
   \   02AE  F582              MOV     DPL,A
   \   02B0  EF                MOV     A,R7
   \   02B1  3400              ADDC    A,#HIGH(commandLine)
   \   02B3  F583              MOV     DPH,A
   \   02B5  E4                CLR     A
   \   02B6  F0                MOVX    @DPTR,A
    339                          cmdFile = fopen(commandLine[0], "r");
   \   02B7  7F02              MOV     R7,#2
   \   02B9  900000            MOV     DPTR,#$PRMBX fopen+3
   \   02BC  EF                MOV     A,R7
   \   02BD  F0                MOVX    @DPTR,A
   \   02BE  A3                INC     DPTR
   \   02BF  7401              MOV     A,#HIGH(?0052)
   \   02C1  F0                MOVX    @DPTR,A
   \   02C2  A3                INC     DPTR
   \   02C3  74C6              MOV     A,#LOW(?0052)
   \   02C5  F0                MOVX    @DPTR,A
   \   02C6  7D00              MOV     R5,#LOW(commandLine)
   \   02C8  7E00              MOV     R6,#HIGH(commandLine)
   \   02CA  1F                DEC     R7
   \   02CB  120000            LCALL   $REFFN fopen
    340                          if (cmdFile) {
   \   02CE  900000            MOV     DPTR,#$LOCBX MainShell+386
   \   02D1  EF                MOV     A,R7
   \   02D2  F0                MOVX    @DPTR,A
   \   02D3  A3                INC     DPTR
   \   02D4  EE                MOV     A,R6
   \   02D5  F0                MOVX    @DPTR,A
   \   02D6  A3                INC     DPTR
   \   02D7  ED                MOV     A,R5
   \   02D8  F0                MOVX    @DPTR,A
   \   02D9  4E                ORL     A,R6
   \   02DA  600E              JZ      ?0054
   \   02DC            ?0053:
    341          //                    SendStringEOLRS232("Found a BAT-file");
    342                              fclose(cmdFile);
   \   02DC  120000            LCALL   $REFFN fclose
    343                              ExecuteBatFile(commandLine[0]);
   \   02DF  7D00              MOV     R5,#LOW(commandLine)
   \   02E1  7E00              MOV     R6,#HIGH(commandLine)
   \   02E3  7F01              MOV     R7,#1
   \   02E5  120000            LCALL   $REFFN ExecuteBatFile
    344          //                    SendStringEOLRS232("BAT-file executed");
    345                          } else {
   \   02E8  8009              SJMP    ?0055
   \   02EA            ?0054:
    346                              SendStringEOLRS232("Unrecognized command or BAT-file");
   \   02EA  7DC8              MOV     R5,#LOW(?0056)
   \   02EC  7E01              MOV     R6,#HIGH(?0056)
   \   02EE  7F02              MOV     R7,#2
   \   02F0  120000            LCALL   $REFFN SendStringEOLRS232
   \   02F3            ?0055:
   \   02F3            ?0051:
    347          //                error = 0x00;
    348                          }
    349                      }
    350           
    351          //            cmdStr[myStrLen(cmdStr)] = ' ';
    352          //            cmdStr[myStrLen(cmdStr)+1] = 0;
    353          
    354          //            SendStringEOLRS232(cmdStr);
    355                      
    356          //            sprintf(msg, "Length: %d", myStrLen(cmdStr));
    357          //            SendStringEOLRS232(msg);
    358          
    359                      if (error) {
   \   02F3  900182            MOV     DPTR,#error
   \   02F6  E0                MOVX    A,@DPTR
   \   02F7  FD                MOV     R5,A
   \   02F8  A3                INC     DPTR
   \   02F9  E0                MOVX    A,@DPTR
   \   02FA  4D                ORL     A,R5
   \   02FB  6038              JZ      ?0058
   \   02FD            ?0057:
    360                          SendStringRS232("Error code: ");
   \   02FD  7DE9              MOV     R5,#LOW(?0059)
   \   02FF  7E01              MOV     R6,#HIGH(?0059)
   \   0301  7F02              MOV     R7,#2
   \   0303  120000            LCALL   $REFFN SendStringRS232
    361                          myLong2HexStr(error, msg);
   \   0306  7401              MOV     A,#1
   \   0308  900000            MOV     DPTR,#$PRMBX myLong2HexStr+4
   \   030B  F0                MOVX    @DPTR,A
   \   030C  A3                INC     DPTR
   \   030D  7401              MOV     A,#HIGH(msg)
   \   030F  F0                MOVX    @DPTR,A
   \   0310  A3                INC     DPTR
   \   0311  7484              MOV     A,#LOW(msg)
   \   0313  F0                MOVX    @DPTR,A
   \   0314  900182            MOV     DPTR,#error
   \   0317  E0                MOVX    A,@DPTR
   \   0318  FD                MOV     R5,A
   \   0319  A3                INC     DPTR
   \   031A  E0                MOVX    A,@DPTR
   \   031B  FC                MOV     R4,A
   \   031C  ED                MOV     A,R5
   \   031D  33                RLC     A
   \   031E  95E0              SUBB    A,ACC
   \   0320  FE                MOV     R6,A
   \   0321  FF                MOV     R7,A
   \   0322  120000            LCALL   $REFFN myLong2HexStr
    362                          SendStringEOLRS232(msg);
   \   0325  7D84              MOV     R5,#LOW(msg)
   \   0327  7E01              MOV     R6,#HIGH(msg)
   \   0329  7F01              MOV     R7,#1
   \   032B  120000            LCALL   $REFFN SendStringEOLRS232
    363                          error = 0;
   \   032E  900182            MOV     DPTR,#error
   \   0331  E4                CLR     A
   \   0332  F0                MOVX    @DPTR,A
   \   0333  A3                INC     DPTR
   \   0334  F0                MOVX    @DPTR,A
   \   0335            ?0058:
   \   0335            ?0049:
    364                      }
    365                  }
    366              }
    367          }
   \   0335  0201BB            LJMP    ?0035
   \   0338  900000            MOV     DPTR,#$LOCBX MainShell+390
   \   033B  E0                MOVX    A,@DPTR
   \   033C  F8                MOV     R0,A
   \   033D  A3                INC     DPTR
   \   033E  E0                MOVX    A,@DPTR
   \   033F  C0E0              PUSH    ACC
   \   0341  E8                MOV     A,R0
   \   0342  C0E0              PUSH    ACC
   \   0344  22                RET
    368          
    369          
    370          
    371          char    DecodeAndPerform(const char* cmdStr)
    372          //Sorterar upp strängen cmdStr i "mellanslag-uppdelade" strängar
    373          //Söker sedan efter ett kommando motsv det i cmdStr och utför det.
    374          //Om inget kommando finns retuneras 0, annars 1
    375          {
   \   0345            DecodeAndPerform:
   \   0345  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+32
   \   0348  D0E0              POP     ACC
   \   034A  F0                MOVX    @DPTR,A
   \   034B  A3                INC     DPTR
   \   034C  D0E0              POP     ACC
   \   034E  F0                MOVX    @DPTR,A
    376              xdata int     i; 
    377              xdata char    j; 
    378              xdata char    n;
    379          //    char    c;
    380          //    char    copy;
    381          
    382              xdata char* tmpStr; 
    383              xdata char  delim[4] = " \t";
   \   034F  900000            MOV     DPTR,#?0060
   \   0352  120000            LCALL   ?LD_R0123_CDPTR_L20
   \   0355  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+7
   \   0358  120000            LCALL   ?STO_R0123_DPTR_L20
    384              
    385              xdata char  name[20];
    386              xdata char  category;
    387           
    388              if (cmdStr[0] == 0)  return 1;             //Ignorera tomma rader
   \   035B  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+34
   \   035E  EF                MOV     A,R7
   \   035F  F0                MOVX    @DPTR,A
   \   0360  A3                INC     DPTR
   \   0361  EE                MOV     A,R6
   \   0362  F0                MOVX    @DPTR,A
   \   0363  A3                INC     DPTR
   \   0364  ED                MOV     A,R5
   \   0365  F0                MOVX    @DPTR,A
   \   0366  120000            LCALL   ?LD_A_R567_L17
   \   0369  7005              JNZ     ?0062
   \   036B            ?0061:
   \   036B  7C01              MOV     R4,#1
   \   036D  020D4E            LJMP    ?0297
   \   0370            ?0062:
    389          
    390              nrCommandParameters = 0;
   \   0370  900180            MOV     DPTR,#nrCommandParameters
   \   0373  E4                CLR     A
   \   0374  F0                MOVX    @DPTR,A
   \   0375  A3                INC     DPTR
   \   0376  F0                MOVX    @DPTR,A
    391              n = 0;
    392                  
    393          //    SendStringRS232("Command: ");
    394          //    SendStringEOLRS232(cmdStr);
    395          
    396          
    397              i = 0;
    398              j = 0;
   \   0377  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   037A  F0                MOVX    @DPTR,A
    399          
    400          
    401          
    402          /*
    403              copy = 1;
    404              
    405              while ( (c = cmdStr[i++]) != 0x00) {
    406                  if (copy) {
    407                      SendRS232(c);
    408                      if ((c == ' ') || (c == '\t')) {
    409                          commandLine[nrCommandParameters][j++] = 0x00;
    410                          j = 0;
    411                          nrCommandParameters++;
    412                          copy = 0;
    413                      } else {
    414                          commandLine[nrCommandParameters][j++] = c;
    415                      }
    416                  } else {
    417                      if ((c != ' ') && (c != '\t')) {
    418                          commandLine[nrCommandParameters][j++] = c;
    419                          copy = 1;
    420                      }
    421                  }
    422          
    423              }
    424          */
    425          
    426              i = 0; 
    427              tmpStr = strtok(cmdStr, delim); 
   \   037B  7401              MOV     A,#1
   \   037D  900000            MOV     DPTR,#$PRMBX strtok+3
   \   0380  F0                MOVX    @DPTR,A
   \   0381  A3                INC     DPTR
   \   0382  7400              MOV     A,#HIGH ($LOCBX DecodeAndPerform+7)
   \   0384  F0                MOVX    @DPTR,A
   \   0385  A3                INC     DPTR
   \   0386  7400              MOV     A,#LOW ($LOCBX DecodeAndPerform+7)
   \   0388  F0                MOVX    @DPTR,A
   \   0389  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+34
   \   038C  E0                MOVX    A,@DPTR
   \   038D  FF                MOV     R7,A
   \   038E  A3                INC     DPTR
   \   038F  E0                MOVX    A,@DPTR
   \   0390  FE                MOV     R6,A
   \   0391  A3                INC     DPTR
   \   0392  E0                MOVX    A,@DPTR
   \   0393  FD                MOV     R5,A
   \   0394  120000            LCALL   $REFFN strtok
   \   0397  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+4
   \   039A  EF                MOV     A,R7
   \   039B  F0                MOVX    @DPTR,A
   \   039C  A3                INC     DPTR
   \   039D  EE                MOV     A,R6
   \   039E  F0                MOVX    @DPTR,A
   \   039F  A3                INC     DPTR
   \   03A0  ED                MOV     A,R5
   \   03A1  F0                MOVX    @DPTR,A
   \   03A2  E4                CLR     A
   \   03A3  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+3
   \   03A6  F0                MOVX    @DPTR,A
   \   03A7  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   03AA  F0                MOVX    @DPTR,A
   \   03AB  A3                INC     DPTR
   \   03AC  F0                MOVX    @DPTR,A
   \   03AD            ?0064:
    428              while ((tmpStr != NULL) && (n < CM_NRPAR)) {
   \   03AD  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+4
   \   03B0  E0                MOVX    A,@DPTR
   \   03B1  FF                MOV     R7,A
   \   03B2  A3                INC     DPTR
   \   03B3  E0                MOVX    A,@DPTR
   \   03B4  FE                MOV     R6,A
   \   03B5  A3                INC     DPTR
   \   03B6  E0                MOVX    A,@DPTR
   \   03B7  FD                MOV     R5,A
   \   03B8  4E                ORL     A,R6
   \   03B9  604F              JZ      ?0063
   \   03BB  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+3
   \   03BE  E0                MOVX    A,@DPTR
   \   03BF  24F0              ADD     A,#240
   \   03C1  4047              JC      ?0063
   \   03C3            ?0067:
   \   03C3            ?0066:
   \   03C3            ?0065:
    429                  myStrCpy(commandLine[n++], tmpStr);
   \   03C3  900000            MOV     DPTR,#$PRMBX myStrCpy+3
   \   03C6  EF                MOV     A,R7
   \   03C7  F0                MOVX    @DPTR,A
   \   03C8  A3                INC     DPTR
   \   03C9  EE                MOV     A,R6
   \   03CA  F0                MOVX    @DPTR,A
   \   03CB  A3                INC     DPTR
   \   03CC  ED                MOV     A,R5
   \   03CD  F0                MOVX    @DPTR,A
   \   03CE  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+3
   \   03D1  E0                MOVX    A,@DPTR
   \   03D2  FC                MOV     R4,A
   \   03D3  04                INC     A
   \   03D4  F0                MOVX    @DPTR,A
   \   03D5  EC                MOV     A,R4
   \   03D6  75F010            MOV     B,#16
   \   03D9  A4                MUL     AB
   \   03DA  2400              ADD     A,#LOW(commandLine)
   \   03DC  FD                MOV     R5,A
   \   03DD  E5F0              MOV     A,B
   \   03DF  3400              ADDC    A,#HIGH(commandLine)
   \   03E1  FE                MOV     R6,A
   \   03E2  7F01              MOV     R7,#1
   \   03E4  120000            LCALL   $REFFN myStrCpy
    430          //        SendStringEOLRS232(tmpStr);
    431                  tmpStr = strtok(NULL, delim); 
   \   03E7  7F01              MOV     R7,#1
   \   03E9  900000            MOV     DPTR,#$PRMBX strtok+3
   \   03EC  EF                MOV     A,R7
   \   03ED  F0                MOVX    @DPTR,A
   \   03EE  A3                INC     DPTR
   \   03EF  7400              MOV     A,#HIGH ($LOCBX DecodeAndPerform+7)
   \   03F1  F0                MOVX    @DPTR,A
   \   03F2  A3                INC     DPTR
   \   03F3  7400              MOV     A,#LOW ($LOCBX DecodeAndPerform+7)
   \   03F5  F0                MOVX    @DPTR,A
   \   03F6  E4                CLR     A
   \   03F7  FD                MOV     R5,A
   \   03F8  FE                MOV     R6,A
   \   03F9  1F                DEC     R7
   \   03FA  120000            LCALL   $REFFN strtok
   \   03FD  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+4
   \   0400  EF                MOV     A,R7
   \   0401  F0                MOVX    @DPTR,A
   \   0402  A3                INC     DPTR
   \   0403  EE                MOV     A,R6
   \   0404  F0                MOVX    @DPTR,A
   \   0405  A3                INC     DPTR
   \   0406  ED                MOV     A,R5
   \   0407  F0                MOVX    @DPTR,A
   \   0408  80A3              SJMP    ?0064
   \   040A            ?0063:
    432          //        SendRS232('0' + i);
    433          //        SendStringEOLRS232(" ");
    434          //        i++;
    435              }
    436          
    437          
    438          //    myInt2DecStr(n, msg);
    439          //    SendStringEOLRS232(msg);
    440          //    SendRS232('0' + n);
    441          //    SendStringEOLRS232(" ");
    442              
    443              nrCommandParameters = n;
   \   040A  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+3
   \   040D  E0                MOVX    A,@DPTR
   \   040E  7D00              MOV     R5,#0
   \   0410  900180            MOV     DPTR,#nrCommandParameters
   \   0413  CD                XCH     A,R5
   \   0414  F0                MOVX    @DPTR,A
   \   0415  A3                INC     DPTR
   \   0416  CD                XCH     A,R5
   \   0417  F0                MOVX    @DPTR,A
    444          
    445              
    446              for(i=n ; i < CM_NRPAR ; i++) {
   \   0418  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+3
   \   041B  E0                MOVX    A,@DPTR
   \   041C  FE                MOV     R6,A
   \   041D  CD                XCH     A,R5
   \   041E  FF                MOV     R7,A
   \   041F  CD                XCH     A,R5
   \   0420            ?0069:
   \   0420  C3                CLR     C
   \   0421  EE                MOV     A,R6
   \   0422  9410              SUBB    A,#16
   \   0424  EF                MOV     A,R7
   \   0425  6480              XRL     A,#128
   \   0427  9480              SUBB    A,#128
   \   0429  501E              JNC     ?0068
   \   042B            ?0070:
    447                  commandLine[i][0] = 0;
   \   042B  EF                MOV     A,R7
   \   042C  FD                MOV     R5,A
   \   042D  EE                MOV     A,R6
   \   042E  7C04              MOV     R4,#4
   \   0430            ?0430:
   \   0430  25E0              ADD     A,ACC
   \   0432  CD                XCH     A,R5
   \   0433  33                RLC     A
   \   0434  CD                XCH     A,R5
   \   0435  DCF9              DJNZ    R4,?0430
   \   0437  2400              ADD     A,#LOW(commandLine)
   \   0439  F582              MOV     DPL,A
   \   043B  ED                MOV     A,R5
   \   043C  3400              ADDC    A,#HIGH(commandLine)
   \   043E  F583              MOV     DPH,A
   \   0440  EC                MOV     A,R4
   \   0441  F0                MOVX    @DPTR,A
   \   0442  0E                INC     R6
   \   0443  BE0001            CJNE    R6,#0,?0431
   \   0446  0F                INC     R7
   \   0447            ?0431:
   \   0447  80D7              SJMP    ?0069
   \   0449            ?0068:
   \   0449  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   044C  EF                MOV     A,R7
   \   044D  F0                MOVX    @DPTR,A
   \   044E  A3                INC     DPTR
   \   044F  EE                MOV     A,R6
   \   0450  F0                MOVX    @DPTR,A
    448              }
    449                      
    450          /*
    451                      for (i=0 ; i<n ; i++) {
    452                          SendStringRS232("commandLine ");
    453                          SendRS232('0' + i);
    454                          SendStringRS232(": ");
    455                          SendStringEOLRS232(commandLine[i]);
    456                      }
    457           
    458          */
    459          
    460              if (!myStrCmpNoCase(commandLine[0], CM_HELLO)) {
   \   0451  7F02              MOV     R7,#2
   \   0453  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0456  EF                MOV     A,R7
   \   0457  F0                MOVX    @DPTR,A
   \   0458  A3                INC     DPTR
   \   0459  7401              MOV     A,#HIGH(?0074)
   \   045B  F0                MOVX    @DPTR,A
   \   045C  A3                INC     DPTR
   \   045D  74F6              MOV     A,#LOW(?0074)
   \   045F  F0                MOVX    @DPTR,A
   \   0460  7D00              MOV     R5,#LOW(commandLine)
   \   0462  7E00              MOV     R6,#HIGH(commandLine)
   \   0464  1F                DEC     R7
   \   0465  120000            LCALL   $REFFN myStrCmpNoCase
   \   0468  BC0006            CJNE    R4,#0,?0073
   \   046B            ?0072:
    461                  
    462                  Hello();
   \   046B  120000            LCALL   $REFFN Hello
   \   046E  020D4C            LJMP    ?0075
   \   0471            ?0073:
    463          /*              
    464                      } else if (!myStrCmpNoCase(commandLine[0], CM_TESTHW)) {
    465          
    466                          TestHW();
    467          
    468                      } else if (!myStrCmpNoCase(commandLine[0], CM_ID)) {
    469          
    470                          FlashID();
    471          */
    472              } else if (!myStrCmpNoCase(commandLine[0], CM_ERASE)) {
   \   0471  7F02              MOV     R7,#2
   \   0473  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0476  EF                MOV     A,R7
   \   0477  F0                MOVX    @DPTR,A
   \   0478  A3                INC     DPTR
   \   0479  7401              MOV     A,#HIGH(?0078)
   \   047B  F0                MOVX    @DPTR,A
   \   047C  A3                INC     DPTR
   \   047D  74FC              MOV     A,#LOW(?0078)
   \   047F  F0                MOVX    @DPTR,A
   \   0480  7D00              MOV     R5,#LOW(commandLine)
   \   0482  7E00              MOV     R6,#HIGH(commandLine)
   \   0484  1F                DEC     R7
   \   0485  120000            LCALL   $REFFN myStrCmpNoCase
   \   0488  BC0006            CJNE    R4,#0,?0077
   \   048B            ?0076:
    473          
    474                  EraseAll();
   \   048B  120000            LCALL   $REFFN EraseAll
   \   048E  020D4C            LJMP    ?0079
   \   0491            ?0077:
    475          
    476              } else if (!myStrCmpNoCase(commandLine[0], CM_CREATEDYNAMIC)) {
   \   0491  7F02              MOV     R7,#2
   \   0493  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0496  EF                MOV     A,R7
   \   0497  F0                MOVX    @DPTR,A
   \   0498  A3                INC     DPTR
   \   0499  7402              MOV     A,#HIGH(?0082)
   \   049B  F0                MOVX    @DPTR,A
   \   049C  A3                INC     DPTR
   \   049D  7402              MOV     A,#LOW(?0082)
   \   049F  F0                MOVX    @DPTR,A
   \   04A0  7D00              MOV     R5,#LOW(commandLine)
   \   04A2  7E00              MOV     R6,#HIGH(commandLine)
   \   04A4  1F                DEC     R7
   \   04A5  120000            LCALL   $REFFN myStrCmpNoCase
   \   04A8  BC0006            CJNE    R4,#0,?0081
   \   04AB            ?0080:
    477          
    478                  StartDynamic();
   \   04AB  120000            LCALL   $REFFN StartDynamic
   \   04AE  020D4C            LJMP    ?0083
   \   04B1            ?0081:
    479          
    480              } else if (!myStrCmpNoCase(commandLine[0], CM_ERASEDYNAMIC)) {
   \   04B1  7F02              MOV     R7,#2
   \   04B3  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   04B6  EF                MOV     A,R7
   \   04B7  F0                MOVX    @DPTR,A
   \   04B8  A3                INC     DPTR
   \   04B9  7402              MOV     A,#HIGH(?0086)
   \   04BB  F0                MOVX    @DPTR,A
   \   04BC  A3                INC     DPTR
   \   04BD  7410              MOV     A,#LOW(?0086)
   \   04BF  F0                MOVX    @DPTR,A
   \   04C0  7D00              MOV     R5,#LOW(commandLine)
   \   04C2  7E00              MOV     R6,#HIGH(commandLine)
   \   04C4  1F                DEC     R7
   \   04C5  120000            LCALL   $REFFN myStrCmpNoCase
   \   04C8  BC001C            CJNE    R4,#0,?0085
   \   04CB            ?0084:
    481          
    482                  EraseDynamic();
   \   04CB  120000            LCALL   $REFFN EraseDynamic
    483                  WriteCalenderByte(NV_PLAYED_MS, 0xFF);
   \   04CE  7DFF              MOV     R5,#255
   \   04D0  7C0A              MOV     R4,#10
   \   04D2  120000            LCALL   $REFFN WriteCalenderByte
    484                  WriteCalenderByte(NV_PLAYED_LS, 0xFF);
   \   04D5  7DFF              MOV     R5,#255
   \   04D7  7C0B              MOV     R4,#11
   \   04D9  120000            LCALL   $REFFN WriteCalenderByte
    485                  lastPlayed = -1;
   \   04DC  900000            MOV     DPTR,#lastPlayed
   \   04DF  74FF              MOV     A,#255
   \   04E1  F0                MOVX    @DPTR,A
   \   04E2  A3                INC     DPTR
   \   04E3  F0                MOVX    @DPTR,A
   \   04E4  020D4C            LJMP    ?0087
   \   04E7            ?0085:
    486          
    487          /*
    488              } else if (!myStrCmpNoCase(commandLine[0], CM_WRITEFILE1)) {
    489          
    490                  Append();
    491          
    492                      } else if (!myStrCmpNoCase(commandLine[0], CM_WRITEFILE2)) {
    493          
    494                          WF2();
    495          
    496                      } else if (!myStrCmpNoCase(commandLine[0], CM_WRITEFILE3)) {
    497          
    498                          WF3();
    499          
    500                      } else if (!myStrCmpNoCase(commandLine[0], CM_READFILE1)) {
    501          
    502                          RF1();
    503          
    504                      } else if (!myStrCmpNoCase(commandLine[0], CM_READFILE2)) {
    505          
    506                          RF2();
    507          
    508                      } else if (!myStrCmpNoCase(commandLine[0], CM_READFILE3)) {
    509          
    510                          RF3();
    511          */
    512              } else if (!myStrCmpNoCase(commandLine[0], CM_DIR)) {
   \   04E7  7F02              MOV     R7,#2
   \   04E9  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   04EC  EF                MOV     A,R7
   \   04ED  F0                MOVX    @DPTR,A
   \   04EE  A3                INC     DPTR
   \   04EF  7402              MOV     A,#HIGH(?0090)
   \   04F1  F0                MOVX    @DPTR,A
   \   04F2  A3                INC     DPTR
   \   04F3  741D              MOV     A,#LOW(?0090)
   \   04F5  F0                MOVX    @DPTR,A
   \   04F6  7D00              MOV     R5,#LOW(commandLine)
   \   04F8  7E00              MOV     R6,#HIGH(commandLine)
   \   04FA  1F                DEC     R7
   \   04FB  120000            LCALL   $REFFN myStrCmpNoCase
   \   04FE  BC0006            CJNE    R4,#0,?0089
   \   0501            ?0088:
    513          
    514                  Dir();
   \   0501  120000            LCALL   $REFFN Dir
   \   0504  020D4C            LJMP    ?0091
   \   0507            ?0089:
    515          /*
    516                      } else if (!myStrCmpNoCase(commandLine[0], CM_CREATELONG)) {
    517          
    518                          CreateLong();
    519          
    520                      } else if (!myStrCmpNoCase(commandLine[0], CM_READSPARE)) {
    521          
    522                          ReadSpare();
    523          
    524                      } else if (!myStrCmpNoCase(commandLine[0], CM_READSPARE2)) {
    525          
    526                          ReadSpare2();
    527          
    528              } else if (!myStrCmpNoCase(commandLine[0], CM_DOWNLOAD)) {
    529          
    530                  fdownLoad();
    531          
    532                      } else if (!myStrCmpNoCase(commandLine[0], CM_UPLOAD)) {
    533          
    534                          fupLoad();
    535          */
    536              } else if (!myStrCmpNoCase(commandLine[0], CM_TYPE)) {
   \   0507  7F02              MOV     R7,#2
   \   0509  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   050C  EF                MOV     A,R7
   \   050D  F0                MOVX    @DPTR,A
   \   050E  A3                INC     DPTR
   \   050F  7402              MOV     A,#HIGH(?0094)
   \   0511  F0                MOVX    @DPTR,A
   \   0512  A3                INC     DPTR
   \   0513  7421              MOV     A,#LOW(?0094)
   \   0515  F0                MOVX    @DPTR,A
   \   0516  7D00              MOV     R5,#LOW(commandLine)
   \   0518  7E00              MOV     R6,#HIGH(commandLine)
   \   051A  1F                DEC     R7
   \   051B  120000            LCALL   $REFFN myStrCmpNoCase
   \   051E  BC0006            CJNE    R4,#0,?0093
   \   0521            ?0092:
    537          
    538                  Type();
   \   0521  120000            LCALL   $REFFN Type
   \   0524  020D4C            LJMP    ?0095
   \   0527            ?0093:
    539          
    540              } else if (!myStrCmpNoCase(commandLine[0], CM_TYPEA)) {
   \   0527  7F02              MOV     R7,#2
   \   0529  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   052C  EF                MOV     A,R7
   \   052D  F0                MOVX    @DPTR,A
   \   052E  A3                INC     DPTR
   \   052F  7402              MOV     A,#HIGH(?0098)
   \   0531  F0                MOVX    @DPTR,A
   \   0532  A3                INC     DPTR
   \   0533  7426              MOV     A,#LOW(?0098)
   \   0535  F0                MOVX    @DPTR,A
   \   0536  7D00              MOV     R5,#LOW(commandLine)
   \   0538  7E00              MOV     R6,#HIGH(commandLine)
   \   053A  1F                DEC     R7
   \   053B  120000            LCALL   $REFFN myStrCmpNoCase
   \   053E  BC0006            CJNE    R4,#0,?0097
   \   0541            ?0096:
    541          
    542                  TypeA();
   \   0541  120000            LCALL   $REFFN TypeA
   \   0544  020D4C            LJMP    ?0099
   \   0547            ?0097:
    543          
    544              } else if (!myStrCmpNoCase(commandLine[0], CM_ECHO_MIC)) {
   \   0547  7F02              MOV     R7,#2
   \   0549  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   054C  EF                MOV     A,R7
   \   054D  F0                MOVX    @DPTR,A
   \   054E  A3                INC     DPTR
   \   054F  7402              MOV     A,#HIGH(?0102)
   \   0551  F0                MOVX    @DPTR,A
   \   0552  A3                INC     DPTR
   \   0553  742C              MOV     A,#LOW(?0102)
   \   0555  F0                MOVX    @DPTR,A
   \   0556  7D00              MOV     R5,#LOW(commandLine)
   \   0558  7E00              MOV     R6,#HIGH(commandLine)
   \   055A  1F                DEC     R7
   \   055B  120000            LCALL   $REFFN myStrCmpNoCase
   \   055E  BC000B            CJNE    R4,#0,?0101
   \   0561            ?0100:
    545          
    546                  receivedDTMF = 0;
   \   0561  E4                CLR     A
   \   0562  900000            MOV     DPTR,#receivedDTMF
   \   0565  F0                MOVX    @DPTR,A
    547                  EchoMic();
   \   0566  120000            LCALL   $REFFN EchoMic
   \   0569  020D4C            LJMP    ?0103
   \   056C            ?0101:
    548          
    549              } else if (!myStrCmpNoCase(commandLine[0], CM_ECHO_PHONE)) {
   \   056C  7F02              MOV     R7,#2
   \   056E  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0571  EF                MOV     A,R7
   \   0572  F0                MOVX    @DPTR,A
   \   0573  A3                INC     DPTR
   \   0574  7402              MOV     A,#HIGH(?0106)
   \   0576  F0                MOVX    @DPTR,A
   \   0577  A3                INC     DPTR
   \   0578  7434              MOV     A,#LOW(?0106)
   \   057A  F0                MOVX    @DPTR,A
   \   057B  7D00              MOV     R5,#LOW(commandLine)
   \   057D  7E00              MOV     R6,#HIGH(commandLine)
   \   057F  1F                DEC     R7
   \   0580  120000            LCALL   $REFFN myStrCmpNoCase
   \   0583  BC000B            CJNE    R4,#0,?0105
   \   0586            ?0104:
    550          
    551                  receivedDTMF = 0;
   \   0586  E4                CLR     A
   \   0587  900000            MOV     DPTR,#receivedDTMF
   \   058A  F0                MOVX    @DPTR,A
    552                  EchoPhone();
   \   058B  120000            LCALL   $REFFN EchoPhone
   \   058E  020D4C            LJMP    ?0107
   \   0591            ?0105:
    553          
    554              } else if (!myStrCmpNoCase(commandLine[0], CM_REC_MIC)) {
   \   0591  7F02              MOV     R7,#2
   \   0593  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0596  EF                MOV     A,R7
   \   0597  F0                MOVX    @DPTR,A
   \   0598  A3                INC     DPTR
   \   0599  7402              MOV     A,#HIGH(?0110)
   \   059B  F0                MOVX    @DPTR,A
   \   059C  A3                INC     DPTR
   \   059D  743E              MOV     A,#LOW(?0110)
   \   059F  F0                MOVX    @DPTR,A
   \   05A0  7D00              MOV     R5,#LOW(commandLine)
   \   05A2  7E00              MOV     R6,#HIGH(commandLine)
   \   05A4  1F                DEC     R7
   \   05A5  120000            LCALL   $REFFN myStrCmpNoCase
   \   05A8  BC0011            CJNE    R4,#0,?0109
   \   05AB            ?0108:
    555          
    556                  receivedDTMF = 0;
   \   05AB  E4                CLR     A
   \   05AC  900000            MOV     DPTR,#receivedDTMF
   \   05AF  F0                MOVX    @DPTR,A
    557                  RecMicFile(commandLine[1]);
   \   05B0  7D10              MOV     R5,#LOW(commandLine+16)
   \   05B2  7E00              MOV     R6,#HIGH(commandLine+16)
   \   05B4  7F01              MOV     R7,#1
   \   05B6  120000            LCALL   $REFFN RecMicFile
   \   05B9  020D4C            LJMP    ?0111
   \   05BC            ?0109:
    558          
    559              } else if (!myStrCmpNoCase(commandLine[0], CM_REC_PHONE)) {
   \   05BC  7F02              MOV     R7,#2
   \   05BE  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   05C1  EF                MOV     A,R7
   \   05C2  F0                MOVX    @DPTR,A
   \   05C3  A3                INC     DPTR
   \   05C4  7402              MOV     A,#HIGH(?0114)
   \   05C6  F0                MOVX    @DPTR,A
   \   05C7  A3                INC     DPTR
   \   05C8  7445              MOV     A,#LOW(?0114)
   \   05CA  F0                MOVX    @DPTR,A
   \   05CB  7D00              MOV     R5,#LOW(commandLine)
   \   05CD  7E00              MOV     R6,#HIGH(commandLine)
   \   05CF  1F                DEC     R7
   \   05D0  120000            LCALL   $REFFN myStrCmpNoCase
   \   05D3  BC0011            CJNE    R4,#0,?0113
   \   05D6            ?0112:
    560          
    561                  receivedDTMF = 0;
   \   05D6  E4                CLR     A
   \   05D7  900000            MOV     DPTR,#receivedDTMF
   \   05DA  F0                MOVX    @DPTR,A
    562                  RecPhoneFile(commandLine[1]);
   \   05DB  7D10              MOV     R5,#LOW(commandLine+16)
   \   05DD  7E00              MOV     R6,#HIGH(commandLine+16)
   \   05DF  7F01              MOV     R7,#1
   \   05E1  120000            LCALL   $REFFN RecPhoneFile
   \   05E4  020D4C            LJMP    ?0115
   \   05E7            ?0113:
    563          /*
    564              } else if (!myStrCmpNoCase(commandLine[0], CM_REC_PORT)) {
    565          
    566                  receivedDTMF = 0;
    567                  RecPort1(commandLine[1]);
    568          */
    569              } else if (!myStrCmpNoCase(commandLine[0], CM_TONE)) {
   \   05E7  7F02              MOV     R7,#2
   \   05E9  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   05EC  EF                MOV     A,R7
   \   05ED  F0                MOVX    @DPTR,A
   \   05EE  A3                INC     DPTR
   \   05EF  7402              MOV     A,#HIGH(?0118)
   \   05F1  F0                MOVX    @DPTR,A
   \   05F2  A3                INC     DPTR
   \   05F3  744E              MOV     A,#LOW(?0118)
   \   05F5  F0                MOVX    @DPTR,A
   \   05F6  7D00              MOV     R5,#LOW(commandLine)
   \   05F8  7E00              MOV     R6,#HIGH(commandLine)
   \   05FA  1F                DEC     R7
   \   05FB  120000            LCALL   $REFFN myStrCmpNoCase
   \   05FE  BC0006            CJNE    R4,#0,?0117
   \   0601            ?0116:
    570          
    571                  WavTone();
   \   0601  120000            LCALL   $REFFN WavTone
   \   0604  020D4C            LJMP    ?0119
   \   0607            ?0117:
    572          
    573              } else if (!myStrCmpNoCase(commandLine[0], CM_PLAY)) {
   \   0607  7F02              MOV     R7,#2
   \   0609  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   060C  EF                MOV     A,R7
   \   060D  F0                MOVX    @DPTR,A
   \   060E  A3                INC     DPTR
   \   060F  7402              MOV     A,#HIGH(?0122)
   \   0611  F0                MOVX    @DPTR,A
   \   0612  A3                INC     DPTR
   \   0613  7453              MOV     A,#LOW(?0122)
   \   0615  F0                MOVX    @DPTR,A
   \   0616  7D00              MOV     R5,#LOW(commandLine)
   \   0618  7E00              MOV     R6,#HIGH(commandLine)
   \   061A  1F                DEC     R7
   \   061B  120000            LCALL   $REFFN myStrCmpNoCase
   \   061E  BC0011            CJNE    R4,#0,?0121
   \   0621            ?0120:
    574          
    575                  receivedDTMF = 0;
   \   0621  E4                CLR     A
   \   0622  900000            MOV     DPTR,#receivedDTMF
   \   0625  F0                MOVX    @DPTR,A
    576                  PlayFile(commandLine[1]);
   \   0626  7D10              MOV     R5,#LOW(commandLine+16)
   \   0628  7E00              MOV     R6,#HIGH(commandLine+16)
   \   062A  7F01              MOV     R7,#1
   \   062C  120000            LCALL   $REFFN PlayFile
   \   062F  020D4C            LJMP    ?0123
   \   0632            ?0121:
    577          
    578              } else if (!myStrCmpNoCase(commandLine[0], CM_DTMF)) {
   \   0632  7F02              MOV     R7,#2
   \   0634  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0637  EF                MOV     A,R7
   \   0638  F0                MOVX    @DPTR,A
   \   0639  A3                INC     DPTR
   \   063A  7402              MOV     A,#HIGH(?0126)
   \   063C  F0                MOVX    @DPTR,A
   \   063D  A3                INC     DPTR
   \   063E  7458              MOV     A,#LOW(?0126)
   \   0640  F0                MOVX    @DPTR,A
   \   0641  7D00              MOV     R5,#LOW(commandLine)
   \   0643  7E00              MOV     R6,#HIGH(commandLine)
   \   0645  1F                DEC     R7
   \   0646  120000            LCALL   $REFFN myStrCmpNoCase
   \   0649  BC000C            CJNE    R4,#0,?0125
   \   064C            ?0124:
    579          
    580                  MakeDTMFTones(commandLine[1]);
   \   064C  7D10              MOV     R5,#LOW(commandLine+16)
   \   064E  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0650  7F01              MOV     R7,#1
   \   0652  120000            LCALL   $REFFN MakeDTMFTones
   \   0655  020D4C            LJMP    ?0127
   \   0658            ?0125:
    581          /*
    582              } else if (!myStrCmpNoCase(commandLine[0], CM_WAIT_DTMF)) {
    583          
    584                  WaitForDTMF();
    585          */
    586              } else if (!myStrCmpNoCase(commandLine[0], CM_HANG_UP)) {
   \   0658  7F02              MOV     R7,#2
   \   065A  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   065D  EF                MOV     A,R7
   \   065E  F0                MOVX    @DPTR,A
   \   065F  A3                INC     DPTR
   \   0660  7402              MOV     A,#HIGH(?0130)
   \   0662  F0                MOVX    @DPTR,A
   \   0663  A3                INC     DPTR
   \   0664  745D              MOV     A,#LOW(?0130)
   \   0666  F0                MOVX    @DPTR,A
   \   0667  7D00              MOV     R5,#LOW(commandLine)
   \   0669  7E00              MOV     R6,#HIGH(commandLine)
   \   066B  1F                DEC     R7
   \   066C  120000            LCALL   $REFFN myStrCmpNoCase
   \   066F  BC0006            CJNE    R4,#0,?0129
   \   0672            ?0128:
    587          
    588                  HangUp();
   \   0672  120000            LCALL   $REFFN HangUp
   \   0675  020D4C            LJMP    ?0131
   \   0678            ?0129:
    589          
    590              } else if (!myStrCmpNoCase(commandLine[0], CM_LIFT_PHONE)) {
   \   0678  7F02              MOV     R7,#2
   \   067A  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   067D  EF                MOV     A,R7
   \   067E  F0                MOVX    @DPTR,A
   \   067F  A3                INC     DPTR
   \   0680  7402              MOV     A,#HIGH(?0134)
   \   0682  F0                MOVX    @DPTR,A
   \   0683  A3                INC     DPTR
   \   0684  7460              MOV     A,#LOW(?0134)
   \   0686  F0                MOVX    @DPTR,A
   \   0687  7D00              MOV     R5,#LOW(commandLine)
   \   0689  7E00              MOV     R6,#HIGH(commandLine)
   \   068B  1F                DEC     R7
   \   068C  120000            LCALL   $REFFN myStrCmpNoCase
   \   068F  BC0006            CJNE    R4,#0,?0133
   \   0692            ?0132:
    591          
    592                  LiftPhone();
   \   0692  120000            LCALL   $REFFN LiftPhone
   \   0695  020D4C            LJMP    ?0135
   \   0698            ?0133:
    593          /*
    594              } else if (!myStrCmpNoCase(commandLine[0], CM_WAIT_RING)) {
    595          
    596                  i = myStr2Int(commandLine[1]);
    597           
    598                  WaitForRingSignals(i);
    599          */
    600              } else if (!myStrCmpNoCase(commandLine[0], CM_WAIT_FOR)) {
   \   0698  7F02              MOV     R7,#2
   \   069A  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   069D  EF                MOV     A,R7
   \   069E  F0                MOVX    @DPTR,A
   \   069F  A3                INC     DPTR
   \   06A0  7402              MOV     A,#HIGH(?0138)
   \   06A2  F0                MOVX    @DPTR,A
   \   06A3  A3                INC     DPTR
   \   06A4  7463              MOV     A,#LOW(?0138)
   \   06A6  F0                MOVX    @DPTR,A
   \   06A7  7D00              MOV     R5,#LOW(commandLine)
   \   06A9  7E00              MOV     R6,#HIGH(commandLine)
   \   06AB  1F                DEC     R7
   \   06AC  120000            LCALL   $REFFN myStrCmpNoCase
   \   06AF  BC0017            CJNE    R4,#0,?0137
   \   06B2            ?0136:
    601          
    602                  i = myStr2Int(commandLine[1]);
   \   06B2  7D10              MOV     R5,#LOW(commandLine+16)
   \   06B4  7E00              MOV     R6,#HIGH(commandLine+16)
   \   06B6  7F01              MOV     R7,#1
   \   06B8  120000            LCALL   $REFFN myStr2Int
    603                  WaitFor(i);
   \   06BB  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   06BE  ED                MOV     A,R5
   \   06BF  F0                MOVX    @DPTR,A
   \   06C0  A3                INC     DPTR
   \   06C1  EC                MOV     A,R4
   \   06C2  F0                MOVX    @DPTR,A
   \   06C3  120000            LCALL   $REFFN WaitFor
   \   06C6  020D4C            LJMP    ?0139
   \   06C9            ?0137:
    604          
    605              } else if (!myStrCmpNoCase(commandLine[0], CM_ANS_ON)) {
   \   06C9  7F02              MOV     R7,#2
   \   06CB  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   06CE  EF                MOV     A,R7
   \   06CF  F0                MOVX    @DPTR,A
   \   06D0  A3                INC     DPTR
   \   06D1  7402              MOV     A,#HIGH(?0142)
   \   06D3  F0                MOVX    @DPTR,A
   \   06D4  A3                INC     DPTR
   \   06D5  746B              MOV     A,#LOW(?0142)
   \   06D7  F0                MOVX    @DPTR,A
   \   06D8  7D00              MOV     R5,#LOW(commandLine)
   \   06DA  7E00              MOV     R6,#HIGH(commandLine)
   \   06DC  1F                DEC     R7
   \   06DD  120000            LCALL   $REFFN myStrCmpNoCase
   \   06E0  BC0011            CJNE    R4,#0,?0141
   \   06E3            ?0140:
    606           
    607                  answerOn = 1;
   \   06E3  7401              MOV     A,#1
   \   06E5  900000            MOV     DPTR,#answerOn
   \   06E8  F0                MOVX    @DPTR,A
    608                  P3.5 = 0;
   \   06E9  C2B5              CLR     P3.5
    609                  WriteCalenderByte(NV_ANSWERING_ON, answerOn);
   \   06EB  FD                MOV     R5,A
   \   06EC  7C08              MOV     R4,#8
   \   06EE  120000            LCALL   $REFFN WriteCalenderByte
   \   06F1  020D4C            LJMP    ?0143
   \   06F4            ?0141:
    610          
    611              } else if (!myStrCmpNoCase(commandLine[0], CM_ANS_OFF)) {
   \   06F4  7F02              MOV     R7,#2
   \   06F6  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   06F9  EF                MOV     A,R7
   \   06FA  F0                MOVX    @DPTR,A
   \   06FB  A3                INC     DPTR
   \   06FC  7402              MOV     A,#HIGH(?0146)
   \   06FE  F0                MOVX    @DPTR,A
   \   06FF  A3                INC     DPTR
   \   0700  7471              MOV     A,#LOW(?0146)
   \   0702  F0                MOVX    @DPTR,A
   \   0703  7D00              MOV     R5,#LOW(commandLine)
   \   0705  7E00              MOV     R6,#HIGH(commandLine)
   \   0707  1F                DEC     R7
   \   0708  120000            LCALL   $REFFN myStrCmpNoCase
   \   070B  BC0010            CJNE    R4,#0,?0145
   \   070E            ?0144:
    612           
    613                  answerOn = 0;
   \   070E  E4                CLR     A
   \   070F  900000            MOV     DPTR,#answerOn
   \   0712  F0                MOVX    @DPTR,A
    614                  P3.5 = 1;
   \   0713  D2B5              SETB    P3.5
    615                  WriteCalenderByte(NV_ANSWERING_ON, answerOn);
   \   0715  FD                MOV     R5,A
   \   0716  7C08              MOV     R4,#8
   \   0718  120000            LCALL   $REFFN WriteCalenderByte
   \   071B  020D4C            LJMP    ?0147
   \   071E            ?0145:
    616                  
    617              } else if (!myStrCmpNoCase(commandLine[0], CM_CRE_LOG)) {
   \   071E  7F02              MOV     R7,#2
   \   0720  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0723  EF                MOV     A,R7
   \   0724  F0                MOVX    @DPTR,A
   \   0725  A3                INC     DPTR
   \   0726  7402              MOV     A,#HIGH(?0150)
   \   0728  F0                MOVX    @DPTR,A
   \   0729  A3                INC     DPTR
   \   072A  7478              MOV     A,#LOW(?0150)
   \   072C  F0                MOVX    @DPTR,A
   \   072D  7D00              MOV     R5,#LOW(commandLine)
   \   072F  7E00              MOV     R6,#HIGH(commandLine)
   \   0731  1F                DEC     R7
   \   0732  120000            LCALL   $REFFN myStrCmpNoCase
   \   0735  BC000F            CJNE    R4,#0,?0149
   \   0738            ?0148:
    618                  CreateLog();
   \   0738  120000            LCALL   $REFFN CreateLog
    619                  SendStringEOLRS232("Log created here too!");
   \   073B  7D82              MOV     R5,#LOW(?0151)
   \   073D  7E02              MOV     R6,#HIGH(?0151)
   \   073F  7F02              MOV     R7,#2
   \   0741  120000            LCALL   $REFFN SendStringEOLRS232
   \   0744  020D4C            LJMP    ?0152
   \   0747            ?0149:
    620              } else if (!myStrCmpNoCase(commandLine[0], CM_ENTER_CODE)) {
   \   0747  7F02              MOV     R7,#2
   \   0749  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   074C  EF                MOV     A,R7
   \   074D  F0                MOVX    @DPTR,A
   \   074E  A3                INC     DPTR
   \   074F  7402              MOV     A,#HIGH(?0155)
   \   0751  F0                MOVX    @DPTR,A
   \   0752  A3                INC     DPTR
   \   0753  7498              MOV     A,#LOW(?0155)
   \   0755  F0                MOVX    @DPTR,A
   \   0756  7D00              MOV     R5,#LOW(commandLine)
   \   0758  7E00              MOV     R6,#HIGH(commandLine)
   \   075A  1F                DEC     R7
   \   075B  120000            LCALL   $REFFN myStrCmpNoCase
   \   075E  BC0006            CJNE    R4,#0,?0154
   \   0761            ?0153:
    621                  EnterCode();
   \   0761  120000            LCALL   $REFFN EnterCode
   \   0764  020D4C            LJMP    ?0156
   \   0767            ?0154:
    622              } else if (!myStrCmpNoCase(commandLine[0], CM_READ_CALENDER_BYTE)) {
   \   0767  7F02              MOV     R7,#2
   \   0769  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   076C  EF                MOV     A,R7
   \   076D  F0                MOVX    @DPTR,A
   \   076E  A3                INC     DPTR
   \   076F  7402              MOV     A,#HIGH(?0159)
   \   0771  F0                MOVX    @DPTR,A
   \   0772  A3                INC     DPTR
   \   0773  74A2              MOV     A,#LOW(?0159)
   \   0775  F0                MOVX    @DPTR,A
   \   0776  7D00              MOV     R5,#LOW(commandLine)
   \   0778  7E00              MOV     R6,#HIGH(commandLine)
   \   077A  1F                DEC     R7
   \   077B  120000            LCALL   $REFFN myStrCmpNoCase
   \   077E  BC006A            CJNE    R4,#0,?0158
   \   0781            ?0157:
    623                      
    624                  i = myStr2Int(commandLine[1]);
   \   0781  7D10              MOV     R5,#LOW(commandLine+16)
   \   0783  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0785  7F01              MOV     R7,#1
   \   0787  120000            LCALL   $REFFN myStr2Int
    625                  if ((i >= 0) && (i < 64)) {
   \   078A  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   078D  ED                MOV     A,R5
   \   078E  F0                MOVX    @DPTR,A
   \   078F  A3                INC     DPTR
   \   0790  EC                MOV     A,R4
   \   0791  F0                MOVX    @DPTR,A
   \   0792  ED                MOV     A,R5
   \   0793  33                RLC     A
   \   0794  4049              JC      ?0161
   \   0796  C3                CLR     C
   \   0797  EC                MOV     A,R4
   \   0798  9440              SUBB    A,#64
   \   079A  ED                MOV     A,R5
   \   079B  6480              XRL     A,#128
   \   079D  9480              SUBB    A,#128
   \   079F  503E              JNC     ?0161
   \   07A1            ?0163:
   \   07A1            ?0162:
   \   07A1            ?0160:
    626                      if (!ReadCalenderByte(i, &j)) {
   \   07A1  EC                MOV     A,R4
   \   07A2  7D00              MOV     R5,#LOW ($LOCBX DecodeAndPerform+2)
   \   07A4  7E00              MOV     R6,#HIGH ($LOCBX DecodeAndPerform+2)
   \   07A6  7F01              MOV     R7,#1
   \   07A8  120000            LCALL   $REFFN ReadCalenderByte
   \   07AB  BC0026            CJNE    R4,#0,?0165
   \   07AE            ?0164:
    627                          myLong2HexStr(j, msg);
   \   07AE  7F01              MOV     R7,#1
   \   07B0  900000            MOV     DPTR,#$PRMBX myLong2HexStr+4
   \   07B3  EF                MOV     A,R7
   \   07B4  F0                MOVX    @DPTR,A
   \   07B5  A3                INC     DPTR
   \   07B6  7401              MOV     A,#HIGH(msg)
   \   07B8  F0                MOVX    @DPTR,A
   \   07B9  A3                INC     DPTR
   \   07BA  7484              MOV     A,#LOW(msg)
   \   07BC  F0                MOVX    @DPTR,A
   \   07BD  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   07C0  E0                MOVX    A,@DPTR
   \   07C1  FC                MOV     R4,A
   \   07C2  E4                CLR     A
   \   07C3  FD                MOV     R5,A
   \   07C4  FE                MOV     R6,A
   \   07C5  1F                DEC     R7
   \   07C6  120000            LCALL   $REFFN myLong2HexStr
    628                          SendStringEOLRS232(msg);
    629                      } else {
   \   07C9  7D84              MOV     R5,#LOW(msg)
   \   07CB  7E01              MOV     R6,#HIGH(msg)
   \   07CD  7F01              MOV     R7,#1
   \   07CF  120000            LCALL   $REFFN SendStringEOLRS232
   \   07D2  8009              SJMP    ?0166
   \   07D4            ?0165:
    630                          SendStringEOLRS232("Error in read");
   \   07D4  7DA5              MOV     R5,#LOW(?0167)
   \   07D6  7E02              MOV     R6,#HIGH(?0167)
   \   07D8  7F02              MOV     R7,#2
   \   07DA  120000            LCALL   $REFFN SendStringEOLRS232
   \   07DD            ?0166:
    631                      }
    632                  } else {
   \   07DD  8009              SJMP    ?0168
   \   07DF            ?0161:
    633                      SendStringEOLRS232("Illegal address");
   \   07DF  7DB3              MOV     R5,#LOW(?0169)
   \   07E1  7E02              MOV     R6,#HIGH(?0169)
   \   07E3  7F02              MOV     R7,#2
   \   07E5  120000            LCALL   $REFFN SendStringEOLRS232
   \   07E8            ?0168:
   \   07E8  020D4C            LJMP    ?0170
   \   07EB            ?0158:
    634                  }
    635           
    636              } else if (!myStrCmpNoCase(commandLine[0], CM_WRITE_CALENDER_BYTE)) {
   \   07EB  7F02              MOV     R7,#2
   \   07ED  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   07F0  EF                MOV     A,R7
   \   07F1  F0                MOVX    @DPTR,A
   \   07F2  A3                INC     DPTR
   \   07F3  7402              MOV     A,#HIGH(?0173)
   \   07F5  F0                MOVX    @DPTR,A
   \   07F6  A3                INC     DPTR
   \   07F7  74C3              MOV     A,#LOW(?0173)
   \   07F9  F0                MOVX    @DPTR,A
   \   07FA  7D00              MOV     R5,#LOW(commandLine)
   \   07FC  7E00              MOV     R6,#HIGH(commandLine)
   \   07FE  1F                DEC     R7
   \   07FF  120000            LCALL   $REFFN myStrCmpNoCase
   \   0802  BC0058            CJNE    R4,#0,?0172
   \   0805            ?0171:
    637                  i = myStr2Int(commandLine[1]);
   \   0805  7D10              MOV     R5,#LOW(commandLine+16)
   \   0807  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0809  7F01              MOV     R7,#1
   \   080B  120000            LCALL   $REFFN myStr2Int
    638                  j = myStr2Int(commandLine[2]);
   \   080E  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0811  ED                MOV     A,R5
   \   0812  F0                MOVX    @DPTR,A
   \   0813  A3                INC     DPTR
   \   0814  EC                MOV     A,R4
   \   0815  F0                MOVX    @DPTR,A
   \   0816  7D20              MOV     R5,#LOW(commandLine+32)
   \   0818  7E00              MOV     R6,#HIGH(commandLine+32)
   \   081A  7F01              MOV     R7,#1
   \   081C  120000            LCALL   $REFFN myStr2Int
   \   081F  EC                MOV     A,R4
   \   0820  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   0823  F0                MOVX    @DPTR,A
    639                  if ((i >= 0) && (i < 64)) {
   \   0824  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0827  E0                MOVX    A,@DPTR
   \   0828  33                RLC     A
   \   0829  4026              JC      ?0175
   \   082B  C3                CLR     C
   \   082C  A3                INC     DPTR
   \   082D  E0                MOVX    A,@DPTR
   \   082E  9440              SUBB    A,#64
   \   0830  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0833  E0                MOVX    A,@DPTR
   \   0834  6480              XRL     A,#128
   \   0836  9480              SUBB    A,#128
   \   0838  5017              JNC     ?0175
   \   083A            ?0177:
   \   083A            ?0176:
   \   083A            ?0174:
    640                      if (WriteCalenderByte(i, j)) {
   \   083A  A3                INC     DPTR
   \   083B  E0                MOVX    A,@DPTR
   \   083C  FC                MOV     R4,A
   \   083D  A3                INC     DPTR
   \   083E  E0                MOVX    A,@DPTR
   \   083F  FD                MOV     R5,A
   \   0840  120000            LCALL   $REFFN WriteCalenderByte
   \   0843  EC                MOV     A,R4
   \   0844  6009              JZ      ?0179
   \   0846            ?0178:
    641                          SendStringEOLRS232("Error in write");
   \   0846  7DC6              MOV     R5,#LOW(?0180)
   \   0848  7E02              MOV     R6,#HIGH(?0180)
   \   084A  7F02              MOV     R7,#2
   \   084C  120000            LCALL   $REFFN SendStringEOLRS232
   \   084F            ?0179:
    642                      }
    643                  } else {
   \   084F  8009              SJMP    ?0181
   \   0851            ?0175:
    644                      SendStringEOLRS232("Illegal address");
   \   0851  7DB3              MOV     R5,#LOW(?0169)
   \   0853  7E02              MOV     R6,#HIGH(?0169)
   \   0855  7F02              MOV     R7,#2
   \   0857  120000            LCALL   $REFFN SendStringEOLRS232
   \   085A            ?0181:
   \   085A  020D4C            LJMP    ?0182
   \   085D            ?0172:
    645                  }
    646          
    647          /*
    648              } else if (!myStrCmpNoCase(commandLine[0], CM_LCD_SET)) {
    649          
    650                  i = myStr2Int(commandLine[1]);
    651                  j = myStr2Int(commandLine[2]);
    652                  SetLCDReg(i, j);
    653          */
    654              } else if (!myStrCmpNoCase(commandLine[0], CM_GOTO_LABEL)) {
   \   085D  7F02              MOV     R7,#2
   \   085F  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0862  EF                MOV     A,R7
   \   0863  F0                MOVX    @DPTR,A
   \   0864  A3                INC     DPTR
   \   0865  7402              MOV     A,#HIGH(?0185)
   \   0867  F0                MOVX    @DPTR,A
   \   0868  A3                INC     DPTR
   \   0869  74D5              MOV     A,#LOW(?0185)
   \   086B  F0                MOVX    @DPTR,A
   \   086C  7D00              MOV     R5,#LOW(commandLine)
   \   086E  7E00              MOV     R6,#HIGH(commandLine)
   \   0870  1F                DEC     R7
   \   0871  120000            LCALL   $REFFN myStrCmpNoCase
   \   0874  BC0025            CJNE    R4,#0,?0184
   \   0877            ?0183:
    655                  
    656                  if (batFilePtr) {
   \   0877  9001E9            MOV     DPTR,#batFilePtr
   \   087A  E0                MOVX    A,@DPTR
   \   087B  FF                MOV     R7,A
   \   087C  A3                INC     DPTR
   \   087D  E0                MOVX    A,@DPTR
   \   087E  FE                MOV     R6,A
   \   087F  A3                INC     DPTR
   \   0880  E0                MOVX    A,@DPTR
   \   0881  FD                MOV     R5,A
   \   0882  4E                ORL     A,R6
   \   0883  600B              JZ      ?0187
   \   0885            ?0186:
    657                      GotoLabel(commandLine[1]);
   \   0885  7D10              MOV     R5,#LOW(commandLine+16)
   \   0887  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0889  7F01              MOV     R7,#1
   \   088B  120000            LCALL   $REFFN GotoLabel
    658                  } else {
   \   088E  8009              SJMP    ?0188
   \   0890            ?0187:
    659                      SendStringEOLRS232("No BAT-file is running!");
   \   0890  7DDA              MOV     R5,#LOW(?0189)
   \   0892  7E02              MOV     R6,#HIGH(?0189)
   \   0894  7F02              MOV     R7,#2
   \   0896  120000            LCALL   $REFFN SendStringEOLRS232
   \   0899            ?0188:
   \   0899  020D4C            LJMP    ?0190
   \   089C            ?0184:
    660                  }
    661          
    662              } else if (!myStrCmpNoCase(commandLine[0], CM_GOTO_CAT_EQUAL)) {
   \   089C  7F02              MOV     R7,#2
   \   089E  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   08A1  EF                MOV     A,R7
   \   08A2  F0                MOVX    @DPTR,A
   \   08A3  A3                INC     DPTR
   \   08A4  7402              MOV     A,#HIGH(?0193)
   \   08A6  F0                MOVX    @DPTR,A
   \   08A7  A3                INC     DPTR
   \   08A8  74F2              MOV     A,#LOW(?0193)
   \   08AA  F0                MOVX    @DPTR,A
   \   08AB  7D00              MOV     R5,#LOW(commandLine)
   \   08AD  7E00              MOV     R6,#HIGH(commandLine)
   \   08AF  1F                DEC     R7
   \   08B0  120000            LCALL   $REFFN myStrCmpNoCase
   \   08B3  BC003C            CJNE    R4,#0,?0192
   \   08B6            ?0191:
    663                  
    664                  if (batFilePtr) {
   \   08B6  9001E9            MOV     DPTR,#batFilePtr
   \   08B9  E0                MOVX    A,@DPTR
   \   08BA  FF                MOV     R7,A
   \   08BB  A3                INC     DPTR
   \   08BC  E0                MOVX    A,@DPTR
   \   08BD  FE                MOV     R6,A
   \   08BE  A3                INC     DPTR
   \   08BF  E0                MOVX    A,@DPTR
   \   08C0  FD                MOV     R5,A
   \   08C1  4E                ORL     A,R6
   \   08C2  6022              JZ      ?0195
   \   08C4            ?0194:
    665                      if (callerCategory == myStr2Int(commandLine[1])) GotoLabel(commandLine[2]);
   \   08C4  7D10              MOV     R5,#LOW(commandLine+16)
   \   08C6  7E00              MOV     R6,#HIGH(commandLine+16)
   \   08C8  7F01              MOV     R7,#1
   \   08CA  120000            LCALL   $REFFN myStr2Int
   \   08CD  900000            MOV     DPTR,#callerCategory
   \   08D0  E0                MOVX    A,@DPTR
   \   08D1  7F00              MOV     R7,#0
   \   08D3  FE                MOV     R6,A
   \   08D4  EC                MOV     A,R4
   \   08D5  6E                XRL     A,R6
   \   08D6  7002              JNZ     ?0432
   \   08D8  ED                MOV     A,R5
   \   08D9  6F                XRL     A,R7
   \   08DA            ?0432:
   \   08DA  7008              JNZ     ?0197
   \   08DC            ?0196:
   \   08DC  7D20              MOV     R5,#LOW(commandLine+32)
   \   08DE  7E00              MOV     R6,#HIGH(commandLine+32)
   \   08E0  0F                INC     R7
   \   08E1  120000            LCALL   $REFFN GotoLabel
   \   08E4            ?0197:
    666                  } else {
   \   08E4  8009              SJMP    ?0198
   \   08E6            ?0195:
    667                      SendStringEOLRS232("No BAT-file is running!");
   \   08E6  7DDA              MOV     R5,#LOW(?0189)
   \   08E8  7E02              MOV     R6,#HIGH(?0189)
   \   08EA  7F02              MOV     R7,#2
   \   08EC  120000            LCALL   $REFFN SendStringEOLRS232
   \   08EF            ?0198:
   \   08EF  020D4C            LJMP    ?0199
   \   08F2            ?0192:
    668                  }
    669              } else if (!myStrCmpNoCase(commandLine[0], CM_RECMSG)) {
   \   08F2  7F02              MOV     R7,#2
   \   08F4  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   08F7  EF                MOV     A,R7
   \   08F8  F0                MOVX    @DPTR,A
   \   08F9  A3                INC     DPTR
   \   08FA  7402              MOV     A,#HIGH(?0202)
   \   08FC  F0                MOVX    @DPTR,A
   \   08FD  A3                INC     DPTR
   \   08FE  74FC              MOV     A,#LOW(?0202)
   \   0900  F0                MOVX    @DPTR,A
   \   0901  7D00              MOV     R5,#LOW(commandLine)
   \   0903  7E00              MOV     R6,#HIGH(commandLine)
   \   0905  1F                DEC     R7
   \   0906  120000            LCALL   $REFFN myStrCmpNoCase
   \   0909  BC0006            CJNE    R4,#0,?0201
   \   090C            ?0200:
    670                  RecordCallerMessage();
   \   090C  120000            LCALL   $REFFN RecordCallerMessage
   \   090F  020D4C            LJMP    ?0203
   \   0912            ?0201:
    671              } else if (!myStrCmpNoCase(commandLine[0], CM_QUESTION)) {
   \   0912  7F02              MOV     R7,#2
   \   0914  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0917  EF                MOV     A,R7
   \   0918  F0                MOVX    @DPTR,A
   \   0919  A3                INC     DPTR
   \   091A  7403              MOV     A,#HIGH(?0206)
   \   091C  F0                MOVX    @DPTR,A
   \   091D  A3                INC     DPTR
   \   091E  7403              MOV     A,#LOW(?0206)
   \   0920  F0                MOVX    @DPTR,A
   \   0921  7D00              MOV     R5,#LOW(commandLine)
   \   0923  7E00              MOV     R6,#HIGH(commandLine)
   \   0925  1F                DEC     R7
   \   0926  120000            LCALL   $REFFN myStrCmpNoCase
   \   0929  BC0006            CJNE    R4,#0,?0205
   \   092C            ?0204:
    672                  AskQuestionMsg();
   \   092C  120000            LCALL   $REFFN AskQuestionMsg
   \   092F  020D4C            LJMP    ?0207
   \   0932            ?0205:
    673              } else if (!myStrCmpNoCase(commandLine[0], CM_PLAYNEW)) {
   \   0932  7F02              MOV     R7,#2
   \   0934  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0937  EF                MOV     A,R7
   \   0938  F0                MOVX    @DPTR,A
   \   0939  A3                INC     DPTR
   \   093A  7403              MOV     A,#HIGH(?0210)
   \   093C  F0                MOVX    @DPTR,A
   \   093D  A3                INC     DPTR
   \   093E  740C              MOV     A,#LOW(?0210)
   \   0940  F0                MOVX    @DPTR,A
   \   0941  7D00              MOV     R5,#LOW(commandLine)
   \   0943  7E00              MOV     R6,#HIGH(commandLine)
   \   0945  1F                DEC     R7
   \   0946  120000            LCALL   $REFFN myStrCmpNoCase
   \   0949  BC000E            CJNE    R4,#0,?0209
   \   094C            ?0208:
    674                  PlayNewMessages();
   \   094C  120000            LCALL   $REFFN PlayNewMessages
    675                  receivedDTMF = 0;
   \   094F  E4                CLR     A
   \   0950  900000            MOV     DPTR,#receivedDTMF
   \   0953  F0                MOVX    @DPTR,A
    676                  ResetDTMFIndex();
   \   0954  120000            LCALL   $REFFN ResetDTMFIndex
   \   0957  020D4C            LJMP    ?0211
   \   095A            ?0209:
    677              } else if (!myStrCmpNoCase(commandLine[0], CM_WAITCALL)) {
   \   095A  7F02              MOV     R7,#2
   \   095C  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   095F  EF                MOV     A,R7
   \   0960  F0                MOVX    @DPTR,A
   \   0961  A3                INC     DPTR
   \   0962  7403              MOV     A,#HIGH(?0214)
   \   0964  F0                MOVX    @DPTR,A
   \   0965  A3                INC     DPTR
   \   0966  7414              MOV     A,#LOW(?0214)
   \   0968  F0                MOVX    @DPTR,A
   \   0969  7D00              MOV     R5,#LOW(commandLine)
   \   096B  7E00              MOV     R6,#HIGH(commandLine)
   \   096D  1F                DEC     R7
   \   096E  120000            LCALL   $REFFN myStrCmpNoCase
   \   0971  BC0006            CJNE    R4,#0,?0213
   \   0974            ?0212:
    678                  WaitForCall();
   \   0974  120000            LCALL   $REFFN WaitForCall
   \   0977  020D4C            LJMP    ?0215
   \   097A            ?0213:
    679              } else if (!myStrCmpNoCase(commandLine[0], CM_READ_PB)) {
   \   097A  7F02              MOV     R7,#2
   \   097C  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   097F  EF                MOV     A,R7
   \   0980  F0                MOVX    @DPTR,A
   \   0981  A3                INC     DPTR
   \   0982  7403              MOV     A,#HIGH(?0218)
   \   0984  F0                MOVX    @DPTR,A
   \   0985  A3                INC     DPTR
   \   0986  741D              MOV     A,#LOW(?0218)
   \   0988  F0                MOVX    @DPTR,A
   \   0989  7D00              MOV     R5,#LOW(commandLine)
   \   098B  7E00              MOV     R6,#HIGH(commandLine)
   \   098D  1F                DEC     R7
   \   098E  120000            LCALL   $REFFN myStrCmpNoCase
   \   0991  BC0006            CJNE    R4,#0,?0217
   \   0994            ?0216:
    680                  ReadPhoneBookFile();
   \   0994  120000            LCALL   $REFFN ReadPhoneBookFile
   \   0997  020D4C            LJMP    ?0219
   \   099A            ?0217:
    681              } else if (!myStrCmpNoCase(commandLine[0], CM_LOOKUP_PB)) {
   \   099A  7F02              MOV     R7,#2
   \   099C  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   099F  EF                MOV     A,R7
   \   09A0  F0                MOVX    @DPTR,A
   \   09A1  A3                INC     DPTR
   \   09A2  7403              MOV     A,#HIGH(?0222)
   \   09A4  F0                MOVX    @DPTR,A
   \   09A5  A3                INC     DPTR
   \   09A6  7424              MOV     A,#LOW(?0222)
   \   09A8  F0                MOVX    @DPTR,A
   \   09A9  7D00              MOV     R5,#LOW(commandLine)
   \   09AB  7E00              MOV     R6,#HIGH(commandLine)
   \   09AD  1F                DEC     R7
   \   09AE  120000            LCALL   $REFFN myStrCmpNoCase
   \   09B1  BC0054            CJNE    R4,#0,?0221
   \   09B4            ?0220:
    682                  LookUpCaller(commandLine[1], name,  &category);
   \   09B4  7F01              MOV     R7,#1
   \   09B6  900000            MOV     DPTR,#$PRMBX LookUpCaller+6
   \   09B9  EF                MOV     A,R7
   \   09BA  F0                MOVX    @DPTR,A
   \   09BB  A3                INC     DPTR
   \   09BC  7400              MOV     A,#HIGH ($LOCBX DecodeAndPerform+31)
   \   09BE  F0                MOVX    @DPTR,A
   \   09BF  A3                INC     DPTR
   \   09C0  7400              MOV     A,#LOW ($LOCBX DecodeAndPerform+31)
   \   09C2  F0                MOVX    @DPTR,A
   \   09C3  900000            MOV     DPTR,#$PRMBX LookUpCaller+3
   \   09C6  EF                MOV     A,R7
   \   09C7  F0                MOVX    @DPTR,A
   \   09C8  A3                INC     DPTR
   \   09C9  7400              MOV     A,#HIGH ($LOCBX DecodeAndPerform+11)
   \   09CB  F0                MOVX    @DPTR,A
   \   09CC  A3                INC     DPTR
   \   09CD  7400              MOV     A,#LOW ($LOCBX DecodeAndPerform+11)
   \   09CF  F0                MOVX    @DPTR,A
   \   09D0  7D10              MOV     R5,#LOW(commandLine+16)
   \   09D2  7E00              MOV     R6,#HIGH(commandLine+16)
   \   09D4  120000            LCALL   $REFFN LookUpCaller
    683                  SendStringRS232("Caller: ");
   \   09D7  7D2B              MOV     R5,#LOW(?0223)
   \   09D9  7E03              MOV     R6,#HIGH(?0223)
   \   09DB  7F02              MOV     R7,#2
   \   09DD  120000            LCALL   $REFFN SendStringRS232
    684                  SendStringEOLRS232(name);
   \   09E0  7D00              MOV     R5,#LOW ($LOCBX DecodeAndPerform+11)
   \   09E2  7E00              MOV     R6,#HIGH ($LOCBX DecodeAndPerform+11)
   \   09E4  7F01              MOV     R7,#1
   \   09E6  120000            LCALL   $REFFN SendStringEOLRS232
    685                  SendStringRS232("Category: ");
   \   09E9  7D34              MOV     R5,#LOW(?0224)
   \   09EB  7E03              MOV     R6,#HIGH(?0224)
   \   09ED  7F02              MOV     R7,#2
   \   09EF  120000            LCALL   $REFFN SendStringRS232
    686                  SendRS232('0' + category);
   \   09F2  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+31
   \   09F5  E0                MOVX    A,@DPTR
   \   09F6  2430              ADD     A,#48
   \   09F8  FC                MOV     R4,A
   \   09F9  120000            LCALL   $REFFN SendRS232
    687                  SendStringEOLRS232(" ");
   \   09FC  7D3F              MOV     R5,#LOW(?0225)
   \   09FE  7E03              MOV     R6,#HIGH(?0225)
   \   0A00  7F02              MOV     R7,#2
   \   0A02  120000            LCALL   $REFFN SendStringEOLRS232
   \   0A05  020D4C            LJMP    ?0226
   \   0A08            ?0221:
    688          
    689              } else if (!myStrCmpNoCase(commandLine[0], CM_SETWIPER)) {
   \   0A08  7F02              MOV     R7,#2
   \   0A0A  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0A0D  EF                MOV     A,R7
   \   0A0E  F0                MOVX    @DPTR,A
   \   0A0F  A3                INC     DPTR
   \   0A10  7403              MOV     A,#HIGH(?0229)
   \   0A12  F0                MOVX    @DPTR,A
   \   0A13  A3                INC     DPTR
   \   0A14  7441              MOV     A,#LOW(?0229)
   \   0A16  F0                MOVX    @DPTR,A
   \   0A17  7D00              MOV     R5,#LOW(commandLine)
   \   0A19  7E00              MOV     R6,#HIGH(commandLine)
   \   0A1B  1F                DEC     R7
   \   0A1C  120000            LCALL   $REFFN myStrCmpNoCase
   \   0A1F  BC0061            CJNE    R4,#0,?0228
   \   0A22            ?0227:
    690                  i = myStr2Int(commandLine[1]);
   \   0A22  7D10              MOV     R5,#LOW(commandLine+16)
   \   0A24  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0A26  7F01              MOV     R7,#1
   \   0A28  120000            LCALL   $REFFN myStr2Int
    691                  j = myStr2Int(commandLine[2]);
   \   0A2B  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0A2E  ED                MOV     A,R5
   \   0A2F  F0                MOVX    @DPTR,A
   \   0A30  A3                INC     DPTR
   \   0A31  EC                MOV     A,R4
   \   0A32  F0                MOVX    @DPTR,A
   \   0A33  7D20              MOV     R5,#LOW(commandLine+32)
   \   0A35  7E00              MOV     R6,#HIGH(commandLine+32)
   \   0A37  7F01              MOV     R7,#1
   \   0A39  120000            LCALL   $REFFN myStr2Int
   \   0A3C  EC                MOV     A,R4
   \   0A3D  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   0A40  F0                MOVX    @DPTR,A
    692                  j = SetDPWiper(i, j);
   \   0A41  E0                MOVX    A,@DPTR
   \   0A42  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+1
   \   0A45  E0                MOVX    A,@DPTR
   \   0A46  FC                MOV     R4,A
   \   0A47  A3                INC     DPTR
   \   0A48  E0                MOVX    A,@DPTR
   \   0A49  FD                MOV     R5,A
   \   0A4A  120000            LCALL   $REFFN SetDPWiper
   \   0A4D  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   0A50  E0                MOVX    A,@DPTR
   \   0A51  EC                MOV     A,R4
   \   0A52  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   0A55  F0                MOVX    @DPTR,A
    693                  SendStringRS232("Returned: "); 
   \   0A56  7D4A              MOV     R5,#LOW(?0230)
   \   0A58  7E03              MOV     R6,#HIGH(?0230)
   \   0A5A  7F02              MOV     R7,#2
   \   0A5C  120000            LCALL   $REFFN SendStringRS232
    694                  myInt2DecStr(j, msg);
   \   0A5F  7401              MOV     A,#1
   \   0A61  900000            MOV     DPTR,#$PRMBX myInt2DecStr+2
   \   0A64  F0                MOVX    @DPTR,A
   \   0A65  A3                INC     DPTR
   \   0A66  7401              MOV     A,#HIGH(msg)
   \   0A68  F0                MOVX    @DPTR,A
   \   0A69  A3                INC     DPTR
   \   0A6A  7484              MOV     A,#LOW(msg)
   \   0A6C  F0                MOVX    @DPTR,A
   \   0A6D  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   0A70  E0                MOVX    A,@DPTR
   \   0A71  7D00              MOV     R5,#0
   \   0A73  FC                MOV     R4,A
   \   0A74  120000            LCALL   $REFFN myInt2DecStr
    695                  SendStringEOLRS232(msg);
   \   0A77  7D84              MOV     R5,#LOW(msg)
   \   0A79  7E01              MOV     R6,#HIGH(msg)
   \   0A7B  7F01              MOV     R7,#1
   \   0A7D  120000            LCALL   $REFFN SendStringEOLRS232
   \   0A80  020D4C            LJMP    ?0231
   \   0A83            ?0228:
    696          
    697              } else if (!myStrCmpNoCase(commandLine[0], CM_SPEAKVOL)) {
   \   0A83  7F02              MOV     R7,#2
   \   0A85  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0A88  EF                MOV     A,R7
   \   0A89  F0                MOVX    @DPTR,A
   \   0A8A  A3                INC     DPTR
   \   0A8B  7403              MOV     A,#HIGH(?0234)
   \   0A8D  F0                MOVX    @DPTR,A
   \   0A8E  A3                INC     DPTR
   \   0A8F  7455              MOV     A,#LOW(?0234)
   \   0A91  F0                MOVX    @DPTR,A
   \   0A92  7D00              MOV     R5,#LOW(commandLine)
   \   0A94  7E00              MOV     R6,#HIGH(commandLine)
   \   0A96  1F                DEC     R7
   \   0A97  120000            LCALL   $REFFN myStrCmpNoCase
   \   0A9A  BC004E            CJNE    R4,#0,?0233
   \   0A9D            ?0232:
    698                  i = myStr2Int(commandLine[1]);
   \   0A9D  7D10              MOV     R5,#LOW(commandLine+16)
   \   0A9F  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0AA1  7F01              MOV     R7,#1
   \   0AA3  120000            LCALL   $REFFN myStr2Int
    699                          speakerVolume = i;
   \   0AA6  EC                MOV     A,R4
    700                          WriteCalenderByte(NV_SPEAKER_VOL, speakerVolume);
   \   0AA7  900000            MOV     DPTR,#speakerVolume
   \   0AAA  F0                MOVX    @DPTR,A
   \   0AAB  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0AAE  CD                XCH     A,R5
   \   0AAF  F0                MOVX    @DPTR,A
   \   0AB0  A3                INC     DPTR
   \   0AB1  CD                XCH     A,R5
   \   0AB2  F0                MOVX    @DPTR,A
   \   0AB3  900000            MOV     DPTR,#speakerVolume
   \   0AB6  E0                MOVX    A,@DPTR
   \   0AB7  FD                MOV     R5,A
   \   0AB8  7C0C              MOV     R4,#12
   \   0ABA  120000            LCALL   $REFFN WriteCalenderByte
    701                  SendStringRS232("Speaker volume set to: "); 
   \   0ABD  7D5E              MOV     R5,#LOW(?0235)
   \   0ABF  7E03              MOV     R6,#HIGH(?0235)
   \   0AC1  7F02              MOV     R7,#2
   \   0AC3  120000            LCALL   $REFFN SendStringRS232
    702                  myInt2DecStr(i, msg);
   \   0AC6  7401              MOV     A,#1
   \   0AC8  900000            MOV     DPTR,#$PRMBX myInt2DecStr+2
   \   0ACB  F0                MOVX    @DPTR,A
   \   0ACC  A3                INC     DPTR
   \   0ACD  7401              MOV     A,#HIGH(msg)
   \   0ACF  F0                MOVX    @DPTR,A
   \   0AD0  A3                INC     DPTR
   \   0AD1  7484              MOV     A,#LOW(msg)
   \   0AD3  F0                MOVX    @DPTR,A
   \   0AD4  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0AD7  E0                MOVX    A,@DPTR
   \   0AD8  FD                MOV     R5,A
   \   0AD9  A3                INC     DPTR
   \   0ADA  E0                MOVX    A,@DPTR
   \   0ADB  FC                MOV     R4,A
   \   0ADC  120000            LCALL   $REFFN myInt2DecStr
    703                  SendStringEOLRS232(msg);
   \   0ADF  7D84              MOV     R5,#LOW(msg)
   \   0AE1  7E01              MOV     R6,#HIGH(msg)
   \   0AE3  7F01              MOV     R7,#1
   \   0AE5  120000            LCALL   $REFFN SendStringEOLRS232
   \   0AE8  020D4C            LJMP    ?0236
   \   0AEB            ?0233:
    704              } else if (!myStrCmpNoCase(commandLine[0], CM_SETDPREG)) {
   \   0AEB  7F02              MOV     R7,#2
   \   0AED  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0AF0  EF                MOV     A,R7
   \   0AF1  F0                MOVX    @DPTR,A
   \   0AF2  A3                INC     DPTR
   \   0AF3  7403              MOV     A,#HIGH(?0239)
   \   0AF5  F0                MOVX    @DPTR,A
   \   0AF6  A3                INC     DPTR
   \   0AF7  7476              MOV     A,#LOW(?0239)
   \   0AF9  F0                MOVX    @DPTR,A
   \   0AFA  7D00              MOV     R5,#LOW(commandLine)
   \   0AFC  7E00              MOV     R6,#HIGH(commandLine)
   \   0AFE  1F                DEC     R7
   \   0AFF  120000            LCALL   $REFFN myStrCmpNoCase
   \   0B02  BC0003            CJNE    R4,#0,?0238
   \   0B05            ?0237:
   \   0B05  020D4C            LJMP    ?0240
   \   0B08            ?0238:
    705              } else if (!myStrCmpNoCase(commandLine[0], CM_TRFTOWIPER)) {
   \   0B08  7F02              MOV     R7,#2
   \   0B0A  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0B0D  EF                MOV     A,R7
   \   0B0E  F0                MOVX    @DPTR,A
   \   0B0F  A3                INC     DPTR
   \   0B10  7403              MOV     A,#HIGH(?0243)
   \   0B12  F0                MOVX    @DPTR,A
   \   0B13  A3                INC     DPTR
   \   0B14  747F              MOV     A,#LOW(?0243)
   \   0B16  F0                MOVX    @DPTR,A
   \   0B17  7D00              MOV     R5,#LOW(commandLine)
   \   0B19  7E00              MOV     R6,#HIGH(commandLine)
   \   0B1B  1F                DEC     R7
   \   0B1C  120000            LCALL   $REFFN myStrCmpNoCase
   \   0B1F  BC0003            CJNE    R4,#0,?0242
   \   0B22            ?0241:
   \   0B22  020D4C            LJMP    ?0244
   \   0B25            ?0242:
    706              } else if (!myStrCmpNoCase(commandLine[0], CM_READWIPER)) {
   \   0B25  7F02              MOV     R7,#2
   \   0B27  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0B2A  EF                MOV     A,R7
   \   0B2B  F0                MOVX    @DPTR,A
   \   0B2C  A3                INC     DPTR
   \   0B2D  7403              MOV     A,#HIGH(?0247)
   \   0B2F  F0                MOVX    @DPTR,A
   \   0B30  A3                INC     DPTR
   \   0B31  748A              MOV     A,#LOW(?0247)
   \   0B33  F0                MOVX    @DPTR,A
   \   0B34  7D00              MOV     R5,#LOW(commandLine)
   \   0B36  7E00              MOV     R6,#HIGH(commandLine)
   \   0B38  1F                DEC     R7
   \   0B39  120000            LCALL   $REFFN myStrCmpNoCase
   \   0B3C  BC0002            CJNE    R4,#0,$+5
   \   0B3F  8003              SJMP    $+5
   \   0B41  020BC4            LJMP    ?0246
   \   0B44            ?0245:
    707                  i = myStr2Int(commandLine[1]);
   \   0B44  7D10              MOV     R5,#LOW(commandLine+16)
   \   0B46  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0B48  7F01              MOV     R7,#1
   \   0B4A  120000            LCALL   $REFFN myStr2Int
    708                  i = ReadDPWiper(i, &j);
   \   0B4D  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0B50  ED                MOV     A,R5
   \   0B51  F0                MOVX    @DPTR,A
   \   0B52  A3                INC     DPTR
   \   0B53  EC                MOV     A,R4
   \   0B54  F0                MOVX    @DPTR,A
   \   0B55  7D00              MOV     R5,#LOW ($LOCBX DecodeAndPerform+2)
   \   0B57  7E00              MOV     R6,#HIGH ($LOCBX DecodeAndPerform+2)
   \   0B59  7F01              MOV     R7,#1
   \   0B5B  120000            LCALL   $REFFN ReadDPWiper
   \   0B5E  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0B61  E0                MOVX    A,@DPTR
   \   0B62  A3                INC     DPTR
   \   0B63  E0                MOVX    A,@DPTR
    709                  SendStringRS232("Returned: "); 
   \   0B64  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0B67  E4                CLR     A
   \   0B68  F0                MOVX    @DPTR,A
   \   0B69  A3                INC     DPTR
   \   0B6A  EC                MOV     A,R4
   \   0B6B  F0                MOVX    @DPTR,A
   \   0B6C  7D4A              MOV     R5,#LOW(?0230)
   \   0B6E  7E03              MOV     R6,#HIGH(?0230)
   \   0B70  7F02              MOV     R7,#2
   \   0B72  120000            LCALL   $REFFN SendStringRS232
    710                  myInt2DecStr(i, msg);
   \   0B75  7401              MOV     A,#1
   \   0B77  900000            MOV     DPTR,#$PRMBX myInt2DecStr+2
   \   0B7A  F0                MOVX    @DPTR,A
   \   0B7B  A3                INC     DPTR
   \   0B7C  7401              MOV     A,#HIGH(msg)
   \   0B7E  F0                MOVX    @DPTR,A
   \   0B7F  A3                INC     DPTR
   \   0B80  7484              MOV     A,#LOW(msg)
   \   0B82  F0                MOVX    @DPTR,A
   \   0B83  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0B86  E0                MOVX    A,@DPTR
   \   0B87  FD                MOV     R5,A
   \   0B88  A3                INC     DPTR
   \   0B89  E0                MOVX    A,@DPTR
   \   0B8A  FC                MOV     R4,A
   \   0B8B  120000            LCALL   $REFFN myInt2DecStr
    711                  SendStringEOLRS232(msg);
   \   0B8E  7D84              MOV     R5,#LOW(msg)
   \   0B90  7E01              MOV     R6,#HIGH(msg)
   \   0B92  7F01              MOV     R7,#1
   \   0B94  120000            LCALL   $REFFN SendStringEOLRS232
    712                  SendStringRS232("Value: "); 
   \   0B97  7D94              MOV     R5,#LOW(?0248)
   \   0B99  7E03              MOV     R6,#HIGH(?0248)
   \   0B9B  7F02              MOV     R7,#2
   \   0B9D  120000            LCALL   $REFFN SendStringRS232
    713                  myInt2DecStr(j, msg);
   \   0BA0  7401              MOV     A,#1
   \   0BA2  900000            MOV     DPTR,#$PRMBX myInt2DecStr+2
   \   0BA5  F0                MOVX    @DPTR,A
   \   0BA6  A3                INC     DPTR
   \   0BA7  7401              MOV     A,#HIGH(msg)
   \   0BA9  F0                MOVX    @DPTR,A
   \   0BAA  A3                INC     DPTR
   \   0BAB  7484              MOV     A,#LOW(msg)
   \   0BAD  F0                MOVX    @DPTR,A
   \   0BAE  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+2
   \   0BB1  E0                MOVX    A,@DPTR
   \   0BB2  7D00              MOV     R5,#0
   \   0BB4  FC                MOV     R4,A
   \   0BB5  120000            LCALL   $REFFN myInt2DecStr
    714                  SendStringEOLRS232(msg);
   \   0BB8  7D84              MOV     R5,#LOW(msg)
   \   0BBA  7E01              MOV     R6,#HIGH(msg)
   \   0BBC  7F01              MOV     R7,#1
   \   0BBE  120000            LCALL   $REFFN SendStringEOLRS232
   \   0BC1  020D4C            LJMP    ?0249
   \   0BC4            ?0246:
    715              } else if (!myStrCmpNoCase(commandLine[0], CM_DATAH)) {
   \   0BC4  7F02              MOV     R7,#2
   \   0BC6  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0BC9  EF                MOV     A,R7
   \   0BCA  F0                MOVX    @DPTR,A
   \   0BCB  A3                INC     DPTR
   \   0BCC  7403              MOV     A,#HIGH(?0252)
   \   0BCE  F0                MOVX    @DPTR,A
   \   0BCF  A3                INC     DPTR
   \   0BD0  749C              MOV     A,#LOW(?0252)
   \   0BD2  F0                MOVX    @DPTR,A
   \   0BD3  7D00              MOV     R5,#LOW(commandLine)
   \   0BD5  7E00              MOV     R6,#HIGH(commandLine)
   \   0BD7  1F                DEC     R7
   \   0BD8  120000            LCALL   $REFFN myStrCmpNoCase
   \   0BDB  BC0005            CJNE    R4,#0,?0251
   \   0BDE            ?0250:
    716                  DPDA = 1;
   \   0BDE  D2B4              SETB    P3.4
   \   0BE0  020D4C            LJMP    ?0253
   \   0BE3            ?0251:
    717              } else if (!myStrCmpNoCase(commandLine[0], CM_DATAL)) {
   \   0BE3  7F02              MOV     R7,#2
   \   0BE5  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0BE8  EF                MOV     A,R7
   \   0BE9  F0                MOVX    @DPTR,A
   \   0BEA  A3                INC     DPTR
   \   0BEB  7403              MOV     A,#HIGH(?0256)
   \   0BED  F0                MOVX    @DPTR,A
   \   0BEE  A3                INC     DPTR
   \   0BEF  749F              MOV     A,#LOW(?0256)
   \   0BF1  F0                MOVX    @DPTR,A
   \   0BF2  7D00              MOV     R5,#LOW(commandLine)
   \   0BF4  7E00              MOV     R6,#HIGH(commandLine)
   \   0BF6  1F                DEC     R7
   \   0BF7  120000            LCALL   $REFFN myStrCmpNoCase
   \   0BFA  BC0005            CJNE    R4,#0,?0255
   \   0BFD            ?0254:
    718                  DPDA = 0;
   \   0BFD  C2B4              CLR     P3.4
   \   0BFF  020D4C            LJMP    ?0257
   \   0C02            ?0255:
    719              } else if (!myStrCmpNoCase(commandLine[0], CM_CLKH)) {
   \   0C02  7F02              MOV     R7,#2
   \   0C04  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0C07  EF                MOV     A,R7
   \   0C08  F0                MOVX    @DPTR,A
   \   0C09  A3                INC     DPTR
   \   0C0A  7403              MOV     A,#HIGH(?0260)
   \   0C0C  F0                MOVX    @DPTR,A
   \   0C0D  A3                INC     DPTR
   \   0C0E  74A2              MOV     A,#LOW(?0260)
   \   0C10  F0                MOVX    @DPTR,A
   \   0C11  7D00              MOV     R5,#LOW(commandLine)
   \   0C13  7E00              MOV     R6,#HIGH(commandLine)
   \   0C15  1F                DEC     R7
   \   0C16  120000            LCALL   $REFFN myStrCmpNoCase
   \   0C19  BC0005            CJNE    R4,#0,?0259
   \   0C1C            ?0258:
    720                  DPCL = 1;
   \   0C1C  D2B3              SETB    P3.3
   \   0C1E  020D4C            LJMP    ?0261
   \   0C21            ?0259:
    721              } else if (!myStrCmpNoCase(commandLine[0], CM_CLKL)) {
   \   0C21  7F02              MOV     R7,#2
   \   0C23  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0C26  EF                MOV     A,R7
   \   0C27  F0                MOVX    @DPTR,A
   \   0C28  A3                INC     DPTR
   \   0C29  7403              MOV     A,#HIGH(?0264)
   \   0C2B  F0                MOVX    @DPTR,A
   \   0C2C  A3                INC     DPTR
   \   0C2D  74A5              MOV     A,#LOW(?0264)
   \   0C2F  F0                MOVX    @DPTR,A
   \   0C30  7D00              MOV     R5,#LOW(commandLine)
   \   0C32  7E00              MOV     R6,#HIGH(commandLine)
   \   0C34  1F                DEC     R7
   \   0C35  120000            LCALL   $REFFN myStrCmpNoCase
   \   0C38  BC0005            CJNE    R4,#0,?0263
   \   0C3B            ?0262:
    722                  DPCL = 0;
   \   0C3B  C2B3              CLR     P3.3
   \   0C3D  020D4C            LJMP    ?0265
   \   0C40            ?0263:
    723              } else if (!myStrCmpNoCase(commandLine[0], CM_CATJMP)) {
   \   0C40  7F02              MOV     R7,#2
   \   0C42  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0C45  EF                MOV     A,R7
   \   0C46  F0                MOVX    @DPTR,A
   \   0C47  A3                INC     DPTR
   \   0C48  7403              MOV     A,#HIGH(?0268)
   \   0C4A  F0                MOVX    @DPTR,A
   \   0C4B  A3                INC     DPTR
   \   0C4C  74A8              MOV     A,#LOW(?0268)
   \   0C4E  F0                MOVX    @DPTR,A
   \   0C4F  7D00              MOV     R5,#LOW(commandLine)
   \   0C51  7E00              MOV     R6,#HIGH(commandLine)
   \   0C53  1F                DEC     R7
   \   0C54  120000            LCALL   $REFFN myStrCmpNoCase
   \   0C57  BC001D            CJNE    R4,#0,?0267
   \   0C5A            ?0266:
    724                  if (CategoryHit(commandLine[1], callerCategory)) {
   \   0C5A  900000            MOV     DPTR,#callerCategory
   \   0C5D  E0                MOVX    A,@DPTR
   \   0C5E  FC                MOV     R4,A
   \   0C5F  7D10              MOV     R5,#LOW(commandLine+16)
   \   0C61  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0C63  7F01              MOV     R7,#1
   \   0C65  120000            LCALL   $REFFN CategoryHit
   \   0C68  EC                MOV     A,R4
   \   0C69  6009              JZ      ?0270
   \   0C6B            ?0269:
    725                                  GotoLabel(commandLine[2]);
   \   0C6B  7D20              MOV     R5,#LOW(commandLine+32)
   \   0C6D  7E00              MOV     R6,#HIGH(commandLine+32)
   \   0C6F  7F01              MOV     R7,#1
   \   0C71  120000            LCALL   $REFFN GotoLabel
   \   0C74            ?0270:
   \   0C74  020D4C            LJMP    ?0271
   \   0C77            ?0267:
    726                          }
    727              } else if (!myStrCmpNoCase(commandLine[0], CM_TESTCATJMP)) {
   \   0C77  7F02              MOV     R7,#2
   \   0C79  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0C7C  EF                MOV     A,R7
   \   0C7D  F0                MOVX    @DPTR,A
   \   0C7E  A3                INC     DPTR
   \   0C7F  7403              MOV     A,#HIGH(?0274)
   \   0C81  F0                MOVX    @DPTR,A
   \   0C82  A3                INC     DPTR
   \   0C83  74B0              MOV     A,#LOW(?0274)
   \   0C85  F0                MOVX    @DPTR,A
   \   0C86  7D00              MOV     R5,#LOW(commandLine)
   \   0C88  7E00              MOV     R6,#HIGH(commandLine)
   \   0C8A  1F                DEC     R7
   \   0C8B  120000            LCALL   $REFFN myStrCmpNoCase
   \   0C8E  BC002C            CJNE    R4,#0,?0273
   \   0C91            ?0272:
    728                  if (CategoryHit(commandLine[1], myStr2Int(commandLine[2]))) {
   \   0C91  7D20              MOV     R5,#LOW(commandLine+32)
   \   0C93  7E00              MOV     R6,#HIGH(commandLine+32)
   \   0C95  7F01              MOV     R7,#1
   \   0C97  120000            LCALL   $REFFN myStr2Int
   \   0C9A  7D10              MOV     R5,#LOW(commandLine+16)
   \   0C9C  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0C9E  7F01              MOV     R7,#1
   \   0CA0  120000            LCALL   $REFFN CategoryHit
   \   0CA3  EC                MOV     A,R4
   \   0CA4  600B              JZ      ?0276
   \   0CA6            ?0275:
    729                      SendStringEOLRS232("Category Hit");
   \   0CA6  7DB4              MOV     R5,#LOW(?0277)
   \   0CA8  7E03              MOV     R6,#HIGH(?0277)
   \   0CAA  7F02              MOV     R7,#2
   \   0CAC  120000            LCALL   $REFFN SendStringEOLRS232
    730                  } else {
   \   0CAF  8009              SJMP    ?0278
   \   0CB1            ?0276:
    731                      SendStringEOLRS232("Category Miss");
   \   0CB1  7DC1              MOV     R5,#LOW(?0279)
   \   0CB3  7E03              MOV     R6,#HIGH(?0279)
   \   0CB5  7F02              MOV     R7,#2
   \   0CB7  120000            LCALL   $REFFN SendStringEOLRS232
   \   0CBA            ?0278:
   \   0CBA  020D4C            LJMP    ?0280
   \   0CBD            ?0273:
    732                  }
    733              } else if (!myStrCmpNoCase(commandLine[0], CM_PLAYMEMO)) {
   \   0CBD  7F02              MOV     R7,#2
   \   0CBF  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0CC2  EF                MOV     A,R7
   \   0CC3  F0                MOVX    @DPTR,A
   \   0CC4  A3                INC     DPTR
   \   0CC5  7403              MOV     A,#HIGH(?0283)
   \   0CC7  F0                MOVX    @DPTR,A
   \   0CC8  A3                INC     DPTR
   \   0CC9  74CF              MOV     A,#LOW(?0283)
   \   0CCB  F0                MOVX    @DPTR,A
   \   0CCC  7D00              MOV     R5,#LOW(commandLine)
   \   0CCE  7E00              MOV     R6,#HIGH(commandLine)
   \   0CD0  1F                DEC     R7
   \   0CD1  120000            LCALL   $REFFN myStrCmpNoCase
   \   0CD4  BC0005            CJNE    R4,#0,?0282
   \   0CD7            ?0281:
    734                  PlayMemo();
   \   0CD7  120000            LCALL   $REFFN PlayMemo
   \   0CDA  8070              SJMP    ?0284
   \   0CDC            ?0282:
    735              } else if (!myStrCmpNoCase(commandLine[0], CM_RECMEMO)) {
   \   0CDC  7F02              MOV     R7,#2
   \   0CDE  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0CE1  EF                MOV     A,R7
   \   0CE2  F0                MOVX    @DPTR,A
   \   0CE3  A3                INC     DPTR
   \   0CE4  7403              MOV     A,#HIGH(?0287)
   \   0CE6  F0                MOVX    @DPTR,A
   \   0CE7  A3                INC     DPTR
   \   0CE8  74D8              MOV     A,#LOW(?0287)
   \   0CEA  F0                MOVX    @DPTR,A
   \   0CEB  7D00              MOV     R5,#LOW(commandLine)
   \   0CED  7E00              MOV     R6,#HIGH(commandLine)
   \   0CEF  1F                DEC     R7
   \   0CF0  120000            LCALL   $REFFN myStrCmpNoCase
   \   0CF3  BC0005            CJNE    R4,#0,?0286
   \   0CF6            ?0285:
    736                 RecordMemo();
   \   0CF6  120000            LCALL   $REFFN RecordMemo
   \   0CF9  8051              SJMP    ?0288
   \   0CFB            ?0286:
    737              } else if (!myStrCmpNoCase(commandLine[0], CM_SETSIGNALS)) {
   \   0CFB  7F02              MOV     R7,#2
   \   0CFD  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0D00  EF                MOV     A,R7
   \   0D01  F0                MOVX    @DPTR,A
   \   0D02  A3                INC     DPTR
   \   0D03  7403              MOV     A,#HIGH(?0291)
   \   0D05  F0                MOVX    @DPTR,A
   \   0D06  A3                INC     DPTR
   \   0D07  74E0              MOV     A,#LOW(?0291)
   \   0D09  F0                MOVX    @DPTR,A
   \   0D0A  7D00              MOV     R5,#LOW(commandLine)
   \   0D0C  7E00              MOV     R6,#HIGH(commandLine)
   \   0D0E  1F                DEC     R7
   \   0D0F  120000            LCALL   $REFFN myStrCmpNoCase
   \   0D12  BC0033            CJNE    R4,#0,?0290
   \   0D15            ?0289:
    738                  i = myStr2Int(commandLine[1]);
   \   0D15  7D10              MOV     R5,#LOW(commandLine+16)
   \   0D17  7E00              MOV     R6,#HIGH(commandLine+16)
   \   0D19  7F01              MOV     R7,#1
   \   0D1B  120000            LCALL   $REFFN myStr2Int
    739                  if ((i>0) && (i<15)) {
   \   0D1E  900000            MOV     DPTR,#$LOCBX DecodeAndPerform
   \   0D21  ED                MOV     A,R5
   \   0D22  F0                MOVX    @DPTR,A
   \   0D23  A3                INC     DPTR
   \   0D24  EC                MOV     A,R4
   \   0D25  F0                MOVX    @DPTR,A
   \   0D26  D3                SETB    C
   \   0D27  9400              SUBB    A,#0
   \   0D29  ED                MOV     A,R5
   \   0D2A  6480              XRL     A,#128
   \   0D2C  9480              SUBB    A,#128
   \   0D2E  4016              JC      ?0293
   \   0D30  C3                CLR     C
   \   0D31  EC                MOV     A,R4
   \   0D32  940F              SUBB    A,#15
   \   0D34  ED                MOV     A,R5
   \   0D35  6480              XRL     A,#128
   \   0D37  9480              SUBB    A,#128
   \   0D39  500B              JNC     ?0293
   \   0D3B            ?0295:
   \   0D3B            ?0294:
   \   0D3B            ?0292:
    740                      numSignals = i;
   \   0D3B  EC                MOV     A,R4
    741                      WriteCalenderByte(NV_NUM_SIGNALS, numSignals);
   \   0D3C  900000            MOV     DPTR,#numSignals
   \   0D3F  F0                MOVX    @DPTR,A
   \   0D40  FD                MOV     R5,A
   \   0D41  7C09              MOV     R4,#9
   \   0D43  120000            LCALL   $REFFN WriteCalenderByte
   \   0D46            ?0293:
    742                  }
    743              } else {
   \   0D46  8004              SJMP    ?0296
   \   0D48            ?0290:
    744                  return 0;
   \   0D48  7C00              MOV     R4,#0
    745              }
   \   0D4A  8002              SJMP    ?0297
   \   0D4C            ?0296:
   \   0D4C            ?0288:
   \   0D4C            ?0284:
   \   0D4C            ?0280:
   \   0D4C            ?0271:
   \   0D4C            ?0265:
   \   0D4C            ?0261:
   \   0D4C            ?0257:
   \   0D4C            ?0253:
   \   0D4C            ?0249:
   \   0D4C            ?0244:
   \   0D4C            ?0240:
   \   0D4C            ?0236:
   \   0D4C            ?0231:
   \   0D4C            ?0226:
   \   0D4C            ?0219:
   \   0D4C            ?0215:
   \   0D4C            ?0211:
   \   0D4C            ?0207:
   \   0D4C            ?0203:
   \   0D4C            ?0199:
   \   0D4C            ?0190:
   \   0D4C            ?0182:
   \   0D4C            ?0170:
   \   0D4C            ?0156:
   \   0D4C            ?0152:
   \   0D4C            ?0147:
   \   0D4C            ?0143:
   \   0D4C            ?0139:
   \   0D4C            ?0135:
   \   0D4C            ?0131:
   \   0D4C            ?0127:
   \   0D4C            ?0123:
   \   0D4C            ?0119:
   \   0D4C            ?0115:
   \   0D4C            ?0111:
   \   0D4C            ?0107:
   \   0D4C            ?0103:
   \   0D4C            ?0099:
   \   0D4C            ?0095:
   \   0D4C            ?0091:
   \   0D4C            ?0087:
   \   0D4C            ?0083:
   \   0D4C            ?0079:
   \   0D4C            ?0075:
    746              return 1;
   \   0D4C  7C01              MOV     R4,#1
    747          }
   \   0D4E            ?0297:
   \   0D4E  900000            MOV     DPTR,#$LOCBX DecodeAndPerform+32
   \   0D51  E0                MOVX    A,@DPTR
   \   0D52  F8                MOV     R0,A
   \   0D53  A3                INC     DPTR
   \   0D54  E0                MOVX    A,@DPTR
   \   0D55  C0E0              PUSH    ACC
   \   0D57  E8                MOV     A,R0
   \   0D58  C0E0              PUSH    ACC
   \   0D5A  22                RET
    748          
    749          
    750          
    751          /**************************************************************************************
    752          Batfile (kommandofil) spec: 
    753          
    754          När en batfil har hittats och skall köras letas ett ledigt BatFileObj fram från BatFiles. 
    755          En BatFileObj är ledig om dess occupied-medlem = 0. BatFileObj fylls i med information om filen.
    756          currentBatFile sätts till det nya BatFileObj. Sedan hämtas en rad i filen i taget och körs 
    757          genom DecodeAndPerform. Rader som börjar med # skall inte skickas. Rader som börjar med : är 
    758          definitioner av lablar och skall inte skickas till DecodeAndPerform. 
    759          
    760          Om en rad börjar med : är det en label. Den skall läggas in i labelList. Den får bara läggas in 
    761          i listan om den inte lagts in tidigare. Om samma labelnamn definierats tidigare i bat filen skall
    762          ett felmeddelande ges och batfilen avbrytas. Om samma label definition (samma rad) körs en gång 
    763          till pga ex en loop skall den ignoreras. Således skall en label läggas i listan om det är den första
    764          gången som den aktuella kommandoraden körs i batfilen. Om en label som skall definieras hittas i listan
    765          och dess filposition stämmer med den nuvarande skall labeldefinitionen ignoreras. Om filpositionen
    766          inte stämmer skall ett felmeddelande ges och exekveringen avbrytas.
    767          
    768          När en batfil är slut kollas dess caller-medlem. Om den är NULL avslutas exekveringen helt och 
    769          currentBatFile sätts till NULL. Annars sätts currentBatFile till caller och exekveringen forsätter med
    770          den gamla batfilen.
    771          
    772          
    773          BatFiles
    774          ========
    775          BatFileObj[MAX_BATFILES]    BatFiles    //Sammlar alla BatFileObj
    776          
    777          
    778          BatFileObj
    779          ==========
    780          FILE*               fp              //Filpekare till bat-filen
    781          Label[MAX_LABELS]   labels          //Lista med ingående labels
    782          char                labelIndex      //Pekar på nästa lediga label
    783          BatFileObj*         caller          //Den batfil som kallade på denna. Om användaren gav kommandot 
    784                                              //skall den inehålla NULL
    785          char                occupied        //1 om detta objekt används, 0 annars
    786           
    787          
    788          Label
    789          =====
    790          char                name[LABEL_LEN] //Här läggs en labels namn in
    791          long                pos             //filpositionen av raden efter labeln
    792          
    793          
    794          
    795          ********************************************************************************************/
    796          
    797          void    SetupBatFile( void )
    798          {
   \   0D5B            SetupBatFile:
    799              xdata int     i;
    800          
    801              batFilePtr = NULL;
   \   0D5B  9001E9            MOV     DPTR,#batFilePtr
   \   0D5E  E4                CLR     A
   \   0D5F  F0                MOVX    @DPTR,A
   \   0D60  A3                INC     DPTR
   \   0D61  F0                MOVX    @DPTR,A
   \   0D62  A3                INC     DPTR
   \   0D63  F0                MOVX    @DPTR,A
    802          
    803              for (i=0 ; i<MAX_LABELS ; i++) {
   \   0D64  900000            MOV     DPTR,#$LOCBX SetupBatFile
   \   0D67  F0                MOVX    @DPTR,A
   \   0D68  A3                INC     DPTR
   \   0D69  F0                MOVX    @DPTR,A
   \   0D6A            ?0299:
   \   0D6A  C3                CLR     C
   \   0D6B  900000            MOV     DPTR,#$LOCBX SetupBatFile+1
   \   0D6E  E0                MOVX    A,@DPTR
   \   0D6F  9440              SUBB    A,#64
   \   0D71  900000            MOV     DPTR,#$LOCBX SetupBatFile
   \   0D74  E0                MOVX    A,@DPTR
   \   0D75  6480              XRL     A,#128
   \   0D77  9480              SUBB    A,#128
   \   0D79  5028              JNC     ?0298
   \   0D7B            ?0300:
    804                  batLabelPos[i] = -1;
   \   0D7B  A3                INC     DPTR
   \   0D7C  E0                MOVX    A,@DPTR
   \   0D7D  25E0              ADD     A,ACC
   \   0D7F  25E0              ADD     A,ACC
   \   0D81  24EC              ADD     A,#LOW(batLabelPos)
   \   0D83  F582              MOV     DPL,A
   \   0D85  E4                CLR     A
   \   0D86  3403              ADDC    A,#HIGH(batLabelPos)
   \   0D88  F583              MOV     DPH,A
   \   0D8A  74FF              MOV     A,#255
   \   0D8C  F0                MOVX    @DPTR,A
   \   0D8D  A3                INC     DPTR
   \   0D8E  F0                MOVX    @DPTR,A
   \   0D8F  A3                INC     DPTR
   \   0D90  F0                MOVX    @DPTR,A
   \   0D91  A3                INC     DPTR
   \   0D92  F0                MOVX    @DPTR,A
   \   0D93  900000            MOV     DPTR,#$LOCBX SetupBatFile+1
   \   0D96  E0                MOVX    A,@DPTR
   \   0D97  04                INC     A
   \   0D98  F0                MOVX    @DPTR,A
   \   0D99  900000            MOV     DPTR,#$LOCBX SetupBatFile
   \   0D9C  7003              JNZ     ?0433
   \   0D9E  E0                MOVX    A,@DPTR
   \   0D9F  04                INC     A
   \   0DA0  F0                MOVX    @DPTR,A
   \   0DA1            ?0433:
    805              }
    806          
    807          // Nedan var ett försök till multipla bat-filer, kanske införs senare
    808           
    809          /*
    810              int     i;
    811              Label*  l;
    812              Label*  l2;
    813          //    int j;
    814              
    815              for (i=0 ; i<MAX_BATFILES ; i++) {
    816                  batFiles[i].fp = NULL;
    817                  batFiles[i].caller = NULL;
    818                  batFiles[i].occupied = 0;
    819              }
    820              for (i=0 ; i<MAX_LABELS ; i++) {
    821                  labelList0[i].name[0] = 0;
    822                  labelList0[i].pos = -1;
    823                  labelList1[i].name[0] = 0;
    824                  labelList1[i].pos = -1;
    825                  labelList2[i].name[0] = 0;
    826                  labelList2[i].pos = -1;
    827                  labelList3[i].name[0] = 0;
    828                  labelList3[i].pos = -1;
    829                  labelList4[i].name[0] = 0;
    830                  labelList4[i].pos = -1;
    831                  labelList5[i].name[0] = 0;
    832                  labelList5[i].pos = -1;
    833                  labelList6[i].name[0] = 0;
    834                  labelList6[i].pos = -1;
    835                  labelList7[i].name[0] = 0;
    836                  labelList7[i].pos = -1;
    837              }
    838              batFiles[0].labels = labelList0;
    839              batFiles[1].labels = labelList1;
    840              batFiles[2].labels = labelList2;
    841              batFiles[3].labels = labelList3;
    842              batFiles[4].labels = labelList4;
    843              batFiles[5].labels = labelList5;
    844              batFiles[6].labels = labelList6;
    845              batFiles[7].labels = labelList7;
    846              
    847              l = batFiles[1].labels;
    848              
    849              for (i=0 ; i<MAX_LABELS ; i++) {
    850                  if (labelList1[i].pos == -1) {
    851                      SendStringEOLRS232("labelList == -1");
    852                  } else {
    853                      SendStringEOLRS232("labelList != -1");
    854                  }
    855          //        l2 = &l[i];
    856                  l2 = labelList1;
    857                  if (l->pos == -1) {
    858                      SendStringEOLRS232("batFiles[1] == -1");
    859                  } else {
    860                      SendStringEOLRS232("batFiles[1] != -1");
    861                  }
    862              }
    863          */    
    864          }
   \   0DA1  80C7              SJMP    ?0299
   \   0DA3            ?0298:
   \   0DA3  22                RET
    865          
    866          void    ClearLabelList( void )
    867          {
   \   0DA4            ClearLabelList:
    868              xdata int    i;
    869          
    870              for (i=0 ; i<MAX_LABELS ; i++) {
   \   0DA4  900000            MOV     DPTR,#$LOCBX ClearLabelList
   \   0DA7  E4                CLR     A
   \   0DA8  F0                MOVX    @DPTR,A
   \   0DA9  A3                INC     DPTR
   \   0DAA  F0                MOVX    @DPTR,A
   \   0DAB            ?0303:
   \   0DAB  C3                CLR     C
   \   0DAC  900000            MOV     DPTR,#$LOCBX ClearLabelList+1
   \   0DAF  E0                MOVX    A,@DPTR
   \   0DB0  9440              SUBB    A,#64
   \   0DB2  900000            MOV     DPTR,#$LOCBX ClearLabelList
   \   0DB5  E0                MOVX    A,@DPTR
   \   0DB6  6480              XRL     A,#128
   \   0DB8  9480              SUBB    A,#128
   \   0DBA  503C              JNC     ?0302
   \   0DBC            ?0304:
    871                  batLabelPos[i] = -1;
   \   0DBC  A3                INC     DPTR
   \   0DBD  E0                MOVX    A,@DPTR
   \   0DBE  25E0              ADD     A,ACC
   \   0DC0  25E0              ADD     A,ACC
   \   0DC2  24EC              ADD     A,#LOW(batLabelPos)
   \   0DC4  F582              MOV     DPL,A
   \   0DC6  E4                CLR     A
   \   0DC7  3403              ADDC    A,#HIGH(batLabelPos)
   \   0DC9  F583              MOV     DPH,A
   \   0DCB  74FF              MOV     A,#255
   \   0DCD  F0                MOVX    @DPTR,A
   \   0DCE  A3                INC     DPTR
   \   0DCF  F0                MOVX    @DPTR,A
   \   0DD0  A3                INC     DPTR
   \   0DD1  F0                MOVX    @DPTR,A
   \   0DD2  A3                INC     DPTR
   \   0DD3  F0                MOVX    @DPTR,A
    872                  batLabelName[0][i] = 0;     //var [i][0]
   \   0DD4  900000            MOV     DPTR,#$LOCBX ClearLabelList+1
   \   0DD7  E0                MOVX    A,@DPTR
   \   0DD8  24EC              ADD     A,#LOW(batLabelName)
   \   0DDA  FC                MOV     R4,A
   \   0DDB  900000            MOV     DPTR,#$LOCBX ClearLabelList
   \   0DDE  E0                MOVX    A,@DPTR
   \   0DDF  3401              ADDC    A,#HIGH(batLabelName)
   \   0DE1  FD                MOV     R5,A
   \   0DE2  E4                CLR     A
   \   0DE3  8C82              MOV     DPL,R4
   \   0DE5  8D83              MOV     DPH,R5
   \   0DE7  F0                MOVX    @DPTR,A
   \   0DE8  900000            MOV     DPTR,#$LOCBX ClearLabelList+1
   \   0DEB  E0                MOVX    A,@DPTR
   \   0DEC  04                INC     A
   \   0DED  F0                MOVX    @DPTR,A
   \   0DEE  900000            MOV     DPTR,#$LOCBX ClearLabelList
   \   0DF1  7003              JNZ     ?0434
   \   0DF3  E0                MOVX    A,@DPTR
   \   0DF4  04                INC     A
   \   0DF5  F0                MOVX    @DPTR,A
   \   0DF6            ?0434:
    873              }
    874          }
   \   0DF6  80B3              SJMP    ?0303
   \   0DF8            ?0302:
   \   0DF8  22                RET
    875          
    876          
    877          void    ExecuteBatFile(const char* batFileName)
    878          {
   \   0DF9            ExecuteBatFile:
   \   0DF9  900000            MOV     DPTR,#$LOCBX ExecuteBatFile+386
   \   0DFC  D0E0              POP     ACC
   \   0DFE  F0                MOVX    @DPTR,A
   \   0DFF  A3                INC     DPTR
   \   0E00  D0E0              POP     ACC
   \   0E02  F0                MOVX    @DPTR,A
    879              xdata char        batLine[CM_PARSIZE*CM_NRPAR];
    880              xdata int         i;
    881              
    882              if (batFilePtr = fopen(batFileName, "r")) {
   \   0E03  A3                INC     DPTR
   \   0E04  EF                MOV     A,R7
   \   0E05  F0                MOVX    @DPTR,A
   \   0E06  A3                INC     DPTR
   \   0E07  EE                MOV     A,R6
   \   0E08  F0                MOVX    @DPTR,A
   \   0E09  A3                INC     DPTR
   \   0E0A  ED                MOV     A,R5
   \   0E0B  F0                MOVX    @DPTR,A
   \   0E0C  7402              MOV     A,#2
   \   0E0E  900000            MOV     DPTR,#$PRMBX fopen+3
   \   0E11  F0                MOVX    @DPTR,A
   \   0E12  A3                INC     DPTR
   \   0E13  7401              MOV     A,#HIGH(?0052)
   \   0E15  F0                MOVX    @DPTR,A
   \   0E16  A3                INC     DPTR
   \   0E17  74C6              MOV     A,#LOW(?0052)
   \   0E19  F0                MOVX    @DPTR,A
   \   0E1A  120000            LCALL   $REFFN fopen
   \   0E1D  9001E9            MOV     DPTR,#batFilePtr
   \   0E20  EF                MOV     A,R7
   \   0E21  F0                MOVX    @DPTR,A
   \   0E22  A3                INC     DPTR
   \   0E23  EE                MOV     A,R6
   \   0E24  F0                MOVX    @DPTR,A
   \   0E25  A3                INC     DPTR
   \   0E26  ED                MOV     A,R5
   \   0E27  F0                MOVX    @DPTR,A
   \   0E28  4E                ORL     A,R6
   \   0E29  7003              JNZ     $+5
   \   0E2B  020F57            LJMP    ?0307
   \   0E2E            ?0306:
   \   0E2E            ?0309:
    883                  while (ftell(batFilePtr) < batFilePtr->length) {
   \   0E2E  9001E9            MOV     DPTR,#batFilePtr
   \   0E31  E0                MOVX    A,@DPTR
   \   0E32  FF                MOV     R7,A
   \   0E33  A3                INC     DPTR
   \   0E34  E0                MOVX    A,@DPTR
   \   0E35  FE                MOV     R6,A
   \   0E36  A3                INC     DPTR
   \   0E37  E0                MOVX    A,@DPTR
   \   0E38  FD                MOV     R5,A
   \   0E39  120000            LCALL   $REFFN ftell
   \   0E3C  9001E9            MOV     DPTR,#batFilePtr
   \   0E3F  E0                MOVX    A,@DPTR
   \   0E40  FB                MOV     R3,A
   \   0E41  A3                INC     DPTR
   \   0E42  E0                MOVX    A,@DPTR
   \   0E43  FA                MOV     R2,A
   \   0E44  A3                INC     DPTR
   \   0E45  E0                MOVX    A,@DPTR
   \   0E46  F9                MOV     R1,A
   \   0E47  EF                MOV     A,R7
   \   0E48  C0E0              PUSH    ACC
   \   0E4A  EE                MOV     A,R6
   \   0E4B  C0E0              PUSH    ACC
   \   0E4D  ED                MOV     A,R5
   \   0E4E  C0E0              PUSH    ACC
   \   0E50  EC                MOV     A,R4
   \   0E51  C0E0              PUSH    ACC
   \   0E53  900011            MOV     DPTR,#17
   \   0E56  120000            LCALL   ?LD_R4567_R123_DISP_L17
   \   0E59  D0E0              POP     ACC
   \   0E5B  F8                MOV     R0,A
   \   0E5C  D0E0              POP     ACC
   \   0E5E  F9                MOV     R1,A
   \   0E5F  D0E0              POP     ACC
   \   0E61  FA                MOV     R2,A
   \   0E62  D0E0              POP     ACC
   \   0E64  FB                MOV     R3,A
   \   0E65  7407              MOV     A,#7
   \   0E67  120000            LCALL   ?L_CMP_L01
   \   0E6A  6003              JZ      $+5
   \   0E6C  020F34            LJMP    ?0308
   \   0E6F            ?0310:
    884          
    885                      for (i=0 ; i<CM_PARSIZE*CM_NRPAR ; i++) batLine[i] = 0;     //För att strtok skall fungera
   \   0E6F  900000            MOV     DPTR,#$LOCBX ExecuteBatFile
   \   0E72  7C80              MOV     R4,#128
   \   0E74  7D02              MOV     R5,#2
   \   0E76  E4                CLR     A
   \   0E77            ?0435:
   \   0E77  F0                MOVX    @DPTR,A
   \   0E78  A3                INC     DPTR
   \   0E79  DCFC              DJNZ    R4,?0435
   \   0E7B  DDFA              DJNZ    R5,?0435
   \   0E7D  7C80              MOV     R4,#128
   \   0E7F            ?0312:
   \   0E7F            ?0313:
   \   0E7F            ?0311:
    886          
    887                      fgetLine(batFilePtr, batLine, CM_PARSIZE*CM_NRPAR);
   \   0E7F  900000            MOV     DPTR,#$PRMBX fgetLine+6
   \   0E82  04                INC     A
   \   0E83  F0                MOVX    @DPTR,A
   \   0E84  A3                INC     DPTR
   \   0E85  03                RR      A
   \   0E86  F0                MOVX    @DPTR,A
   \   0E87  7401              MOV     A,#1
   \   0E89  900000            MOV     DPTR,#$PRMBX fgetLine+3
   \   0E8C  F0                MOVX    @DPTR,A
   \   0E8D  A3                INC     DPTR
   \   0E8E  7400              MOV     A,#HIGH $LOCBX ExecuteBatFile
   \   0E90  F0                MOVX    @DPTR,A
   \   0E91  A3                INC     DPTR
   \   0E92  7400              MOV     A,#LOW $LOCBX ExecuteBatFile
   \   0E94  F0                MOVX    @DPTR,A
   \   0E95  9001E9            MOV     DPTR,#batFilePtr
   \   0E98  E0                MOVX    A,@DPTR
   \   0E99  FF                MOV     R7,A
   \   0E9A  A3                INC     DPTR
   \   0E9B  E0                MOVX    A,@DPTR
   \   0E9C  FE                MOV     R6,A
   \   0E9D  A3                INC     DPTR
   \   0E9E  E0                MOVX    A,@DPTR
   \   0E9F  FD                MOV     R5,A
   \   0EA0  120000            LCALL   $REFFN fgetLine
    888                          SendStringEOLRS232(batLine);
   \   0EA3  7D00              MOV     R5,#LOW $LOCBX ExecuteBatFile
   \   0EA5  7E00              MOV     R6,#HIGH $LOCBX ExecuteBatFile
   \   0EA7  7F01              MOV     R7,#1
   \   0EA9  120000            LCALL   $REFFN SendStringEOLRS232
    889                      if (batLine[0] != '#') {
   \   0EAC  900000            MOV     DPTR,#$LOCBX ExecuteBatFile
   \   0EAF  E0                MOVX    A,@DPTR
   \   0EB0  6423              XRL     A,#35
   \   0EB2  607D              JZ      ?0316
   \   0EB4            ?0315:
    890                          if (batLine[0] == ':') {
   \   0EB4  900000            MOV     DPTR,#$LOCBX ExecuteBatFile
   \   0EB7  E0                MOVX    A,@DPTR
   \   0EB8  B43A1F            CJNE    A,#58,?0318
   \   0EBB            ?0317:
    891                              InsertLabel(batLine, ftell(batFilePtr));
   \   0EBB  9001E9            MOV     DPTR,#batFilePtr
   \   0EBE  E0                MOVX    A,@DPTR
   \   0EBF  FF                MOV     R7,A
   \   0EC0  A3                INC     DPTR
   \   0EC1  E0                MOVX    A,@DPTR
   \   0EC2  FE                MOV     R6,A
   \   0EC3  A3                INC     DPTR
   \   0EC4  E0                MOVX    A,@DPTR
   \   0EC5  FD                MOV     R5,A
   \   0EC6  120000            LCALL   $REFFN ftell
   \   0EC9  900000            MOV     DPTR,#$PRMBX InsertLabel+3
   \   0ECC  120000            LCALL   ?STO_R4567_DPTR_L20
   \   0ECF  7D00              MOV     R5,#LOW $LOCBX ExecuteBatFile
   \   0ED1  7E00              MOV     R6,#HIGH $LOCBX ExecuteBatFile
   \   0ED3  7F01              MOV     R7,#1
   \   0ED5  120000            LCALL   $REFFN InsertLabel
    892                          } else {
   \   0ED8  8015              SJMP    ?0319
   \   0EDA            ?0318:
    893                              if (!DecodeAndPerform(batLine)) {
   \   0EDA  7D00              MOV     R5,#LOW $LOCBX ExecuteBatFile
   \   0EDC  7E00              MOV     R6,#HIGH $LOCBX ExecuteBatFile
   \   0EDE  7F01              MOV     R7,#1
   \   0EE0  120000            LCALL   $REFFN DecodeAndPerform
   \   0EE3  BC0009            CJNE    R4,#0,?0321
   \   0EE6            ?0320:
    894                                  SendStringEOLRS232("BAT: Unrecognized command or BAT-file");
   \   0EE6  7DEB              MOV     R5,#LOW(?0322)
   \   0EE8  7E03              MOV     R6,#HIGH(?0322)
   \   0EEA  7F02              MOV     R7,#2
   \   0EEC  120000            LCALL   $REFFN SendStringEOLRS232
   \   0EEF            ?0321:
   \   0EEF            ?0319:
    895                              }
    896                          }
    897                          if (error) {
   \   0EEF  900182            MOV     DPTR,#error
   \   0EF2  E0                MOVX    A,@DPTR
   \   0EF3  FD                MOV     R5,A
   \   0EF4  A3                INC     DPTR
   \   0EF5  E0                MOVX    A,@DPTR
   \   0EF6  4D                ORL     A,R5
   \   0EF7  6038              JZ      ?0324
   \   0EF9            ?0323:
    898                              SendStringRS232("BAT: Error code: ");
   \   0EF9  7D11              MOV     R5,#LOW(?0325)
   \   0EFB  7E04              MOV     R6,#HIGH(?0325)
   \   0EFD  7F02              MOV     R7,#2
   \   0EFF  120000            LCALL   $REFFN SendStringRS232
    899                              myLong2HexStr(error, msg);
   \   0F02  7401              MOV     A,#1
   \   0F04  900000            MOV     DPTR,#$PRMBX myLong2HexStr+4
   \   0F07  F0                MOVX    @DPTR,A
   \   0F08  A3                INC     DPTR
   \   0F09  7401              MOV     A,#HIGH(msg)
   \   0F0B  F0                MOVX    @DPTR,A
   \   0F0C  A3                INC     DPTR
   \   0F0D  7484              MOV     A,#LOW(msg)
   \   0F0F  F0                MOVX    @DPTR,A
   \   0F10  900182            MOV     DPTR,#error
   \   0F13  E0                MOVX    A,@DPTR
   \   0F14  FD                MOV     R5,A
   \   0F15  A3                INC     DPTR
   \   0F16  E0                MOVX    A,@DPTR
   \   0F17  FC                MOV     R4,A
   \   0F18  ED                MOV     A,R5
   \   0F19  33                RLC     A
   \   0F1A  95E0              SUBB    A,ACC
   \   0F1C  FE                MOV     R6,A
   \   0F1D  FF                MOV     R7,A
   \   0F1E  120000            LCALL   $REFFN myLong2HexStr
    900                              SendStringEOLRS232(msg);
   \   0F21  7D84              MOV     R5,#LOW(msg)
   \   0F23  7E01              MOV     R6,#HIGH(msg)
   \   0F25  7F01              MOV     R7,#1
   \   0F27  120000            LCALL   $REFFN SendStringEOLRS232
    901                              error = 0;
   \   0F2A  900182            MOV     DPTR,#error
   \   0F2D  E4                CLR     A
   \   0F2E  F0                MOVX    @DPTR,A
   \   0F2F  A3                INC     DPTR
   \   0F30  F0                MOVX    @DPTR,A
   \   0F31            ?0324:
   \   0F31            ?0316:
   \   0F31  020E2E            LJMP    ?0309
   \   0F34            ?0308:
    902                          }
    903                      }
    904                  }
    905                  ClearLabelList();
   \   0F34  120000            LCALL   $REFFN ClearLabelList
    906                  fclose(batFilePtr);
   \   0F37  9001E9            MOV     DPTR,#batFilePtr
   \   0F3A  E0                MOVX    A,@DPTR
   \   0F3B  FF                MOV     R7,A
   \   0F3C  A3                INC     DPTR
   \   0F3D  E0                MOVX    A,@DPTR
   \   0F3E  FE                MOV     R6,A
   \   0F3F  A3                INC     DPTR
   \   0F40  E0                MOVX    A,@DPTR
   \   0F41  FD                MOV     R5,A
   \   0F42  120000            LCALL   $REFFN fclose
    907                  batFilePtr = NULL;
   \   0F45  9001E9            MOV     DPTR,#batFilePtr
   \   0F48  E4                CLR     A
   \   0F49  F0                MOVX    @DPTR,A
   \   0F4A  A3                INC     DPTR
   \   0F4B  F0                MOVX    @DPTR,A
   \   0F4C  A3                INC     DPTR
   \   0F4D  F0                MOVX    @DPTR,A
    908                  SendStringEOLRS232("BAT-file finished");
   \   0F4E  7D23              MOV     R5,#LOW(?0326)
   \   0F50  7E04              MOV     R6,#HIGH(?0326)
   \   0F52  7F02              MOV     R7,#2
   \   0F54  120000            LCALL   $REFFN SendStringEOLRS232
   \   0F57            ?0307:
    909              }
    910          }
   \   0F57  900000            MOV     DPTR,#$LOCBX ExecuteBatFile+386
   \   0F5A  E0                MOVX    A,@DPTR
   \   0F5B  F8                MOV     R0,A
   \   0F5C  A3                INC     DPTR
   \   0F5D  E0                MOVX    A,@DPTR
   \   0F5E  C0E0              PUSH    ACC
   \   0F60  E8                MOV     A,R0
   \   0F61  C0E0              PUSH    ACC
   \   0F63  22                RET
    911          
    912          
    913          char    InsertLabel(const char* name, long pos)
    914          //Retunerar 1 om det gick att lägga in labeln, 0 om det inte gick. error sätts om det inte gick.
    915          {
   \   0F64            InsertLabel:
   \   0F64  900000            MOV     DPTR,#$LOCBX InsertLabel+10
   \   0F67  D0E0              POP     ACC
   \   0F69  F0                MOVX    @DPTR,A
   \   0F6A  A3                INC     DPTR
   \   0F6B  D0E0              POP     ACC
   \   0F6D  F0                MOVX    @DPTR,A
    916              xdata int     i = 0;
    917          //    int     t;
    918              xdata char*   tmpStr; 
    919              xdata char    delim[5] = " \t:";
   \   0F6E  900000            MOV     DPTR,#$LOCBX InsertLabel+5
   \   0F71  7904              MOV     R1,#LOW(?0327)
   \   0F73  7A00              MOV     R2,#HIGH(?0327)
   \   0F75  7B05              MOV     R3,#5
   \   0F77  7801              MOV     R0,#1
   \   0F79  120000            LCALL   ?MOVE_LONG_CR12_DPTR_L17
    920              
    921              //Omforma name så att inledande ':' tas bort och raden klipps efter första ordet
    922              tmpStr = strtok(name, delim); 
   \   0F7C  900000            MOV     DPTR,#$LOCBX InsertLabel+12
   \   0F7F  EF                MOV     A,R7
   \   0F80  F0                MOVX    @DPTR,A
   \   0F81  A3                INC     DPTR
   \   0F82  EE                MOV     A,R6
   \   0F83  F0                MOVX    @DPTR,A
   \   0F84  A3                INC     DPTR
   \   0F85  ED                MOV     A,R5
   \   0F86  F0                MOVX    @DPTR,A
   \   0F87  7401              MOV     A,#1
   \   0F89  900000            MOV     DPTR,#$PRMBX strtok+3
   \   0F8C  F0                MOVX    @DPTR,A
   \   0F8D  A3                INC     DPTR
   \   0F8E  7400              MOV     A,#HIGH ($LOCBX InsertLabel+5)
   \   0F90  F0                MOVX    @DPTR,A
   \   0F91  A3                INC     DPTR
   \   0F92  7400              MOV     A,#LOW ($LOCBX InsertLabel+5)
   \   0F94  F0                MOVX    @DPTR,A
   \   0F95  120000            LCALL   $REFFN strtok
   \   0F98  900000            MOV     DPTR,#$LOCBX InsertLabel+2
   \   0F9B  EF                MOV     A,R7
   \   0F9C  F0                MOVX    @DPTR,A
   \   0F9D  A3                INC     DPTR
   \   0F9E  EE                MOV     A,R6
   \   0F9F  F0                MOVX    @DPTR,A
   \   0FA0  A3                INC     DPTR
   \   0FA1  ED                MOV     A,R5
   \   0FA2  F0                MOVX    @DPTR,A
   \   0FA3  900000            MOV     DPTR,#$LOCBX InsertLabel
   \   0FA6  E4                CLR     A
   \   0FA7  F0                MOVX    @DPTR,A
   \   0FA8  A3                INC     DPTR
   \   0FA9  F0                MOVX    @DPTR,A
   \   0FAA            ?0329:
    923          
    924              //Finns labeln redan?
    925              while ((i < MAX_LABELS) && (batLabelPos[i] != -1) && (myStrCmpNoCase(batLabelName[i], tmpStr))) {
   \   0FAA  C3                CLR     C
   \   0FAB  900000            MOV     DPTR,#$LOCBX InsertLabel+1
   \   0FAE  E0                MOVX    A,@DPTR
   \   0FAF  9440              SUBB    A,#64
   \   0FB1  900000            MOV     DPTR,#$LOCBX InsertLabel
   \   0FB4  E0                MOVX    A,@DPTR
   \   0FB5  6480              XRL     A,#128
   \   0FB7  9480              SUBB    A,#128
   \   0FB9  506A              JNC     ?0328
   \   0FBB  A3                INC     DPTR
   \   0FBC  E0                MOVX    A,@DPTR
   \   0FBD  25E0              ADD     A,ACC
   \   0FBF  25E0              ADD     A,ACC
   \   0FC1  24EC              ADD     A,#LOW(batLabelPos)
   \   0FC3  F582              MOV     DPL,A
   \   0FC5  E4                CLR     A
   \   0FC6  3403              ADDC    A,#HIGH(batLabelPos)
   \   0FC8  F583              MOV     DPH,A
   \   0FCA  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   0FCD  74FF              MOV     A,#255
   \   0FCF  F8                MOV     R0,A
   \   0FD0  F9                MOV     R1,A
   \   0FD1  FA                MOV     R2,A
   \   0FD2  FB                MOV     R3,A
   \   0FD3  7405              MOV     A,#5
   \   0FD5  120000            LCALL   ?L_CMP_L01
   \   0FD8  704B              JNZ     ?0328
   \   0FDA  900000            MOV     DPTR,#$LOCBX InsertLabel+2
   \   0FDD  E0                MOVX    A,@DPTR
   \   0FDE  FF                MOV     R7,A
   \   0FDF  A3                INC     DPTR
   \   0FE0  E0                MOVX    A,@DPTR
   \   0FE1  FE                MOV     R6,A
   \   0FE2  A3                INC     DPTR
   \   0FE3  E0                MOVX    A,@DPTR
   \   0FE4  FD                MOV     R5,A
   \   0FE5  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   0FE8  EF                MOV     A,R7
   \   0FE9  F0                MOVX    @DPTR,A
   \   0FEA  A3                INC     DPTR
   \   0FEB  EE                MOV     A,R6
   \   0FEC  F0                MOVX    @DPTR,A
   \   0FED  A3                INC     DPTR
   \   0FEE  ED                MOV     A,R5
   \   0FEF  F0                MOVX    @DPTR,A
   \   0FF0  900000            MOV     DPTR,#$LOCBX InsertLabel
   \   0FF3  E0                MOVX    A,@DPTR
   \   0FF4  FD                MOV     R5,A
   \   0FF5  A3                INC     DPTR
   \   0FF6  E0                MOVX    A,@DPTR
   \   0FF7  7C03              MOV     R4,#3
   \   0FF9            ?0436:
   \   0FF9  25E0              ADD     A,ACC
   \   0FFB  CD                XCH     A,R5
   \   0FFC  33                RLC     A
   \   0FFD  CD                XCH     A,R5
   \   0FFE  DCF9              DJNZ    R4,?0436
   \   1000  24EC              ADD     A,#LOW(batLabelName)
   \   1002  FC                MOV     R4,A
   \   1003  ED                MOV     A,R5
   \   1004  3401              ADDC    A,#HIGH(batLabelName)
   \   1006  FE                MOV     R6,A
   \   1007  EC                MOV     A,R4
   \   1008  FD                MOV     R5,A
   \   1009  7F01              MOV     R7,#1
   \   100B  120000            LCALL   $REFFN myStrCmpNoCase
   \   100E  EC                MOV     A,R4
   \   100F  6014              JZ      ?0328
   \   1011            ?0332:
   \   1011            ?0331:
   \   1011            ?0330:
    926          /*
    927                  SendStringRS232("Insertsearch for: ");
    928                  SendStringRS232(tmpStr);
    929                  sprintf(msg, ", at index: %d", i);
    930                  SendStringRS232(msg);
    931                  t = batLabelPos[i] & 0xFF;
    932                  sprintf(msg, ", has position: %d", t);
    933                  SendStringEOLRS232(msg);
    934          */
    935                  i++;
   \   1011  900000            MOV     DPTR,#$LOCBX InsertLabel+1
   \   1014  E0                MOVX    A,@DPTR
   \   1015  04                INC     A
   \   1016  F0                MOVX    @DPTR,A
   \   1017  900000            MOV     DPTR,#$LOCBX InsertLabel
   \   101A  7003              JNZ     ?0437
   \   101C  E0                MOVX    A,@DPTR
   \   101D  04                INC     A
   \   101E  F0                MOVX    @DPTR,A
   \   101F            ?0437:
    936                  WDT = 1;
   \   101F  D2AE              SETB    IE.6
    937                  SWDT = 1;
   \   1021  D2BE              SETB    IP.6
   \   1023  8085              SJMP    ?0329
   \   1025            ?0328:
    938              }
    939              if (i >= MAX_LABELS) {
   \   1025  C3                CLR     C
   \   1026  900000            MOV     DPTR,#$LOCBX InsertLabel+1
   \   1029  E0                MOVX    A,@DPTR
   \   102A  9440              SUBB    A,#64
   \   102C  900000            MOV     DPTR,#$LOCBX InsertLabel
   \   102F  E0                MOVX    A,@DPTR
   \   1030  6480              XRL     A,#128
   \   1032  9480              SUBB    A,#128
   \   1034  400E              JC      ?0334
   \   1036            ?0333:
    940                  //Den är inte definierad tidigare och det finns inte fler labelplatser
    941                  error = EM_TOOMANYLABELS;
   \   1036  900182            MOV     DPTR,#error
   \   1039  E4                CLR     A
   \   103A  F0                MOVX    @DPTR,A
   \   103B  A3                INC     DPTR
   \   103C  7422              MOV     A,#34
   \   103E  F0                MOVX    @DPTR,A
    942                  return 0;
   \   103F  7C00              MOV     R4,#0
    943              } else {
   \   1041  0210E5            LJMP    ?0339
   \   1044            ?0334:
    944                  if (batLabelPos[i] == -1) {
   \   1044  A3                INC     DPTR
   \   1045  E0                MOVX    A,@DPTR
   \   1046  25E0              ADD     A,ACC
   \   1048  25E0              ADD     A,ACC
   \   104A  24EC              ADD     A,#LOW(batLabelPos)
   \   104C  F582              MOV     DPL,A
   \   104E  E4                CLR     A
   \   104F  3403              ADDC    A,#HIGH(batLabelPos)
   \   1051  F583              MOV     DPH,A
   \   1053  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   1056  74FF              MOV     A,#255
   \   1058  F8                MOV     R0,A
   \   1059  F9                MOV     R1,A
   \   105A  FA                MOV     R2,A
   \   105B  FB                MOV     R3,A
   \   105C  740D              MOV     A,#13
   \   105E  120000            LCALL   ?L_CMP_L01
   \   1061  7052              JNZ     ?0336
   \   1063            ?0335:
    945                      //Den är inte definierad tidigare, definier nu!
    946                      myStrCpy(batLabelName[i], tmpStr);
   \   1063  900000            MOV     DPTR,#$LOCBX InsertLabel+2
   \   1066  E0                MOVX    A,@DPTR
   \   1067  FF                MOV     R7,A
   \   1068  A3                INC     DPTR
   \   1069  E0                MOVX    A,@DPTR
   \   106A  FE                MOV     R6,A
   \   106B  A3                INC     DPTR
   \   106C  E0                MOVX    A,@DPTR
   \   106D  FD                MOV     R5,A
   \   106E  900000            MOV     DPTR,#$PRMBX myStrCpy+3
   \   1071  EF                MOV     A,R7
   \   1072  F0                MOVX    @DPTR,A
   \   1073  A3                INC     DPTR
   \   1074  EE                MOV     A,R6
   \   1075  F0                MOVX    @DPTR,A
   \   1076  A3                INC     DPTR
   \   1077  ED                MOV     A,R5
   \   1078  F0                MOVX    @DPTR,A
   \   1079  900000            MOV     DPTR,#$LOCBX InsertLabel
   \   107C  E0                MOVX    A,@DPTR
   \   107D  FD                MOV     R5,A
   \   107E  A3                INC     DPTR
   \   107F  E0                MOVX    A,@DPTR
   \   1080  7C03              MOV     R4,#3
   \   1082            ?0438:
   \   1082  25E0              ADD     A,ACC
   \   1084  CD                XCH     A,R5
   \   1085  33                RLC     A
   \   1086  CD                XCH     A,R5
   \   1087  DCF9              DJNZ    R4,?0438
   \   1089  24EC              ADD     A,#LOW(batLabelName)
   \   108B  FC                MOV     R4,A
   \   108C  ED                MOV     A,R5
   \   108D  3401              ADDC    A,#HIGH(batLabelName)
   \   108F  FE                MOV     R6,A
   \   1090  EC                MOV     A,R4
   \   1091  FD                MOV     R5,A
   \   1092  7F01              MOV     R7,#1
   \   1094  120000            LCALL   $REFFN myStrCpy
    947                      batLabelPos[i] = pos;
   \   1097  900000            MOV     DPTR,#$LOCBX InsertLabel+15
   \   109A  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   109D  900000            MOV     DPTR,#$LOCBX InsertLabel+1
   \   10A0  E0                MOVX    A,@DPTR
   \   10A1  25E0              ADD     A,ACC
   \   10A3  25E0              ADD     A,ACC
   \   10A5  24EC              ADD     A,#LOW(batLabelPos)
   \   10A7  F582              MOV     DPL,A
   \   10A9  E4                CLR     A
   \   10AA  3403              ADDC    A,#HIGH(batLabelPos)
   \   10AC  F583              MOV     DPH,A
   \   10AE  120000            LCALL   ?STO_R4567_DPTR_L20
    948          
    949          /*            SendStringRS232("Inserted label: ");
    950                      SendStringRS232(tmpStr);
    951                      sprintf(msg, ", at index: %d", i);
    952                      SendStringRS232(msg);
    953                      t = pos & 0xFF;
    954                      sprintf(msg, ", from position: %d", t);
    955                      SendStringEOLRS232(msg);
    956          */
    957                      return 1;
    958                  } else {
   \   10B1  7C01              MOV     R4,#1
   \   10B3  8030              SJMP    ?0339
   \   10B5            ?0336:
    959                      //Den är definierad tidigare, är det vid samma filposition (omdefiniering)?
    960                      if (batLabelPos[i] == pos) {
   \   10B5  900000            MOV     DPTR,#$LOCBX InsertLabel+1
   \   10B8  E0                MOVX    A,@DPTR
   \   10B9  25E0              ADD     A,ACC
   \   10BB  25E0              ADD     A,ACC
   \   10BD  24EC              ADD     A,#LOW(batLabelPos)
   \   10BF  F582              MOV     DPL,A
   \   10C1  E4                CLR     A
   \   10C2  3403              ADDC    A,#HIGH(batLabelPos)
   \   10C4  F583              MOV     DPH,A
   \   10C6  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   10C9  900000            MOV     DPTR,#$LOCBX InsertLabel+15
   \   10CC  120000            LCALL   ?LD_R0123_XDPTR_L20
   \   10CF  740D              MOV     A,#13
   \   10D1  120000            LCALL   ?L_CMP_L01
   \   10D4  7004              JNZ     ?0338
   \   10D6            ?0337:
    961                          //Detta är en omdefinition, ignorera
    962          /*
    963                          SendStringRS232("Redefinition OK: ");
    964                          SendStringEOLRS232(name);
    965          */
    966                          return 1;
   \   10D6  7C01              MOV     R4,#1
    967                      } else {
   \   10D8  800B              SJMP    ?0339
   \   10DA            ?0338:
    968                          //Labeln försöks definieras med nytt värde, ge felmeddelande
    969          /*
    970                          SendStringRS232("Redefinition error: ");
    971                          SendStringEOLRS232(name);
    972          */
    973                          error = EM_REDEFLABELATTEMPT;
   \   10DA  900182            MOV     DPTR,#error
   \   10DD  E4                CLR     A
   \   10DE  F0                MOVX    @DPTR,A
   \   10DF  A3                INC     DPTR
   \   10E0  7421              MOV     A,#33
   \   10E2  F0                MOVX    @DPTR,A
    974                          return 0;
   \   10E3  7C00              MOV     R4,#0
    975                      }
   \   10E5            ?0339:
    976                  }
    977              }
    978          }
   \   10E5  900000            MOV     DPTR,#$LOCBX InsertLabel+10
   \   10E8  E0                MOVX    A,@DPTR
   \   10E9  F8                MOV     R0,A
   \   10EA  A3                INC     DPTR
   \   10EB  E0                MOVX    A,@DPTR
   \   10EC  C0E0              PUSH    ACC
   \   10EE  E8                MOV     A,R0
   \   10EF  C0E0              PUSH    ACC
   \   10F1  22                RET
    979          
    980          int    FindLabel(const char *name)
    981          //Letar efter en label. Om den hittas retuneras dess index. Annars retuneras -1
    982          {
   \   10F2            FindLabel:
   \   10F2  900000            MOV     DPTR,#$LOCBX FindLabel+2
   \   10F5  D0E0              POP     ACC
   \   10F7  F0                MOVX    @DPTR,A
   \   10F8  A3                INC     DPTR
   \   10F9  D0E0              POP     ACC
   \   10FB  F0                MOVX    @DPTR,A
    983              xdata int     i = 0;
   \   10FC  900000            MOV     DPTR,#$LOCBX FindLabel
   \   10FF  E4                CLR     A
   \   1100  F0                MOVX    @DPTR,A
   \   1101  A3                INC     DPTR
   \   1102  F0                MOVX    @DPTR,A
   \   1103  900000            MOV     DPTR,#$LOCBX FindLabel+4
   \   1106  EF                MOV     A,R7
   \   1107  F0                MOVX    @DPTR,A
   \   1108  A3                INC     DPTR
   \   1109  EE                MOV     A,R6
   \   110A  F0                MOVX    @DPTR,A
   \   110B  A3                INC     DPTR
   \   110C  ED                MOV     A,R5
   \   110D  F0                MOVX    @DPTR,A
   \   110E            ?0341:
    984          //    int     t;
    985          
    986              while ((i < MAX_LABELS) && (batLabelPos[i] != -1) && (myStrCmpNoCase(batLabelName[i], name))) {
   \   110E  C3                CLR     C
   \   110F  900000            MOV     DPTR,#$LOCBX FindLabel+1
   \   1112  E0                MOVX    A,@DPTR
   \   1113  9440              SUBB    A,#64
   \   1115  900000            MOV     DPTR,#$LOCBX FindLabel
   \   1118  E0                MOVX    A,@DPTR
   \   1119  6480              XRL     A,#128
   \   111B  9480              SUBB    A,#128
   \   111D  506A              JNC     ?0340
   \   111F  A3                INC     DPTR
   \   1120  E0                MOVX    A,@DPTR
   \   1121  25E0              ADD     A,ACC
   \   1123  25E0              ADD     A,ACC
   \   1125  24EC              ADD     A,#LOW(batLabelPos)
   \   1127  F582              MOV     DPL,A
   \   1129  E4                CLR     A
   \   112A  3403              ADDC    A,#HIGH(batLabelPos)
   \   112C  F583              MOV     DPH,A
   \   112E  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   1131  74FF              MOV     A,#255
   \   1133  F8                MOV     R0,A
   \   1134  F9                MOV     R1,A
   \   1135  FA                MOV     R2,A
   \   1136  FB                MOV     R3,A
   \   1137  7405              MOV     A,#5
   \   1139  120000            LCALL   ?L_CMP_L01
   \   113C  704B              JNZ     ?0340
   \   113E  900000            MOV     DPTR,#$LOCBX FindLabel+4
   \   1141  E0                MOVX    A,@DPTR
   \   1142  FF                MOV     R7,A
   \   1143  A3                INC     DPTR
   \   1144  E0                MOVX    A,@DPTR
   \   1145  FE                MOV     R6,A
   \   1146  A3                INC     DPTR
   \   1147  E0                MOVX    A,@DPTR
   \   1148  FD                MOV     R5,A
   \   1149  900000            MOV     DPTR,#$PRMBX myStrCmpNoCase+3
   \   114C  EF                MOV     A,R7
   \   114D  F0                MOVX    @DPTR,A
   \   114E  A3                INC     DPTR
   \   114F  EE                MOV     A,R6
   \   1150  F0                MOVX    @DPTR,A
   \   1151  A3                INC     DPTR
   \   1152  ED                MOV     A,R5
   \   1153  F0                MOVX    @DPTR,A
   \   1154  900000            MOV     DPTR,#$LOCBX FindLabel
   \   1157  E0                MOVX    A,@DPTR
   \   1158  FD                MOV     R5,A
   \   1159  A3                INC     DPTR
   \   115A  E0                MOVX    A,@DPTR
   \   115B  7C03              MOV     R4,#3
   \   115D            ?0439:
   \   115D  25E0              ADD     A,ACC
   \   115F  CD                XCH     A,R5
   \   1160  33                RLC     A
   \   1161  CD                XCH     A,R5
   \   1162  DCF9              DJNZ    R4,?0439
   \   1164  24EC              ADD     A,#LOW(batLabelName)
   \   1166  FC                MOV     R4,A
   \   1167  ED                MOV     A,R5
   \   1168  3401              ADDC    A,#HIGH(batLabelName)
   \   116A  FE                MOV     R6,A
   \   116B  EC                MOV     A,R4
   \   116C  FD                MOV     R5,A
   \   116D  7F01              MOV     R7,#1
   \   116F  120000            LCALL   $REFFN myStrCmpNoCase
   \   1172  EC                MOV     A,R4
   \   1173  6014              JZ      ?0340
   \   1175            ?0344:
   \   1175            ?0343:
   \   1175            ?0342:
    987                  i++;
   \   1175  900000            MOV     DPTR,#$LOCBX FindLabel+1
   \   1178  E0                MOVX    A,@DPTR
   \   1179  04                INC     A
   \   117A  F0                MOVX    @DPTR,A
   \   117B  900000            MOV     DPTR,#$LOCBX FindLabel
   \   117E  7003              JNZ     ?0440
   \   1180  E0                MOVX    A,@DPTR
   \   1181  04                INC     A
   \   1182  F0                MOVX    @DPTR,A
   \   1183            ?0440:
    988                  WDT = 1;
   \   1183  D2AE              SETB    IE.6
    989                  SWDT = 1;
   \   1185  D2BE              SETB    IP.6
   \   1187  8085              SJMP    ?0341
   \   1189            ?0340:
    990              }
    991              if ((i >= MAX_LABELS) || (batLabelPos[i] == -1)) {
   \   1189  C3                CLR     C
   \   118A  900000            MOV     DPTR,#$LOCBX FindLabel+1
   \   118D  E0                MOVX    A,@DPTR
   \   118E  9440              SUBB    A,#64
   \   1190  900000            MOV     DPTR,#$LOCBX FindLabel
   \   1193  E0                MOVX    A,@DPTR
   \   1194  6480              XRL     A,#128
   \   1196  9480              SUBB    A,#128
   \   1198  501F              JNC     ?0345
   \   119A  A3                INC     DPTR
   \   119B  E0                MOVX    A,@DPTR
   \   119C  25E0              ADD     A,ACC
   \   119E  25E0              ADD     A,ACC
   \   11A0  24EC              ADD     A,#LOW(batLabelPos)
   \   11A2  F582              MOV     DPL,A
   \   11A4  E4                CLR     A
   \   11A5  3403              ADDC    A,#HIGH(batLabelPos)
   \   11A7  F583              MOV     DPH,A
   \   11A9  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   11AC  74FF              MOV     A,#255
   \   11AE  F8                MOV     R0,A
   \   11AF  F9                MOV     R1,A
   \   11B0  FA                MOV     R2,A
   \   11B1  FB                MOV     R3,A
   \   11B2  740D              MOV     A,#13
   \   11B4  120000            LCALL   ?L_CMP_L01
   \   11B7  7006              JNZ     ?0346
   \   11B9            ?0347:
   \   11B9            ?0348:
   \   11B9            ?0345:
    992                  //Labeln hittades inte
    993          
    994          //        SendStringRS232("Could not find label: ");
    995          //        SendStringEOLRS232(name);
    996          
    997                  return -1;
   \   11B9  74FF              MOV     A,#255
   \   11BB  FC                MOV     R4,A
   \   11BC  FD                MOV     R5,A
    998              } else {
   \   11BD  8008              SJMP    ?0349
   \   11BF            ?0346:
    999          /*
   1000                  SendStringRS232("Found label: ");
   1001                  SendStringRS232(name);
   1002                  SendStringRS232(" at index: ");
   1003                  SendRS232(i + '0');
   1004                  SendStringRS232(" with pos: ");
   1005                  myLong2HexStr(batLabelPos[i], msg);
   1006                  SendStringEOLRS232(msg);
   1007                          
   1008                  
   1009                  sprintf(msg, ", at index: %d", i);
   1010                  SendStringRS232(msg);
   1011                  t = batLabelPos[i] & 0xFF;
   1012                  sprintf(msg, ", from position: %d", t);
   1013                  SendStringEOLRS232(msg);
   1014          */
   1015                  return i;
   \   11BF  900000            MOV     DPTR,#$LOCBX FindLabel
   \   11C2  E0                MOVX    A,@DPTR
   \   11C3  FD                MOV     R5,A
   \   11C4  A3                INC     DPTR
   \   11C5  E0                MOVX    A,@DPTR
   \   11C6  FC                MOV     R4,A
   1016              }
   \   11C7            ?0349:
   1017          }
   \   11C7  900000            MOV     DPTR,#$LOCBX FindLabel+2
   \   11CA  E0                MOVX    A,@DPTR
   \   11CB  F8                MOV     R0,A
   \   11CC  A3                INC     DPTR
   \   11CD  E0                MOVX    A,@DPTR
   \   11CE  C0E0              PUSH    ACC
   \   11D0  E8                MOV     A,R0
   \   11D1  C0E0              PUSH    ACC
   \   11D3  22                RET
   1018          
   1019          
   1020          char    GotoLabel(const char* name)
   1021          //Hoppar till labeln name. Om den redan är definierad går den dit direkt. Är den inte definierad
   1022          //söks BAT-filen rad för rad efter den och stannar när den hittas. I båda dessa fall retuneras 1.
   1023          //Om labeln inte hittas retuneras 0
   1024          {       
   \   11D4            GotoLabel:
   \   11D4  900000            MOV     DPTR,#$LOCBX GotoLabel+387
   \   11D7  D0E0              POP     ACC
   \   11D9  F0                MOVX    @DPTR,A
   \   11DA  A3                INC     DPTR
   \   11DB  D0E0              POP     ACC
   \   11DD  F0                MOVX    @DPTR,A
   1025              xdata char    done;
   1026              xdata char    batLine[CM_PARSIZE*CM_NRPAR];
   1027              xdata int     pos;
   1028           
   1029          //    SendStringRS232("Trying to find label...");
   1030          
   1031              //Finns labeln i listan?
   1032              if ((pos = FindLabel(name)) == -1 ) {
   \   11DE  A3                INC     DPTR
   \   11DF  EF                MOV     A,R7
   \   11E0  F0                MOVX    @DPTR,A
   \   11E1  A3                INC     DPTR
   \   11E2  EE                MOV     A,R6
   \   11E3  F0                MOVX    @DPTR,A
   \   11E4  A3                INC     DPTR
   \   11E5  ED                MOV     A,R5
   \   11E6  F0                MOVX    @DPTR,A
   \   11E7  120000            LCALL   $REFFN FindLabel
   \   11EA  900000            MOV     DPTR,#$LOCBX GotoLabel+385
   \   11ED  ED                MOV     A,R5
   \   11EE  F0                MOVX    @DPTR,A
   \   11EF  A3                INC     DPTR
   \   11F0  EC                MOV     A,R4
   \   11F1  F0                MOVX    @DPTR,A
   \   11F2  04                INC     A
   \   11F3  7002              JNZ     ?0441
   \   11F5  ED                MOV     A,R5
   \   11F6  04                INC     A
   \   11F7            ?0441:
   \   11F7  6003              JZ      $+5
   \   11F9  0212D9            LJMP    ?0351
   \   11FC            ?0350:
   1033          //          SendStringRS232("Searching for label...");
   1034                  //Nej, leta efter den
   1035                  done = 0;
   \   11FC  E4                CLR     A
   \   11FD  900000            MOV     DPTR,#$LOCBX GotoLabel
   \   1200  F0                MOVX    @DPTR,A
   \   1201            ?0353:
   1036                  while (!done) {
   \   1201  900000            MOV     DPTR,#$LOCBX GotoLabel
   \   1204  E0                MOVX    A,@DPTR
   \   1205  6003              JZ      $+5
   \   1207  0212D9            LJMP    ?0352
   \   120A            ?0354:
   1037                                  WDT = 1;
   \   120A  D2AE              SETB    IE.6
   1038                                  SWDT = 1;
   \   120C  D2BE              SETB    IP.6
   1039                      fgetLine(batFilePtr, batLine, CM_PARSIZE*CM_NRPAR);
   \   120E  900000            MOV     DPTR,#$PRMBX fgetLine+6
   \   1211  7401              MOV     A,#1
   \   1213  F0                MOVX    @DPTR,A
   \   1214  A3                INC     DPTR
   \   1215  03                RR      A
   \   1216  F0                MOVX    @DPTR,A
   \   1217  7401              MOV     A,#1
   \   1219  900000            MOV     DPTR,#$PRMBX fgetLine+3
   \   121C  F0                MOVX    @DPTR,A
   \   121D  A3                INC     DPTR
   \   121E  7400              MOV     A,#HIGH ($LOCBX GotoLabel+1)
   \   1220  F0                MOVX    @DPTR,A
   \   1221  A3                INC     DPTR
   \   1222  7400              MOV     A,#LOW ($LOCBX GotoLabel+1)
   \   1224  F0                MOVX    @DPTR,A
   \   1225  9001E9            MOV     DPTR,#batFilePtr
   \   1228  E0                MOVX    A,@DPTR
   \   1229  FF                MOV     R7,A
   \   122A  A3                INC     DPTR
   \   122B  E0                MOVX    A,@DPTR
   \   122C  FE                MOV     R6,A
   \   122D  A3                INC     DPTR
   \   122E  E0                MOVX    A,@DPTR
   \   122F  FD                MOV     R5,A
   \   1230  120000            LCALL   $REFFN fgetLine
   1040                      if (batLine[0] == ':') {
   \   1233  900000            MOV     DPTR,#$LOCBX GotoLabel+1
   \   1236  E0                MOVX    A,@DPTR
   \   1237  B43A51            CJNE    A,#58,?0356
   \   123A            ?0355:
   1041                          if (!InsertLabel(batLine, ftell(batFilePtr))) {
   \   123A  9001E9            MOV     DPTR,#batFilePtr
   \   123D  E0                MOVX    A,@DPTR
   \   123E  FF                MOV     R7,A
   \   123F  A3                INC     DPTR
   \   1240  E0                MOVX    A,@DPTR
   \   1241  FE                MOV     R6,A
   \   1242  A3                INC     DPTR
   \   1243  E0                MOVX    A,@DPTR
   \   1244  FD                MOV     R5,A
   \   1245  120000            LCALL   $REFFN ftell
   \   1248  900000            MOV     DPTR,#$PRMBX InsertLabel+3
   \   124B  120000            LCALL   ?STO_R4567_DPTR_L20
   \   124E  7D00              MOV     R5,#LOW ($LOCBX GotoLabel+1)
   \   1250  7E00              MOV     R6,#HIGH ($LOCBX GotoLabel+1)
   \   1252  7F01              MOV     R7,#1
   \   1254  120000            LCALL   $REFFN InsertLabel
   \   1257  BC000E            CJNE    R4,#0,?0358
   \   125A            ?0357:
   1042                              //Om det inte går att lägga in nya lablar kommer den sökta aldrig hittas
   1043                              error = EM_TOOMANYLABELS;
   \   125A  900182            MOV     DPTR,#error
   \   125D  E4                CLR     A
   \   125E  F0                MOVX    @DPTR,A
   \   125F  A3                INC     DPTR
   \   1260  7422              MOV     A,#34
   \   1262  F0                MOVX    @DPTR,A
   1044                              return 0;
   \   1263  7C00              MOV     R4,#0
   1045                          }
   \   1265  021304            LJMP    ?0363
   \   1268            ?0358:
   1046                          if ((pos = FindLabel(name)) != -1) {
   \   1268  900000            MOV     DPTR,#$LOCBX GotoLabel+389
   \   126B  E0                MOVX    A,@DPTR
   \   126C  FF                MOV     R7,A
   \   126D  A3                INC     DPTR
   \   126E  E0                MOVX    A,@DPTR
   \   126F  FE                MOV     R6,A
   \   1270  A3                INC     DPTR
   \   1271  E0                MOVX    A,@DPTR
   \   1272  FD                MOV     R5,A
   \   1273  120000            LCALL   $REFFN FindLabel
   \   1276  900000            MOV     DPTR,#$LOCBX GotoLabel+385
   \   1279  ED                MOV     A,R5
   \   127A  F0                MOVX    @DPTR,A
   \   127B  A3                INC     DPTR
   \   127C  EC                MOV     A,R4
   \   127D  F0                MOVX    @DPTR,A
   \   127E  04                INC     A
   \   127F  7004              JNZ     ?0442
   \   1281  ED                MOV     A,R5
   \   1282  04                INC     A
   \   1283  6006              JZ      ?0360
   \   1285            ?0442:
   \   1285            ?0359:
   1047                              done = 1;
   \   1285  7401              MOV     A,#1
   \   1287  900000            MOV     DPTR,#$LOCBX GotoLabel
   \   128A  F0                MOVX    @DPTR,A
   \   128B            ?0360:
   \   128B            ?0356:
   1048                          }
   1049                      }
   1050                      if (ftell(batFilePtr) >= batFilePtr->length) {
   \   128B  9001E9            MOV     DPTR,#batFilePtr
   \   128E  E0                MOVX    A,@DPTR
   \   128F  FF                MOV     R7,A
   \   1290  A3                INC     DPTR
   \   1291  E0                MOVX    A,@DPTR
   \   1292  FE                MOV     R6,A
   \   1293  A3                INC     DPTR
   \   1294  E0                MOVX    A,@DPTR
   \   1295  FD                MOV     R5,A
   \   1296  120000            LCALL   $REFFN ftell
   \   1299  9001E9            MOV     DPTR,#batFilePtr
   \   129C  E0                MOVX    A,@DPTR
   \   129D  FB                MOV     R3,A
   \   129E  A3                INC     DPTR
   \   129F  E0                MOVX    A,@DPTR
   \   12A0  FA                MOV     R2,A
   \   12A1  A3                INC     DPTR
   \   12A2  E0                MOVX    A,@DPTR
   \   12A3  F9                MOV     R1,A
   \   12A4  EF                MOV     A,R7
   \   12A5  C0E0              PUSH    ACC
   \   12A7  EE                MOV     A,R6
   \   12A8  C0E0              PUSH    ACC
   \   12AA  ED                MOV     A,R5
   \   12AB  C0E0              PUSH    ACC
   \   12AD  EC                MOV     A,R4
   \   12AE  C0E0              PUSH    ACC
   \   12B0  900011            MOV     DPTR,#17
   \   12B3  120000            LCALL   ?LD_R4567_R123_DISP_L17
   \   12B6  D0E0              POP     ACC
   \   12B8  F8                MOV     R0,A
   \   12B9  D0E0              POP     ACC
   \   12BB  F9                MOV     R1,A
   \   12BC  D0E0              POP     ACC
   \   12BE  FA                MOV     R2,A
   \   12BF  D0E0              POP     ACC
   \   12C1  FB                MOV     R3,A
   \   12C2  740F              MOV     A,#15
   \   12C4  120000            LCALL   ?L_CMP_L01
   \   12C7  700D              JNZ     ?0362
   \   12C9            ?0361:
   1051                          //Slutet på filen har nåtts men labeln hittades inte
   1052                          error = EM_NOLABEL;
   \   12C9  900182            MOV     DPTR,#error
   \   12CC  E4                CLR     A
   \   12CD  F0                MOVX    @DPTR,A
   \   12CE  A3                INC     DPTR
   \   12CF  7423              MOV     A,#35
   \   12D1  F0                MOVX    @DPTR,A
   1053                          return 0;
   \   12D2  7C00              MOV     R4,#0
   1054                      }
   \   12D4  802E              SJMP    ?0363
   \   12D6            ?0362:
   1055                  }
   1056              }
   \   12D6  021201            LJMP    ?0353
   \   12D9            ?0352:
   \   12D9            ?0351:
   1057              //Om detta nås innehåller har labeln hittats
   1058              fSetPos(batFilePtr, batLabelPos[pos]);
   \   12D9  900000            MOV     DPTR,#$LOCBX GotoLabel+386
   \   12DC  E0                MOVX    A,@DPTR
   \   12DD  25E0              ADD     A,ACC
   \   12DF  25E0              ADD     A,ACC
   \   12E1  24EC              ADD     A,#LOW(batLabelPos)
   \   12E3  F582              MOV     DPL,A
   \   12E5  E4                CLR     A
   \   12E6  3403              ADDC    A,#HIGH(batLabelPos)
   \   12E8  F583              MOV     DPH,A
   \   12EA  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   12ED  EC                MOV     A,R4
   \   12EE  900000            MOV     DPTR,#$PRMBX fSetPos+3
   \   12F1  120000            LCALL   ?STO_R4567_DPTR_L20
   \   12F4  9001E9            MOV     DPTR,#batFilePtr
   \   12F7  E0                MOVX    A,@DPTR
   \   12F8  FF                MOV     R7,A
   \   12F9  A3                INC     DPTR
   \   12FA  E0                MOVX    A,@DPTR
   \   12FB  FE                MOV     R6,A
   \   12FC  A3                INC     DPTR
   \   12FD  E0                MOVX    A,@DPTR
   \   12FE  FD                MOV     R5,A
   \   12FF  120000            LCALL   $REFFN fSetPos
   1059          //    SendStringRS232("Jumped to: ");
   1060          //    SendStringEOLRS232(name);
   1061          //    myLong2HexStr(batLabelPos[pos], msg);
   1062          //    SendStringEOLRS232(msg);
   1063              
   1064              return 1;
   1065              
   \   1302  7C01              MOV     R4,#1
   1066          }
   \   1304            ?0363:
   \   1304  900000            MOV     DPTR,#$LOCBX GotoLabel+387
   \   1307  E0                MOVX    A,@DPTR
   \   1308  F8                MOV     R0,A
   \   1309  A3                INC     DPTR
   \   130A  E0                MOVX    A,@DPTR
   \   130B  C0E0              PUSH    ACC
   \   130D  E8                MOV     A,R0
   \   130E  C0E0              PUSH    ACC
   \   1310  22                RET
   1067          
   1068          
   1069          
   1070          // Nedan var ett försök till multipla bat-filer, kanske införs senare
   1071          /*
   1072          BatFileObj*    VacantBatFileObj(FILE* fp)
   1073          //Letar i BatFiles efter ett BatFileObj vars occupied-medlem = 0. Om en hittas 
   1074          //fylls den i med filePtr = fp, labelIndex = 0, caller = currentBatFile, occupied = 1 och en
   1075          //pekare till den retuneras. Annars retuneras NULL.
   1076          {
   1077              int i = 0;
   1078          
   1079              while ((i < MAX_BATFILES) && (batFiles[i].occupied == 1)) {
   1080                  i++;
   1081              }
   1082              
   1083              if (i < MAX_BATFILES) {
   1084                  batFiles[i].fp = fp;
   1085                  batFiles[i].caller = currentBatFile;
   1086                  batFiles[i].occupied = 1;
   1087                  return &(batFiles[i]);
   1088              }
   1089              return NULL;
   1090          }
   1091          
   1092          void    ExecuteBatFile(const char* batFileName)
   1093          {
   1094              FILE*       bfp;
   1095              char        batLine[CM_PARSIZE*CM_NRPAR];
   1096              int         len;
   1097              BatFileObj* bfo;
   1098              
   1099              if (bfp = fopen(batFileName, "r")) {
   1100                  currentBatFile = VacantBatFileObj(bfp);
   1101                  while (currentBatFile) {
   1102                      while (ftell(currentBatFile->fp) < currentBatFile->fp->length) {
   1103                          fgetLine(currentBatFile->fp, batLine, CM_PARSIZE*CM_NRPAR);
   1104                          if (batLine[0] != '#') {
   1105                              if (batLine[0] == ':') {
   1106                                  if (!InsertLabel(batLine, ftell(currentBatFile->fp))) {
   1107                                      error = EM_TOOMANYLABELS;
   1108                                  }
   1109                              } else {
   1110                                  if (!DecodeAndPerform(batLine)) {
   1111                                      len = myStrLen(commandLine[0]);
   1112                                      commandLine[0][len++] = '.';
   1113                                      commandLine[0][len++] = 'B';
   1114                                      commandLine[0][len++] = 'A';
   1115                                      commandLine[0][len++] = 'T';
   1116                                      commandLine[0][len++] = 0x00;
   1117                                      if (bfp = fopen(commandLine[0], "r")) {
   1118                                          if (bfo = VacantBatFileObj(bfp)) {
   1119                                              currentBatFile = bfo;
   1120                                          } else {
   1121                                              error = EM_TOOMANYBATFILES;
   1122                                              fclose(bfp);
   1123                                          }
   1124                                      } else {
   1125                                          SendStringEOLRS232("BAT: Unrecognized command or BAT-file");
   1126                                          error = 0x00;
   1127                                      }
   1128                                  }
   1129                              }
   1130                          }
   1131                      }
   1132                      ClearLabelList(currentBatFile->labels);
   1133                      currentBatFile->occupied = 0;
   1134                      fclose(currentBatFile->fp);
   1135                      currentBatFile = currentBatFile->caller;
   1136                  }
   1137              }
   1138          }
   1139           
   1140          
   1141          char    InsertLabel(const char* name, long pos)
   1142          //Retunerar 1 om det gick att lägga in labeln, 0 om det inte gick. error sätts om det inte gick.
   1143          {
   1144              int     i = 0;
   1145              Label*  cl;
   1146              char*   tmpStr; 
   1147              char    delim[5] = " \t:";
   1148              
   1149          
   1150          
   1151              //Omforma name så att inledande ':' tas bort och raden klipps efter första ordet
   1152              tmpStr = strtok(name, delim); 
   1153          
   1154              cl = currentBatFile->labels;
   1155          
   1156              //Finns labeln redan?
   1157              while ((i < MAX_LABELS) && (cl[i].pos != -1) && (myStrCmpNoCase(cl[i].name, tmpStr))) {
   1158                  SendStringRS232("Insertsearch for: ");
   1159                  SendStringRS232(tmpStr);
   1160                  sprintf(msg, ", at index: %d", i);
   1161                  SendStringRS232(msg);
   1162                  sprintf(msg, ", has position: %d", cl[i].pos);
   1163                  SendStringEOLRS232(msg);
   1164                  i++;
   1165              }
   1166              if (i >= MAX_LABELS) {
   1167                  //Den är inte definierad tidigare och det finns inte fler labelplatser
   1168                  error = EM_TOOMANYLABELS;
   1169                  return 0;
   1170              } else {
   1171                  if (cl[i].pos == -1) {
   1172                      //Den är inte definierad tidigare, definier nu!
   1173                      myStrCpy(cl[i].name, tmpStr);
   1174                      cl[i].pos = pos;
   1175                      SendStringRS232("Inserted label: ");
   1176                      SendStringRS232(tmpStr);
   1177                      sprintf(msg, ", at index: %d", i);
   1178                      SendStringRS232(msg);
   1179                      sprintf(msg, ", from position: %d", pos);
   1180                      SendStringEOLRS232(msg);
   1181                      return 1;
   1182                  } else {
   1183                      //Den är definierad tidigare, är det vid samma filposition (omdefiniering)?
   1184                      if (cl[i].pos == pos) {
   1185                          //Detta är en omdefinition, ignorera
   1186                          return 1;
   1187                      } else {
   1188                          //Labeln försöks definieras med nytt värde, ge felmeddelande
   1189                          error = EM_REDEFLABELATTEMPT;
   1190                          return 0;
   1191                      }
   1192                  }
   1193              }
   1194          }
   1195           
   1196          char    FindLabel(const char *name, Label* l)
   1197          //Letar efter en label. Om den hittas sätts l att peka på den och 1 retuneras. Annars sätts
   1198          //l till NULL och 0 retuneras
   1199          {
   1200              int     i = 0;
   1201              Label*  cl = currentBatFile->labels;
   1202          
   1203              while ((i < MAX_LABELS) && (cl[i].pos != -1) && (myStrCmpNoCase(cl[i].name, name))) {
   1204                  i++;
   1205              }
   1206              if ((i >= MAX_LABELS) || (cl[i].pos == -1)) {
   1207                  //Labeln hittades inte
   1208                  l = NULL;
   1209                  return 0;
   1210              } else {
   1211                  SendStringRS232("Found label: ");
   1212                  SendStringRS232(name);
   1213                  sprintf(msg, ", at index: %d", i);
   1214                  SendStringRS232(msg);
   1215                  sprintf(msg, ", from position: %d", cl[i].pos);
   1216                  SendStringEOLRS232(msg);
   1217                  l = &(cl[i]);
   1218                  return 1;
   1219              }
   1220          }
   1221          
   1222          
   1223          char    GotoLabel(const char* name)
   1224          //Hoppar till labeln name. Om den redan är definierad går den dit direkt. Är den inte definierad
   1225          //söks BAT-filen rad för rad efter den och stannar när den hittas. I båda dessa fall retuneras 1.
   1226          //Om labeln inte hittas retuneras 0
   1227          {       
   1228              Label*  l;
   1229              char    done;
   1230              char    batLine[CM_PARSIZE*CM_NRPAR];
   1231           
   1232              //Finns labeln i listan?
   1233              if (!FindLabel(name, l)) {
   1234                  //Nej, leta efter den
   1235                  done = 0;
   1236                  l = NULL;
   1237                  while (!done) {
   1238                      fgetLine(currentBatFile->fp, batLine, CM_PARSIZE*CM_NRPAR);
   1239                      if (batLine[0] == ':') {
   1240                          if (!InsertLabel(batLine, ftell(currentBatFile->fp))) {
   1241                              //Om det inte går att lägga in nya lablar kommer den sökta aldrig hittas
   1242                              return 0;
   1243                          }
   1244                          if (FindLabel(name, l)) {
   1245                              done = 1;
   1246                          }
   1247                      }
   1248                      if (ftell(currentBatFile->fp) >= currentBatFile->fp->length) {
   1249                          //Slutet på filen har nåtts men labeln hittades inte
   1250                          return 0;
   1251                      }
   1252                  }
   1253              }
   1254              //Om detta nås innehåller l en pekare till den hittade labeln
   1255              fSetPos(currentBatFile->fp, l->pos);
   1256              return 1;
   1257              
   1258          }
   1259          */
   1260          
   1261          void    Hello( void )
   1262          {
   \   1311            Hello:
   \   1311  900000            MOV     DPTR,#$LOCBX Hello
   \   1314  D0E0              POP     ACC
   \   1316  F0                MOVX    @DPTR,A
   \   1317  A3                INC     DPTR
   \   1318  D0E0              POP     ACC
   \   131A  F0                MOVX    @DPTR,A
   1263          
   1264          //    TIME    t;
   1265          //    DATE    d;
   1266          
   1267          /*    
   1268              ClearScreen();
   1269              SetUpFrame();
   1270          
   1271              PosTo(1, 1);
   1272              Write("Goddag");
   1273              PosTo(2, 2);
   1274              Write("Hejsan");
   1275              PosTo(35, 3);
   1276              Write("Bruttonationalprodukt");
   1277              PosTo(35, 4);
   1278              WriteClip("Seglingssemester");
   1279              PosTo(2, 7);
   1280              WriteClip("PLAY       UP   DOWN    MENU   PLAY NEW");
   1281              ShowScreen();        
   1282                  
   1283          */    
   1284          /*
   1285              GetTimeNow(&t);
   1286              CreateTimeString(&t, msg);
   1287              SendStringEOLRS232(msg);
   1288              
   1289              GetDateNow(&d);
   1290              CreateDateString(&d, msg);
   1291              SendStringEOLRS232(msg);
   1292          */
   1293          /*
   1294              lastKey = 0;
   1295              KeyboardOn();
   1296           
   1297              while (!(S1CON & 0x01)) {
   1298                  WDT = 1;
   1299                  SWDT = 1;
   1300                  if (lastKey) { 
   1301                      SendRS232(lastKey + '0');
   1302                      lastKey = 0;
   1303                  }
   1304              }
   1305           
   1306              KeyboardOff();
   1307          */
   1308          /*
   1309              SendRS232('H');
   1310              WaitFor(20);
   1311              SendRS232('e');
   1312              WaitFor(20);
   1313              SendRS232('l');
   1314              WaitFor(20);
   1315              SendRS232('l');
   1316              WaitFor(20);
   1317              SendRS232('o');
   1318              WaitFor(20);
   1319          */
   1320              SendStringEOLRS232("Hello!");
   \   131B  7D35              MOV     R5,#LOW(?0364)
   \   131D  7E04              MOV     R6,#HIGH(?0364)
   \   131F  7F02              MOV     R7,#2
   \   1321  120000            LCALL   $REFFN SendStringEOLRS232
   1321          }
   \   1324  900000            MOV     DPTR,#$LOCBX Hello
   \   1327  E0                MOVX    A,@DPTR
   \   1328  F8                MOV     R0,A
   \   1329  A3                INC     DPTR
   \   132A  E0                MOVX    A,@DPTR
   \   132B  C0E0              PUSH    ACC
   \   132D  E8                MOV     A,R0
   \   132E  C0E0              PUSH    ACC
   \   1330  22                RET
   1322          
   1323          /*
   1324          
   1325          
   1326          #define CLE     P4.0
   1327          #define ALE     P4.1
   1328          #define WP      P4.2
   1329          #define SE      P4.3
   1330          #define CE      P4.4
   1331          #define FBUSY   P4.5
   1332          
   1333          #define FREG (*(unsigned char xdata *) 0xE000)
   1334          #define FLASH (*(unsigned char xdata *) 0xB000)
   1335          
   1336          
   1337          void    Erase( void )
   1338          {
   1339              for (eraseAddress = 10 ; eraseAddress < 0x800000 ; eraseAddress += 0x2000){
   1340                  FLASHKey = 0xAA;
   1341                  EraseBlock();
   1342              }
   1343          }
   1344          
   1345          */ 
   1346          
   1347          
   1348          void    myStrCpy(char* dest, const char* src)
   1349          {        
   \   1331            myStrCpy:
   1350              xdata int index = 0;
   \   1331  900000            MOV     DPTR,#$LOCBX myStrCpy
   \   1334  E4                CLR     A
   \   1335  F0                MOVX    @DPTR,A
   \   1336  A3                INC     DPTR
   \   1337  F0                MOVX    @DPTR,A
   \   1338  A3                INC     DPTR
   \   1339  EF                MOV     A,R7
   \   133A  F0                MOVX    @DPTR,A
   \   133B  A3                INC     DPTR
   \   133C  EE                MOV     A,R6
   \   133D  F0                MOVX    @DPTR,A
   \   133E  A3                INC     DPTR
   \   133F  ED                MOV     A,R5
   \   1340  F0                MOVX    @DPTR,A
   \   1341            ?0366:
   1351           
   1352              while (src[index] != 0) {
   \   1341  900000            MOV     DPTR,#$LOCBX myStrCpy+5
   \   1344  E0                MOVX    A,@DPTR
   \   1345  FF                MOV     R7,A
   \   1346  A3                INC     DPTR
   \   1347  E0                MOVX    A,@DPTR
   \   1348  FE                MOV     R6,A
   \   1349  A3                INC     DPTR
   \   134A  E0                MOVX    A,@DPTR
   \   134B  FD                MOV     R5,A
   \   134C  900000            MOV     DPTR,#$LOCBX myStrCpy
   \   134F  E0                MOVX    A,@DPTR
   \   1350  FC                MOV     R4,A
   \   1351  A3                INC     DPTR
   \   1352  E0                MOVX    A,@DPTR
   \   1353  F582              MOV     DPL,A
   \   1355  8C83              MOV     DPH,R4
   \   1357  120000            LCALL   ?LD_A_R567_DISP_L17
   \   135A  6038              JZ      ?0365
   \   135C            ?0367:
   1353                  dest[index] = src[index];
   \   135C  900000            MOV     DPTR,#$LOCBX myStrCpy
   \   135F  E0                MOVX    A,@DPTR
   \   1360  A3                INC     DPTR
   \   1361  E0                MOVX    A,@DPTR
   \   1362  F582              MOV     DPL,A
   \   1364  8C83              MOV     DPH,R4
   \   1366  120000            LCALL   ?LD_A_R567_DISP_L17
   \   1369  FC                MOV     R4,A
   \   136A  900000            MOV     DPTR,#$LOCBX myStrCpy+2
   \   136D  E0                MOVX    A,@DPTR
   \   136E  FF                MOV     R7,A
   \   136F  A3                INC     DPTR
   \   1370  E0                MOVX    A,@DPTR
   \   1371  FE                MOV     R6,A
   \   1372  A3                INC     DPTR
   \   1373  E0                MOVX    A,@DPTR
   \   1374  FD                MOV     R5,A
   \   1375  900000            MOV     DPTR,#$LOCBX myStrCpy
   \   1378  E0                MOVX    A,@DPTR
   \   1379  FB                MOV     R3,A
   \   137A  A3                INC     DPTR
   \   137B  E0                MOVX    A,@DPTR
   \   137C  F582              MOV     DPL,A
   \   137E  8B83              MOV     DPH,R3
   \   1380  EC                MOV     A,R4
   \   1381  120000            LCALL   ?ST_A_R567_DISP_L17
   1354                  index++;
   \   1384  900000            MOV     DPTR,#$LOCBX myStrCpy+1
   \   1387  E0                MOVX    A,@DPTR
   \   1388  04                INC     A
   \   1389  F0                MOVX    @DPTR,A
   \   138A  900000            MOV     DPTR,#$LOCBX myStrCpy
   \   138D  7003              JNZ     ?0443
   \   138F  E0                MOVX    A,@DPTR
   \   1390  04                INC     A
   \   1391  F0                MOVX    @DPTR,A
   \   1392            ?0443:
   \   1392  80AD              SJMP    ?0366
   \   1394            ?0365:
   1355              }
   1356              dest[index] = 0;
   \   1394  900000            MOV     DPTR,#$LOCBX myStrCpy+2
   \   1397  E0                MOVX    A,@DPTR
   \   1398  FF                MOV     R7,A
   \   1399  A3                INC     DPTR
   \   139A  E0                MOVX    A,@DPTR
   \   139B  FE                MOV     R6,A
   \   139C  A3                INC     DPTR
   \   139D  E0                MOVX    A,@DPTR
   \   139E  FD                MOV     R5,A
   \   139F  900000            MOV     DPTR,#$LOCBX myStrCpy
   \   13A2  E0                MOVX    A,@DPTR
   \   13A3  A3                INC     DPTR
   \   13A4  E0                MOVX    A,@DPTR
   \   13A5  F582              MOV     DPL,A
   \   13A7  8C83              MOV     DPH,R4
   \   13A9  E4                CLR     A
   \   13AA  020000            LJMP    ?ST_A_R567_DISP_L17
   1357          }
   1358          
   1359          int    myStrLen(char* str)
   1360          {
   \   13AD            myStrLen:
   1361              xdata int i = 0;
   \   13AD  900000            MOV     DPTR,#$LOCBX myStrLen
   \   13B0  E4                CLR     A
   \   13B1  F0                MOVX    @DPTR,A
   \   13B2  A3                INC     DPTR
   \   13B3  F0                MOVX    @DPTR,A
   \   13B4  A3                INC     DPTR
   \   13B5  EF                MOV     A,R7
   \   13B6  F0                MOVX    @DPTR,A
   \   13B7  A3                INC     DPTR
   \   13B8  EE                MOV     A,R6
   \   13B9  F0                MOVX    @DPTR,A
   \   13BA  A3                INC     DPTR
   \   13BB  ED                MOV     A,R5
   \   13BC  F0                MOVX    @DPTR,A
   \   13BD            ?0369:
   1362              
   1363              while(str[i] != 0) {
   \   13BD  900000            MOV     DPTR,#$LOCBX myStrLen+2
   \   13C0  E0                MOVX    A,@DPTR
   \   13C1  FF                MOV     R7,A
   \   13C2  A3                INC     DPTR
   \   13C3  E0                MOVX    A,@DPTR
   \   13C4  FE                MOV     R6,A
   \   13C5  A3                INC     DPTR
   \   13C6  E0                MOVX    A,@DPTR
   \   13C7  FD                MOV     R5,A
   \   13C8  900000            MOV     DPTR,#$LOCBX myStrLen
   \   13CB  E0                MOVX    A,@DPTR
   \   13CC  FC                MOV     R4,A
   \   13CD  A3                INC     DPTR
   \   13CE  E0                MOVX    A,@DPTR
   \   13CF  F582              MOV     DPL,A
   \   13D1  8C83              MOV     DPH,R4
   \   13D3  120000            LCALL   ?LD_A_R567_DISP_L17
   \   13D6  6010              JZ      ?0368
   \   13D8            ?0370:
   1364                  i++;
   \   13D8  900000            MOV     DPTR,#$LOCBX myStrLen+1
   \   13DB  E0                MOVX    A,@DPTR
   \   13DC  04                INC     A
   \   13DD  F0                MOVX    @DPTR,A
   \   13DE  900000            MOV     DPTR,#$LOCBX myStrLen
   \   13E1  7003              JNZ     ?0444
   \   13E3  E0                MOVX    A,@DPTR
   \   13E4  04                INC     A
   \   13E5  F0                MOVX    @DPTR,A
   \   13E6            ?0444:
   \   13E6  80D5              SJMP    ?0369
   \   13E8            ?0368:
   1365              }
   1366              
   1367              return i;
   \   13E8  900000            MOV     DPTR,#$LOCBX myStrLen
   \   13EB  E0                MOVX    A,@DPTR
   \   13EC  FD                MOV     R5,A
   \   13ED  A3                INC     DPTR
   \   13EE  E0                MOVX    A,@DPTR
   \   13EF  FC                MOV     R4,A
   1368          }
   \   13F0  22                RET
   1369          
   1370          /*
   1371          void    myToUpper(char* dest, const char* src)
   1372          {
   1373              int     index = 0;
   1374              
   1375              while (src[index]) {
   1376                  dest[index] = src[index] & 0xDF;
   1377                  index++;
   1378              }
   1379          }
   1380          */
   1381          
   1382          char    myStrCmpNoCase(const char* s1, const char* s2)
   1383          {
   \   13F1            myStrCmpNoCase:
   1384              xdata int     index = 0;
   \   13F1  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   13F4  E4                CLR     A
   \   13F5  F0                MOVX    @DPTR,A
   \   13F6  A3                INC     DPTR
   \   13F7  F0                MOVX    @DPTR,A
   \   13F8  A3                INC     DPTR
   \   13F9  EF                MOV     A,R7
   \   13FA  F0                MOVX    @DPTR,A
   \   13FB  A3                INC     DPTR
   \   13FC  EE                MOV     A,R6
   \   13FD  F0                MOVX    @DPTR,A
   \   13FE  A3                INC     DPTR
   \   13FF  ED                MOV     A,R5
   \   1400  F0                MOVX    @DPTR,A
   \   1401            ?0372:
   1385              
   1386              while ((s1[index]) && (s2[index])) {
   \   1401  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+2
   \   1404  E0                MOVX    A,@DPTR
   \   1405  FF                MOV     R7,A
   \   1406  A3                INC     DPTR
   \   1407  E0                MOVX    A,@DPTR
   \   1408  FE                MOV     R6,A
   \   1409  A3                INC     DPTR
   \   140A  E0                MOVX    A,@DPTR
   \   140B  FD                MOV     R5,A
   \   140C  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   140F  E0                MOVX    A,@DPTR
   \   1410  FC                MOV     R4,A
   \   1411  A3                INC     DPTR
   \   1412  E0                MOVX    A,@DPTR
   \   1413  F582              MOV     DPL,A
   \   1415  8C83              MOV     DPH,R4
   \   1417  120000            LCALL   ?LD_A_R567_DISP_L17
   \   141A  6067              JZ      ?0371
   \   141C  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+5
   \   141F  E0                MOVX    A,@DPTR
   \   1420  FF                MOV     R7,A
   \   1421  A3                INC     DPTR
   \   1422  E0                MOVX    A,@DPTR
   \   1423  FE                MOV     R6,A
   \   1424  A3                INC     DPTR
   \   1425  E0                MOVX    A,@DPTR
   \   1426  FD                MOV     R5,A
   \   1427  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   142A  E0                MOVX    A,@DPTR
   \   142B  A3                INC     DPTR
   \   142C  E0                MOVX    A,@DPTR
   \   142D  F582              MOV     DPL,A
   \   142F  8C83              MOV     DPH,R4
   \   1431  120000            LCALL   ?LD_A_R567_DISP_L17
   \   1434  604D              JZ      ?0371
   \   1436            ?0375:
   \   1436            ?0374:
   \   1436            ?0373:
   1387                  if ((s1[index] & 0xDF) != (s2[index] & 0xDF)) return 1;
   \   1436  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+2
   \   1439  E0                MOVX    A,@DPTR
   \   143A  FF                MOV     R7,A
   \   143B  A3                INC     DPTR
   \   143C  E0                MOVX    A,@DPTR
   \   143D  FE                MOV     R6,A
   \   143E  A3                INC     DPTR
   \   143F  E0                MOVX    A,@DPTR
   \   1440  FD                MOV     R5,A
   \   1441  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   1444  E0                MOVX    A,@DPTR
   \   1445  A3                INC     DPTR
   \   1446  E0                MOVX    A,@DPTR
   \   1447  F582              MOV     DPL,A
   \   1449  8C83              MOV     DPH,R4
   \   144B  120000            LCALL   ?LD_A_R567_DISP_L17
   \   144E  54DF              ANL     A,#223
   \   1450  FC                MOV     R4,A
   \   1451  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+5
   \   1454  E0                MOVX    A,@DPTR
   \   1455  FF                MOV     R7,A
   \   1456  A3                INC     DPTR
   \   1457  E0                MOVX    A,@DPTR
   \   1458  FE                MOV     R6,A
   \   1459  A3                INC     DPTR
   \   145A  E0                MOVX    A,@DPTR
   \   145B  FD                MOV     R5,A
   \   145C  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   145F  E0                MOVX    A,@DPTR
   \   1460  FB                MOV     R3,A
   \   1461  A3                INC     DPTR
   \   1462  E0                MOVX    A,@DPTR
   \   1463  F582              MOV     DPL,A
   \   1465  8B83              MOV     DPH,R3
   \   1467  120000            LCALL   ?LD_A_R567_DISP_L17
   \   146A  54DF              ANL     A,#223
   \   146C  6C                XRL     A,R4
   \   146D  6003              JZ      ?0377
   \   146F            ?0376:
   \   146F  7C01              MOV     R4,#1
   \   1471  22                RET
   \   1472            ?0377:
   1388                  index++;
   \   1472  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+1
   \   1475  E0                MOVX    A,@DPTR
   \   1476  04                INC     A
   \   1477  F0                MOVX    @DPTR,A
   \   1478  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   147B  7003              JNZ     ?0445
   \   147D  E0                MOVX    A,@DPTR
   \   147E  04                INC     A
   \   147F  F0                MOVX    @DPTR,A
   \   1480            ?0445:
   \   1480  021401            LJMP    ?0372
   \   1483            ?0371:
   1389              }
   1390          
   1391              if ((!s1[index]) && (!s2[index])) return 0;
   \   1483  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+2
   \   1486  E0                MOVX    A,@DPTR
   \   1487  FF                MOV     R7,A
   \   1488  A3                INC     DPTR
   \   1489  E0                MOVX    A,@DPTR
   \   148A  FE                MOV     R6,A
   \   148B  A3                INC     DPTR
   \   148C  E0                MOVX    A,@DPTR
   \   148D  FD                MOV     R5,A
   \   148E  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   1491  E0                MOVX    A,@DPTR
   \   1492  A3                INC     DPTR
   \   1493  E0                MOVX    A,@DPTR
   \   1494  F582              MOV     DPL,A
   \   1496  8C83              MOV     DPH,R4
   \   1498  120000            LCALL   ?LD_A_R567_DISP_L17
   \   149B  701D              JNZ     ?0379
   \   149D  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase+5
   \   14A0  E0                MOVX    A,@DPTR
   \   14A1  FF                MOV     R7,A
   \   14A2  A3                INC     DPTR
   \   14A3  E0                MOVX    A,@DPTR
   \   14A4  FE                MOV     R6,A
   \   14A5  A3                INC     DPTR
   \   14A6  E0                MOVX    A,@DPTR
   \   14A7  FD                MOV     R5,A
   \   14A8  900000            MOV     DPTR,#$LOCBX myStrCmpNoCase
   \   14AB  E0                MOVX    A,@DPTR
   \   14AC  A3                INC     DPTR
   \   14AD  E0                MOVX    A,@DPTR
   \   14AE  F582              MOV     DPL,A
   \   14B0  8C83              MOV     DPH,R4
   \   14B2  120000            LCALL   ?LD_A_R567_DISP_L17
   \   14B5  7003              JNZ     ?0379
   \   14B7            ?0381:
   \   14B7            ?0380:
   \   14B7            ?0378:
   \   14B7  7C00              MOV     R4,#0
   \   14B9  22                RET
   \   14BA            ?0379:
   1392              return 1;
   \   14BA  7C01              MOV     R4,#1
   1393          }
   \   14BC            ?0382:
   \   14BC  22                RET
   1394          
   1395          void    myLong2HexStr(long v, char* str)
   1396          {
   \   14BD            myLong2HexStr:
   1397              xdata char    i;
   1398              xdata int     tmp;
   1399              
   1400              i = 0;
   1401          
   1402              str[i++] = '0';
   \   14BD  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   14C0  E0                MOVX    A,@DPTR
   \   14C1  FB                MOV     R3,A
   \   14C2  A3                INC     DPTR
   \   14C3  E0                MOVX    A,@DPTR
   \   14C4  FA                MOV     R2,A
   \   14C5  A3                INC     DPTR
   \   14C6  E0                MOVX    A,@DPTR
   \   14C7  F9                MOV     R1,A
   \   14C8  7430              MOV     A,#48
   \   14CA  120000            LCALL   ?ST_A_R123_L17
   1403              str[i++] = 'x';
   \   14CD  7478              MOV     A,#120
   \   14CF  900001            MOV     DPTR,#1
   \   14D2  120000            LCALL   ?ST_A_R123_DISP_L17
   1404              tmp = (v >> 28) & 0xF;
   \   14D5  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   14D8  120000            LCALL   ?STO_R4567_DPTR_L20
   \   14DB  781C              MOV     R0,#28
   \   14DD  120000            LCALL   ?SL_SHR_L01
   \   14E0  EC                MOV     A,R4
   \   14E1  540F              ANL     A,#15
   \   14E3  7D00              MOV     R5,#0
   1405              if (tmp > 9) str[i++] = tmp + '7';
   \   14E5  FC                MOV     R4,A
   \   14E6  7402              MOV     A,#2
   \   14E8  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   14EB  F0                MOVX    @DPTR,A
   \   14EC  A3                INC     DPTR
   \   14ED  ED                MOV     A,R5
   \   14EE  F0                MOVX    @DPTR,A
   \   14EF  A3                INC     DPTR
   \   14F0  EC                MOV     A,R4
   \   14F1  F0                MOVX    @DPTR,A
   \   14F2  D3                SETB    C
   \   14F3  9409              SUBB    A,#9
   \   14F5  ED                MOV     A,R5
   \   14F6  6480              XRL     A,#128
   \   14F8  9480              SUBB    A,#128
   \   14FA  4021              JC      ?0384
   \   14FC            ?0383:
   \   14FC  EC                MOV     A,R4
   \   14FD  2437              ADD     A,#55
   \   14FF  FE                MOV     R6,A
   \   1500  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   1503  E0                MOVX    A,@DPTR
   \   1504  FB                MOV     R3,A
   \   1505  A3                INC     DPTR
   \   1506  E0                MOVX    A,@DPTR
   \   1507  FA                MOV     R2,A
   \   1508  A3                INC     DPTR
   \   1509  E0                MOVX    A,@DPTR
   \   150A  F9                MOV     R1,A
   \   150B  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   150E  E0                MOVX    A,@DPTR
   \   150F  FF                MOV     R7,A
   \   1510  04                INC     A
   \   1511  F0                MOVX    @DPTR,A
   \   1512  8F82              MOV     DPL,R7
   \   1514  758300            MOV     DPH,#0
   \   1517  EE                MOV     A,R6
   \   1518  120000            LCALL   ?ST_A_R123_DISP_L17
   \   151B  801F              SJMP    ?0385
   \   151D            ?0384:
   1406              else str[i++] = tmp + '0';
   \   151D  EC                MOV     A,R4
   \   151E  2430              ADD     A,#48
   \   1520  FE                MOV     R6,A
   \   1521  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   1524  E0                MOVX    A,@DPTR
   \   1525  FB                MOV     R3,A
   \   1526  A3                INC     DPTR
   \   1527  E0                MOVX    A,@DPTR
   \   1528  FA                MOV     R2,A
   \   1529  A3                INC     DPTR
   \   152A  E0                MOVX    A,@DPTR
   \   152B  F9                MOV     R1,A
   \   152C  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   152F  E0                MOVX    A,@DPTR
   \   1530  FF                MOV     R7,A
   \   1531  04                INC     A
   \   1532  F0                MOVX    @DPTR,A
   \   1533  8F82              MOV     DPL,R7
   \   1535  758300            MOV     DPH,#0
   \   1538  EE                MOV     A,R6
   \   1539  120000            LCALL   ?ST_A_R123_DISP_L17
   \   153C            ?0385:
   1407              tmp = (v >> 24) & 0xF;
   \   153C  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   153F  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   1542  7818              MOV     R0,#24
   \   1544  120000            LCALL   ?SL_SHR_L01
   \   1547  EC                MOV     A,R4
   \   1548  540F              ANL     A,#15
   \   154A  7D00              MOV     R5,#0
   1408              if (tmp > 9) str[i++] = tmp + '7';
   \   154C  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   154F  CD                XCH     A,R5
   \   1550  F0                MOVX    @DPTR,A
   \   1551  A3                INC     DPTR
   \   1552  CD                XCH     A,R5
   \   1553  F0                MOVX    @DPTR,A
   \   1554  D3                SETB    C
   \   1555  9409              SUBB    A,#9
   \   1557  ED                MOV     A,R5
   \   1558  6480              XRL     A,#128
   \   155A  9480              SUBB    A,#128
   \   155C  4021              JC      ?0387
   \   155E            ?0386:
   \   155E  E0                MOVX    A,@DPTR
   \   155F  2437              ADD     A,#55
   \   1561  FC                MOV     R4,A
   \   1562  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   1565  E0                MOVX    A,@DPTR
   \   1566  FF                MOV     R7,A
   \   1567  A3                INC     DPTR
   \   1568  E0                MOVX    A,@DPTR
   \   1569  FE                MOV     R6,A
   \   156A  A3                INC     DPTR
   \   156B  E0                MOVX    A,@DPTR
   \   156C  FD                MOV     R5,A
   \   156D  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   1570  E0                MOVX    A,@DPTR
   \   1571  FA                MOV     R2,A
   \   1572  04                INC     A
   \   1573  F0                MOVX    @DPTR,A
   \   1574  8A82              MOV     DPL,R2
   \   1576  758300            MOV     DPH,#0
   \   1579  EC                MOV     A,R4
   \   157A  120000            LCALL   ?ST_A_R567_DISP_L17
   \   157D  801F              SJMP    ?0388
   \   157F            ?0387:
   1409              else str[i++] = tmp + '0';
   \   157F  E0                MOVX    A,@DPTR
   \   1580  2430              ADD     A,#48
   \   1582  FC                MOV     R4,A
   \   1583  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   1586  E0                MOVX    A,@DPTR
   \   1587  FF                MOV     R7,A
   \   1588  A3                INC     DPTR
   \   1589  E0                MOVX    A,@DPTR
   \   158A  FE                MOV     R6,A
   \   158B  A3                INC     DPTR
   \   158C  E0                MOVX    A,@DPTR
   \   158D  FD                MOV     R5,A
   \   158E  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   1591  E0                MOVX    A,@DPTR
   \   1592  FA                MOV     R2,A
   \   1593  04                INC     A
   \   1594  F0                MOVX    @DPTR,A
   \   1595  8A82              MOV     DPL,R2
   \   1597  758300            MOV     DPH,#0
   \   159A  EC                MOV     A,R4
   \   159B  120000            LCALL   ?ST_A_R567_DISP_L17
   \   159E            ?0388:
   1410              tmp = (v >> 20) & 0xF;
   \   159E  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   15A1  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   15A4  7814              MOV     R0,#20
   \   15A6  120000            LCALL   ?SL_SHR_L01
   \   15A9  EC                MOV     A,R4
   \   15AA  540F              ANL     A,#15
   \   15AC  7D00              MOV     R5,#0
   1411              if (tmp > 9) str[i++] = tmp + '7';
   \   15AE  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   15B1  CD                XCH     A,R5
   \   15B2  F0                MOVX    @DPTR,A
   \   15B3  A3                INC     DPTR
   \   15B4  CD                XCH     A,R5
   \   15B5  F0                MOVX    @DPTR,A
   \   15B6  D3                SETB    C
   \   15B7  9409              SUBB    A,#9
   \   15B9  ED                MOV     A,R5
   \   15BA  6480              XRL     A,#128
   \   15BC  9480              SUBB    A,#128
   \   15BE  4021              JC      ?0390
   \   15C0            ?0389:
   \   15C0  E0                MOVX    A,@DPTR
   \   15C1  2437              ADD     A,#55
   \   15C3  FC                MOV     R4,A
   \   15C4  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   15C7  E0                MOVX    A,@DPTR
   \   15C8  FF                MOV     R7,A
   \   15C9  A3                INC     DPTR
   \   15CA  E0                MOVX    A,@DPTR
   \   15CB  FE                MOV     R6,A
   \   15CC  A3                INC     DPTR
   \   15CD  E0                MOVX    A,@DPTR
   \   15CE  FD                MOV     R5,A
   \   15CF  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   15D2  E0                MOVX    A,@DPTR
   \   15D3  FA                MOV     R2,A
   \   15D4  04                INC     A
   \   15D5  F0                MOVX    @DPTR,A
   \   15D6  8A82              MOV     DPL,R2
   \   15D8  758300            MOV     DPH,#0
   \   15DB  EC                MOV     A,R4
   \   15DC  120000            LCALL   ?ST_A_R567_DISP_L17
   \   15DF  801F              SJMP    ?0391
   \   15E1            ?0390:
   1412              else str[i++] = tmp + '0';
   \   15E1  E0                MOVX    A,@DPTR
   \   15E2  2430              ADD     A,#48
   \   15E4  FC                MOV     R4,A
   \   15E5  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   15E8  E0                MOVX    A,@DPTR
   \   15E9  FF                MOV     R7,A
   \   15EA  A3                INC     DPTR
   \   15EB  E0                MOVX    A,@DPTR
   \   15EC  FE                MOV     R6,A
   \   15ED  A3                INC     DPTR
   \   15EE  E0                MOVX    A,@DPTR
   \   15EF  FD                MOV     R5,A
   \   15F0  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   15F3  E0                MOVX    A,@DPTR
   \   15F4  FA                MOV     R2,A
   \   15F5  04                INC     A
   \   15F6  F0                MOVX    @DPTR,A
   \   15F7  8A82              MOV     DPL,R2
   \   15F9  758300            MOV     DPH,#0
   \   15FC  EC                MOV     A,R4
   \   15FD  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1600            ?0391:
   1413              tmp = (v >> 16) & 0xF;
   \   1600  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   1603  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   1606  7810              MOV     R0,#16
   \   1608  120000            LCALL   ?SL_SHR_L01
   \   160B  EC                MOV     A,R4
   \   160C  540F              ANL     A,#15
   \   160E  7D00              MOV     R5,#0
   1414              if (tmp > 9) str[i++] = tmp + '7';
   \   1610  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   1613  CD                XCH     A,R5
   \   1614  F0                MOVX    @DPTR,A
   \   1615  A3                INC     DPTR
   \   1616  CD                XCH     A,R5
   \   1617  F0                MOVX    @DPTR,A
   \   1618  D3                SETB    C
   \   1619  9409              SUBB    A,#9
   \   161B  ED                MOV     A,R5
   \   161C  6480              XRL     A,#128
   \   161E  9480              SUBB    A,#128
   \   1620  4021              JC      ?0393
   \   1622            ?0392:
   \   1622  E0                MOVX    A,@DPTR
   \   1623  2437              ADD     A,#55
   \   1625  FC                MOV     R4,A
   \   1626  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   1629  E0                MOVX    A,@DPTR
   \   162A  FF                MOV     R7,A
   \   162B  A3                INC     DPTR
   \   162C  E0                MOVX    A,@DPTR
   \   162D  FE                MOV     R6,A
   \   162E  A3                INC     DPTR
   \   162F  E0                MOVX    A,@DPTR
   \   1630  FD                MOV     R5,A
   \   1631  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   1634  E0                MOVX    A,@DPTR
   \   1635  FA                MOV     R2,A
   \   1636  04                INC     A
   \   1637  F0                MOVX    @DPTR,A
   \   1638  8A82              MOV     DPL,R2
   \   163A  758300            MOV     DPH,#0
   \   163D  EC                MOV     A,R4
   \   163E  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1641  801F              SJMP    ?0394
   \   1643            ?0393:
   1415              else str[i++] = tmp + '0';
   \   1643  E0                MOVX    A,@DPTR
   \   1644  2430              ADD     A,#48
   \   1646  FC                MOV     R4,A
   \   1647  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   164A  E0                MOVX    A,@DPTR
   \   164B  FF                MOV     R7,A
   \   164C  A3                INC     DPTR
   \   164D  E0                MOVX    A,@DPTR
   \   164E  FE                MOV     R6,A
   \   164F  A3                INC     DPTR
   \   1650  E0                MOVX    A,@DPTR
   \   1651  FD                MOV     R5,A
   \   1652  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   1655  E0                MOVX    A,@DPTR
   \   1656  FA                MOV     R2,A
   \   1657  04                INC     A
   \   1658  F0                MOVX    @DPTR,A
   \   1659  8A82              MOV     DPL,R2
   \   165B  758300            MOV     DPH,#0
   \   165E  EC                MOV     A,R4
   \   165F  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1662            ?0394:
   1416              tmp = (v >> 12) & 0xF;
   \   1662  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   1665  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   1668  780C              MOV     R0,#12
   \   166A  120000            LCALL   ?SL_SHR_L01
   \   166D  EC                MOV     A,R4
   \   166E  540F              ANL     A,#15
   \   1670  7D00              MOV     R5,#0
   1417              if (tmp > 9) str[i++] = tmp + '7';
   \   1672  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   1675  CD                XCH     A,R5
   \   1676  F0                MOVX    @DPTR,A
   \   1677  A3                INC     DPTR
   \   1678  CD                XCH     A,R5
   \   1679  F0                MOVX    @DPTR,A
   \   167A  D3                SETB    C
   \   167B  9409              SUBB    A,#9
   \   167D  ED                MOV     A,R5
   \   167E  6480              XRL     A,#128
   \   1680  9480              SUBB    A,#128
   \   1682  4021              JC      ?0396
   \   1684            ?0395:
   \   1684  E0                MOVX    A,@DPTR
   \   1685  2437              ADD     A,#55
   \   1687  FC                MOV     R4,A
   \   1688  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   168B  E0                MOVX    A,@DPTR
   \   168C  FF                MOV     R7,A
   \   168D  A3                INC     DPTR
   \   168E  E0                MOVX    A,@DPTR
   \   168F  FE                MOV     R6,A
   \   1690  A3                INC     DPTR
   \   1691  E0                MOVX    A,@DPTR
   \   1692  FD                MOV     R5,A
   \   1693  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   1696  E0                MOVX    A,@DPTR
   \   1697  FA                MOV     R2,A
   \   1698  04                INC     A
   \   1699  F0                MOVX    @DPTR,A
   \   169A  8A82              MOV     DPL,R2
   \   169C  758300            MOV     DPH,#0
   \   169F  EC                MOV     A,R4
   \   16A0  120000            LCALL   ?ST_A_R567_DISP_L17
   \   16A3  801F              SJMP    ?0397
   \   16A5            ?0396:
   1418              else str[i++] = tmp + '0';
   \   16A5  E0                MOVX    A,@DPTR
   \   16A6  2430              ADD     A,#48
   \   16A8  FC                MOV     R4,A
   \   16A9  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   16AC  E0                MOVX    A,@DPTR
   \   16AD  FF                MOV     R7,A
   \   16AE  A3                INC     DPTR
   \   16AF  E0                MOVX    A,@DPTR
   \   16B0  FE                MOV     R6,A
   \   16B1  A3                INC     DPTR
   \   16B2  E0                MOVX    A,@DPTR
   \   16B3  FD                MOV     R5,A
   \   16B4  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   16B7  E0                MOVX    A,@DPTR
   \   16B8  FA                MOV     R2,A
   \   16B9  04                INC     A
   \   16BA  F0                MOVX    @DPTR,A
   \   16BB  8A82              MOV     DPL,R2
   \   16BD  758300            MOV     DPH,#0
   \   16C0  EC                MOV     A,R4
   \   16C1  120000            LCALL   ?ST_A_R567_DISP_L17
   \   16C4            ?0397:
   1419              tmp = (v >> 8) & 0xF;
   \   16C4  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   16C7  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   16CA  7808              MOV     R0,#8
   \   16CC  120000            LCALL   ?SL_SHR_L01
   \   16CF  EC                MOV     A,R4
   \   16D0  540F              ANL     A,#15
   \   16D2  7D00              MOV     R5,#0
   1420              if (tmp > 9) str[i++] = tmp + '7';
   \   16D4  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   16D7  CD                XCH     A,R5
   \   16D8  F0                MOVX    @DPTR,A
   \   16D9  A3                INC     DPTR
   \   16DA  CD                XCH     A,R5
   \   16DB  F0                MOVX    @DPTR,A
   \   16DC  D3                SETB    C
   \   16DD  9409              SUBB    A,#9
   \   16DF  ED                MOV     A,R5
   \   16E0  6480              XRL     A,#128
   \   16E2  9480              SUBB    A,#128
   \   16E4  4021              JC      ?0399
   \   16E6            ?0398:
   \   16E6  E0                MOVX    A,@DPTR
   \   16E7  2437              ADD     A,#55
   \   16E9  FC                MOV     R4,A
   \   16EA  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   16ED  E0                MOVX    A,@DPTR
   \   16EE  FF                MOV     R7,A
   \   16EF  A3                INC     DPTR
   \   16F0  E0                MOVX    A,@DPTR
   \   16F1  FE                MOV     R6,A
   \   16F2  A3                INC     DPTR
   \   16F3  E0                MOVX    A,@DPTR
   \   16F4  FD                MOV     R5,A
   \   16F5  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   16F8  E0                MOVX    A,@DPTR
   \   16F9  FA                MOV     R2,A
   \   16FA  04                INC     A
   \   16FB  F0                MOVX    @DPTR,A
   \   16FC  8A82              MOV     DPL,R2
   \   16FE  758300            MOV     DPH,#0
   \   1701  EC                MOV     A,R4
   \   1702  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1705  801F              SJMP    ?0400
   \   1707            ?0399:
   1421              else str[i++] = tmp + '0';
   \   1707  E0                MOVX    A,@DPTR
   \   1708  2430              ADD     A,#48
   \   170A  FC                MOV     R4,A
   \   170B  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   170E  E0                MOVX    A,@DPTR
   \   170F  FF                MOV     R7,A
   \   1710  A3                INC     DPTR
   \   1711  E0                MOVX    A,@DPTR
   \   1712  FE                MOV     R6,A
   \   1713  A3                INC     DPTR
   \   1714  E0                MOVX    A,@DPTR
   \   1715  FD                MOV     R5,A
   \   1716  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   1719  E0                MOVX    A,@DPTR
   \   171A  FA                MOV     R2,A
   \   171B  04                INC     A
   \   171C  F0                MOVX    @DPTR,A
   \   171D  8A82              MOV     DPL,R2
   \   171F  758300            MOV     DPH,#0
   \   1722  EC                MOV     A,R4
   \   1723  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1726            ?0400:
   1422              tmp = (v >> 4) & 0xF;
   \   1726  900000            MOV     DPTR,#$LOCBX myLong2HexStr+3
   \   1729  120000            LCALL   ?LD_R4567_XDPTR_L20
   \   172C  7804              MOV     R0,#4
   \   172E  120000            LCALL   ?SL_SHR_L01
   \   1731  EC                MOV     A,R4
   \   1732  540F              ANL     A,#15
   \   1734  7D00              MOV     R5,#0
   1423              if (tmp > 9) str[i++] = tmp + '7';
   \   1736  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   1739  CD                XCH     A,R5
   \   173A  F0                MOVX    @DPTR,A
   \   173B  A3                INC     DPTR
   \   173C  CD                XCH     A,R5
   \   173D  F0                MOVX    @DPTR,A
   \   173E  D3                SETB    C
   \   173F  9409              SUBB    A,#9
   \   1741  ED                MOV     A,R5
   \   1742  6480              XRL     A,#128
   \   1744  9480              SUBB    A,#128
   \   1746  4021              JC      ?0402
   \   1748            ?0401:
   \   1748  E0                MOVX    A,@DPTR
   \   1749  2437              ADD     A,#55
   \   174B  FC                MOV     R4,A
   \   174C  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   174F  E0                MOVX    A,@DPTR
   \   1750  FF                MOV     R7,A
   \   1751  A3                INC     DPTR
   \   1752  E0                MOVX    A,@DPTR
   \   1753  FE                MOV     R6,A
   \   1754  A3                INC     DPTR
   \   1755  E0                MOVX    A,@DPTR
   \   1756  FD                MOV     R5,A
   \   1757  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   175A  E0                MOVX    A,@DPTR
   \   175B  FA                MOV     R2,A
   \   175C  04                INC     A
   \   175D  F0                MOVX    @DPTR,A
   \   175E  8A82              MOV     DPL,R2
   \   1760  758300            MOV     DPH,#0
   \   1763  EC                MOV     A,R4
   \   1764  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1767  801F              SJMP    ?0403
   \   1769            ?0402:
   1424              else str[i++] = tmp + '0';
   \   1769  E0                MOVX    A,@DPTR
   \   176A  2430              ADD     A,#48
   \   176C  FC                MOV     R4,A
   \   176D  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   1770  E0                MOVX    A,@DPTR
   \   1771  FF                MOV     R7,A
   \   1772  A3                INC     DPTR
   \   1773  E0                MOVX    A,@DPTR
   \   1774  FE                MOV     R6,A
   \   1775  A3                INC     DPTR
   \   1776  E0                MOVX    A,@DPTR
   \   1777  FD                MOV     R5,A
   \   1778  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   177B  E0                MOVX    A,@DPTR
   \   177C  FA                MOV     R2,A
   \   177D  04                INC     A
   \   177E  F0                MOVX    @DPTR,A
   \   177F  8A82              MOV     DPL,R2
   \   1781  758300            MOV     DPH,#0
   \   1784  EC                MOV     A,R4
   \   1785  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1788            ?0403:
   1425              tmp = v & 0xF;
   \   1788  900000            MOV     DPTR,#$LOCBX myLong2HexStr+6
   \   178B  E0                MOVX    A,@DPTR
   \   178C  540F              ANL     A,#15
   \   178E  7D00              MOV     R5,#0
   1426              if (tmp > 9) str[i++] = tmp + '7';
   \   1790  900000            MOV     DPTR,#$LOCBX myLong2HexStr+1
   \   1793  CD                XCH     A,R5
   \   1794  F0                MOVX    @DPTR,A
   \   1795  A3                INC     DPTR
   \   1796  CD                XCH     A,R5
   \   1797  F0                MOVX    @DPTR,A
   \   1798  D3                SETB    C
   \   1799  9409              SUBB    A,#9
   \   179B  ED                MOV     A,R5
   \   179C  6480              XRL     A,#128
   \   179E  9480              SUBB    A,#128
   \   17A0  401F              JC      ?0405
   \   17A2            ?0404:
   \   17A2  E0                MOVX    A,@DPTR
   \   17A3  2437              ADD     A,#55
   \   17A5  FC                MOV     R4,A
   \   17A6  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   17A9  E0                MOVX    A,@DPTR
   \   17AA  A3                INC     DPTR
   \   17AB  E0                MOVX    A,@DPTR
   \   17AC  A3                INC     DPTR
   \   17AD  E0                MOVX    A,@DPTR
   \   17AE  FD                MOV     R5,A
   \   17AF  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   17B2  E0                MOVX    A,@DPTR
   \   17B3  FA                MOV     R2,A
   \   17B4  04                INC     A
   \   17B5  F0                MOVX    @DPTR,A
   \   17B6  8A82              MOV     DPL,R2
   \   17B8  758300            MOV     DPH,#0
   \   17BB  EC                MOV     A,R4
   \   17BC  120000            LCALL   ?ST_A_R567_DISP_L17
   \   17BF  801D              SJMP    ?0406
   \   17C1            ?0405:
   1427              else str[i++] = tmp + '0';
   \   17C1  E0                MOVX    A,@DPTR
   \   17C2  2430              ADD     A,#48
   \   17C4  FC                MOV     R4,A
   \   17C5  900000            MOV     DPTR,#$LOCBX myLong2HexStr+7
   \   17C8  E0                MOVX    A,@DPTR
   \   17C9  A3                INC     DPTR
   \   17CA  E0                MOVX    A,@DPTR
   \   17CB  A3                INC     DPTR
   \   17CC  E0                MOVX    A,@DPTR
   \   17CD  FD                MOV     R5,A
   \   17CE  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   17D1  E0                MOVX    A,@DPTR
   \   17D2  FA                MOV     R2,A
   \   17D3  04                INC     A
   \   17D4  F0                MOVX    @DPTR,A
   \   17D5  8A82              MOV     DPL,R2
   \   17D7  758300            MOV     DPH,#0
   \   17DA  EC                MOV     A,R4
   \   17DB  120000            LCALL   ?ST_A_R567_DISP_L17
   \   17DE            ?0406:
   1428              str[i++] = 0;
   \   17DE  900000            MOV     DPTR,#$LOCBX myLong2HexStr
   \   17E1  E0                MOVX    A,@DPTR
   \   17E2  FC                MOV     R4,A
   \   17E3  04                INC     A
   \   17E4  F0                MOVX    @DPTR,A
   \   17E5  8C82              MOV     DPL,R4
   \   17E7  758300            MOV     DPH,#0
   \   17EA  E4                CLR     A
   \   17EB  020000            LJMP    ?ST_A_R567_DISP_L17
   1429          }
   1430           
   1431          void    myInt2DecStr(int v, char* str)
   1432          {
   \   17EE            myInt2DecStr:
   \   17EE  900000            MOV     DPTR,#$LOCBX myInt2DecStr+3
   \   17F1  D0E0              POP     ACC
   \   17F3  F0                MOVX    @DPTR,A
   \   17F4  A3                INC     DPTR
   \   17F5  D0E0              POP     ACC
   \   17F7  F0                MOVX    @DPTR,A
   1433              xdata char    i;
   1434              xdata char    tmp;
   1435              xdata char    vt;
   1436              
   1437              
   1438              i = 0;
   \   17F8  E4                CLR     A
   \   17F9  900000            MOV     DPTR,#$LOCBX myInt2DecStr
   \   17FC  F0                MOVX    @DPTR,A
   1439              if (v > 255) {
   \   17FD  900000            MOV     DPTR,#$LOCBX myInt2DecStr+5
   \   1800  ED                MOV     A,R5
   \   1801  F0                MOVX    @DPTR,A
   \   1802  A3                INC     DPTR
   \   1803  EC                MOV     A,R4
   \   1804  F0                MOVX    @DPTR,A
   \   1805  ED                MOV     A,R5
   \   1806  6480              XRL     A,#128
   \   1808  D3                SETB    C
   \   1809  9480              SUBB    A,#128
   \   180B  401F              JC      ?0408
   \   180D            ?0407:
   1440                  myStrCpy(str, "> 255");
   \   180D  7402              MOV     A,#2
   \   180F  900000            MOV     DPTR,#$PRMBX myStrCpy+3
   \   1812  F0                MOVX    @DPTR,A
   \   1813  A3                INC     DPTR
   \   1814  7404              MOV     A,#HIGH(?0409)
   \   1816  F0                MOVX    @DPTR,A
   \   1817  A3                INC     DPTR
   \   1818  743C              MOV     A,#LOW(?0409)
   \   181A  F0                MOVX    @DPTR,A
   \   181B  900000            MOV     DPTR,#$LOCBX myInt2DecStr+7
   \   181E  E0                MOVX    A,@DPTR
   \   181F  FF                MOV     R7,A
   \   1820  A3                INC     DPTR
   \   1821  E0                MOVX    A,@DPTR
   \   1822  FE                MOV     R6,A
   \   1823  A3                INC     DPTR
   \   1824  E0                MOVX    A,@DPTR
   \   1825  FD                MOV     R5,A
   \   1826  120000            LCALL   $REFFN myStrCpy
   \   1829  02192D            LJMP    ?0410
   \   182C            ?0408:
   1441              } else if (v < -255) {
   \   182C  C3                CLR     C
   \   182D  EC                MOV     A,R4
   \   182E  9401              SUBB    A,#1
   \   1830  ED                MOV     A,R5
   \   1831  6480              XRL     A,#128
   \   1833  947F              SUBB    A,#127
   \   1835  501F              JNC     ?0412
   \   1837            ?0411:
   1442                  myStrCpy(str, "< -255");
   \   1837  7402              MOV     A,#2
   \   1839  900000            MOV     DPTR,#$PRMBX myStrCpy+3
   \   183C  F0                MOVX    @DPTR,A
   \   183D  A3                INC     DPTR
   \   183E  7404              MOV     A,#HIGH(?0413)
   \   1840  F0                MOVX    @DPTR,A
   \   1841  A3                INC     DPTR
   \   1842  7442              MOV     A,#LOW(?0413)
   \   1844  F0                MOVX    @DPTR,A
   \   1845  900000            MOV     DPTR,#$LOCBX myInt2DecStr+7
   \   1848  E0                MOVX    A,@DPTR
   \   1849  FF                MOV     R7,A
   \   184A  A3                INC     DPTR
   \   184B  E0                MOVX    A,@DPTR
   \   184C  FE                MOV     R6,A
   \   184D  A3                INC     DPTR
   \   184E  E0                MOVX    A,@DPTR
   \   184F  FD                MOV     R5,A
   \   1850  120000            LCALL   $REFFN myStrCpy
   1443              } else {
   \   1853  02192D            LJMP    ?0414
   \   1856            ?0412:
   1444                  if (v < 0) {
   \   1856  ED                MOV     A,R5
   \   1857  33                RLC     A
   \   1858  5027              JNC     ?0416
   \   185A            ?0415:
   1445                      v = -v;
   \   185A  C3                CLR     C
   \   185B  E4                CLR     A
   \   185C  9C                SUBB    A,R4
   \   185D  FC                MOV     R4,A
   \   185E  E4                CLR     A
   \   185F  9D                SUBB    A,R5
   \   1860  900000            MOV     DPTR,#$LOCBX myInt2DecStr+5
   \   1863  F0                MOVX    @DPTR,A
   \   1864  A3                INC     DPTR
   \   1865  EC                MOV     A,R4
   \   1866  F0                MOVX    @DPTR,A
   1446                      str[i++] = '-';
   \   1867  A3                INC     DPTR
   \   1868  E0                MOVX    A,@DPTR
   \   1869  FF                MOV     R7,A
   \   186A  A3                INC     DPTR
   \   186B  E0                MOVX    A,@DPTR
   \   186C  FE                MOV     R6,A
   \   186D  A3                INC     DPTR
   \   186E  E0                MOVX    A,@DPTR
   \   186F  FD                MOV     R5,A
   \   1870  900000            MOV     DPTR,#$LOCBX myInt2DecStr
   \   1873  E0                MOVX    A,@DPTR
   \   1874  FC                MOV     R4,A
   \   1875  04                INC     A
   \   1876  F0                MOVX    @DPTR,A
   \   1877  8C82              MOV     DPL,R4
   \   1879  758300            MOV     DPH,#0
   \   187C  742D              MOV     A,#45
   \   187E  120000            LCALL   ?ST_A_R567_DISP_L17
   \   1881            ?0416:
   1447                  }
   1448                  vt = (char) v;
   \   1881  900000            MOV     DPTR,#$LOCBX myInt2DecStr+6
   \   1884  E0                MOVX    A,@DPTR
   1449                  if (vt > 99) {
   \   1885  900000            MOV     DPTR,#$LOCBX myInt2DecStr+2
   \   1888  F0                MOVX    @DPTR,A
   \   1889  249C              ADD     A,#156
   \   188B  5036              JNC     ?0418
   \   188D            ?0417:
   1450                      tmp = (char) vt / 100;
   \   188D  E0                MOVX    A,@DPTR
   \   188E  75F064            MOV     B,#100
   \   1891  84                DIV     AB
   1451                      str[i++] = tmp + '0';
   \   1892  900000            MOV     DPTR,#$LOCBX myInt2DecStr+1
   \   1895  F0                MOVX    @DPTR,A
   \   1896  FC                MOV     R4,A
   \   1897  2430              ADD     A,#48
   \   1899  FA                MOV     R2,A
   \   189A  900000            MOV     DPTR,#$LOCBX myInt2DecStr+7
   \   189D  E0                MOVX    A,@DPTR
   \   189E  FF                MOV     R7,A
   \   189F  A3                INC     DPTR
   \   18A0  E0                MOVX    A,@DPTR
   \   18A1  FE                MOV     R6,A
   \   18A2  A3                INC     DPTR
   \   18A3  E0                MOVX    A,@DPTR
   \   18A4  FD                MOV     R5,A
   \   18A5  900000            MOV     DPTR,#$LOCBX myInt2DecStr
   \   18A8  E0                MOVX    A,@DPTR
   \   18A9  FB                MOV     R3,A
   \   18AA  04                INC     A
   \   18AB  F0                MOVX    @DPTR,A
   \   18AC  8B82              MOV     DPL,R3
   \   18AE  758300            MOV     DPH,#0
   \   18B1  EA                MOV     A,R2
   \   18B2  120000            LCALL   ?ST_A_R567_DISP_L17
   1452                      vt = vt - (tmp * 100);
   \   18B5  EC                MOV     A,R4
   \   18B6  75F064            MOV     B,#100
   \   18B9  A4                MUL     AB
   \   18BA  F4                CPL     A
   \   18BB  04                INC     A
   \   18BC  900000            MOV     DPTR,#$LOCBX myInt2DecStr+2
   \   18BF  FC                MOV     R4,A
   \   18C0  E0                MOVX    A,@DPTR
   \   18C1  2C                ADD     A,R4
   \   18C2  F0                MOVX    @DPTR,A
   \   18C3            ?0418:
   1453                  }
   1454                  if (vt > 9) {
   \   18C3  E0                MOVX    A,@DPTR
   \   18C4  24F6              ADD     A,#246
   \   18C6  5036              JNC     ?0420
   \   18C8            ?0419:
   1455                      tmp = (int) vt / 10;
   \   18C8  E0                MOVX    A,@DPTR
   \   18C9  75F00A            MOV     B,#10
   \   18CC  84                DIV     AB
   1456                      str[i++] = tmp + '0';
   \   18CD  900000            MOV     DPTR,#$LOCBX myInt2DecStr+1
   \   18D0  F0                MOVX    @DPTR,A
   \   18D1  FC                MOV     R4,A
   \   18D2  2430              ADD     A,#48
   \   18D4  FA                MOV     R2,A
   \   18D5  900000            MOV     DPTR,#$LOCBX myInt2DecStr+7
   \   18D8  E0                MOVX    A,@DPTR
   \   18D9  FF                MOV     R7,A
   \   18DA  A3                INC     DPTR
   \   18DB  E0                MOVX    A,@DPTR
   \   18DC  FE                MOV     R6,A
   \   18DD  A3                INC     DPTR
   \   18DE  E0                MOVX    A,@DPTR
   \   18DF  FD                MOV     R5,A
   \   18E0  900000            MOV     DPTR,#$LOCBX myInt2DecStr
   \   18E3  E0                MOVX    A,@DPTR
   \   18E4  FB                MOV     R3,A
   \   18E5  04                INC     A
   \   18E6  F0                MOVX    @DPTR,A
   \   18E7  8B82              MOV     DPL,R3
   \   18E9  758300            MOV     DPH,#0
   \   18EC  EA                MOV     A,R2
   \   18ED  120000            LCALL   ?ST_A_R567_DISP_L17
   1457                      vt = vt - (tmp * 10);
   \   18F0  EC                MOV     A,R4
   \   18F1  75F00A            MOV     B,#10
   \   18F4  A4                MUL     AB
   \   18F5  F4                CPL     A
   \   18F6  04                INC     A
   \   18F7  900000            MOV     DPTR,#$LOCBX myInt2DecStr+2
   \   18FA  FC                MOV     R4,A
   \   18FB  E0                MOVX    A,@DPTR
   \   18FC  2C                ADD     A,R4
   \   18FD  F0                MOVX    @DPTR,A
   \   18FE            ?0420:
   1458                  }
   1459                  str[i++] = vt + '0';
   \   18FE  E0                MOVX    A,@DPTR
   \   18FF  2430              ADD     A,#48
   \   1901  FC                MOV     R4,A
   \   1902  900000            MOV     DPTR,#$LOCBX myInt2DecStr+7
   \   1905  E0                MOVX    A,@DPTR
   \   1906  FF                MOV     R7,A
   \   1907  A3                INC     DPTR
   \   1908  E0                MOVX    A,@DPTR
   \   1909  FE                MOV     R6,A
   \   190A  A3                INC     DPTR
   \   190B  E0                MOVX    A,@DPTR
   \   190C  FD                MOV     R5,A
   \   190D  900000            MOV     DPTR,#$LOCBX myInt2DecStr
   \   1910  E0                MOVX    A,@DPTR
   \   1911  FA                MOV     R2,A
   \   1912  04                INC     A
   \   1913  F0                MOVX    @DPTR,A
   \   1914  8A82              MOV     DPL,R2
   \   1916  758300            MOV     DPH,#0
   \   1919  EC                MOV     A,R4
   \   191A  120000            LCALL   ?ST_A_R567_DISP_L17
   1460                  str[i++] = 0;
   \   191D  900000            MOV     DPTR,#$LOCBX myInt2DecStr
   \   1920  E0                MOVX    A,@DPTR
   \   1921  FC                MOV     R4,A
   \   1922  04                INC     A
   \   1923  F0                MOVX    @DPTR,A
   \   1924  8C82              MOV     DPL,R4
   \   1926  758300            MOV     DPH,#0
   \   1929  E4                CLR     A
   \   192A  120000            LCALL   ?ST_A_R567_DISP_L17
   \   192D            ?0414:
   \   192D            ?0410:
   1461              }
   1462          }
   \   192D  900000            MOV     DPTR,#$LOCBX myInt2DecStr+3
   \   1930  E0                MOVX    A,@DPTR
   \   1931  F8                MOV     R0,A
   \   1932  A3                INC     DPTR
   \   1933  E0                MOVX    A,@DPTR
   \   1934  C0E0              PUSH    ACC
   \   1936  E8                MOV     A,R0
   \   1937  C0E0              PUSH    ACC
   \   1939  22                RET
   1463           
   1464          void    myInt2DecStr00(char v, char* str)
   1465          {
   \   193A            myInt2DecStr00:
   \   193A  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+2
   \   193D  D0E0              POP     ACC
   \   193F  F0                MOVX    @DPTR,A
   \   1940  A3                INC     DPTR
   \   1941  D0E0              POP     ACC
   \   1943  F0                MOVX    @DPTR,A
   1466              xdata char    i;
   1467              xdata char    tmp;
   1468              
   1469              i = 0;
   \   1944  E4                CLR     A
   \   1945  900000            MOV     DPTR,#$LOCBX myInt2DecStr00
   \   1948  F0                MOVX    @DPTR,A
   1470              if (v > 99) {
   \   1949  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+5
   \   194C  EF                MOV     A,R7
   \   194D  F0                MOVX    @DPTR,A
   \   194E  A3                INC     DPTR
   \   194F  EE                MOV     A,R6
   \   1950  F0                MOVX    @DPTR,A
   \   1951  A3                INC     DPTR
   \   1952  ED                MOV     A,R5
   \   1953  F0                MOVX    @DPTR,A
   \   1954  EC                MOV     A,R4
   \   1955  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+4
   \   1958  F0                MOVX    @DPTR,A
   \   1959  249C              ADD     A,#156
   \   195B  501E              JNC     ?0422
   \   195D            ?0421:
   1471                  myStrCpy(str, "PO");
   \   195D  7402              MOV     A,#2
   \   195F  900000            MOV     DPTR,#$PRMBX myStrCpy+3
   \   1962  F0                MOVX    @DPTR,A
   \   1963  A3                INC     DPTR
   \   1964  7404              MOV     A,#HIGH(?0423)
   \   1966  F0                MOVX    @DPTR,A
   \   1967  A3                INC     DPTR
   \   1968  7449              MOV     A,#LOW(?0423)
   \   196A  F0                MOVX    @DPTR,A
   \   196B  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+5
   \   196E  E0                MOVX    A,@DPTR
   \   196F  FF                MOV     R7,A
   \   1970  A3                INC     DPTR
   \   1971  E0                MOVX    A,@DPTR
   \   1972  FE                MOV     R6,A
   \   1973  A3                INC     DPTR
   \   1974  E0                MOVX    A,@DPTR
   \   1975  FD                MOV     R5,A
   \   1976  120000            LCALL   $REFFN myStrCpy
   1472              } else {
   \   1979  8057              SJMP    ?0424
   \   197B            ?0422:
   1473                  tmp = v / 10;
   \   197B  EC                MOV     A,R4
   \   197C  75F00A            MOV     B,#10
   \   197F  84                DIV     AB
   1474                  str[i++] = tmp + '0';
   \   1980  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+1
   \   1983  F0                MOVX    @DPTR,A
   \   1984  FD                MOV     R5,A
   \   1985  2430              ADD     A,#48
   \   1987  FE                MOV     R6,A
   \   1988  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+5
   \   198B  E0                MOVX    A,@DPTR
   \   198C  FB                MOV     R3,A
   \   198D  A3                INC     DPTR
   \   198E  E0                MOVX    A,@DPTR
   \   198F  FA                MOV     R2,A
   \   1990  A3                INC     DPTR
   \   1991  E0                MOVX    A,@DPTR
   \   1992  F9                MOV     R1,A
   \   1993  900000            MOV     DPTR,#$LOCBX myInt2DecStr00
   \   1996  E0                MOVX    A,@DPTR
   \   1997  FF                MOV     R7,A
   \   1998  04                INC     A
   \   1999  F0                MOVX    @DPTR,A
   \   199A  8F82              MOV     DPL,R7
   \   199C  758300            MOV     DPH,#0
   \   199F  EE                MOV     A,R6
   \   19A0  120000            LCALL   ?ST_A_R123_DISP_L17
   1475                  v = v - (tmp * 10);
   \   19A3  ED                MOV     A,R5
   \   19A4  75F00A            MOV     B,#10
   \   19A7  A4                MUL     AB
   \   19A8  F4                CPL     A
   \   19A9  04                INC     A
   \   19AA  2C                ADD     A,R4
   1476          
   1477                  str[i++] = v + '0';
   \   19AB  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+4
   \   19AE  F0                MOVX    @DPTR,A
   \   19AF  2430              ADD     A,#48
   \   19B1  900000            MOV     DPTR,#$LOCBX myInt2DecStr00
   \   19B4  FC                MOV     R4,A
   \   19B5  E0                MOVX    A,@DPTR
   \   19B6  FD                MOV     R5,A
   \   19B7  04                INC     A
   \   19B8  F0                MOVX    @DPTR,A
   \   19B9  8D82              MOV     DPL,R5
   \   19BB  758300            MOV     DPH,#0
   \   19BE  EC                MOV     A,R4
   \   19BF  120000            LCALL   ?ST_A_R123_DISP_L17
   1478                  str[i++] = 0;
   \   19C2  900000            MOV     DPTR,#$LOCBX myInt2DecStr00
   \   19C5  E0                MOVX    A,@DPTR
   \   19C6  FC                MOV     R4,A
   \   19C7  04                INC     A
   \   19C8  F0                MOVX    @DPTR,A
   \   19C9  8C82              MOV     DPL,R4
   \   19CB  758300            MOV     DPH,#0
   \   19CE  E4                CLR     A
   \   19CF  120000            LCALL   ?ST_A_R123_DISP_L17
   \   19D2            ?0424:
   1479              }
   1480          }
   \   19D2  900000            MOV     DPTR,#$LOCBX myInt2DecStr00+2
   \   19D5  E0                MOVX    A,@DPTR
   \   19D6  F8                MOV     R0,A
   \   19D7  A3                INC     DPTR
   \   19D8  E0                MOVX    A,@DPTR
   \   19D9  C0E0              PUSH    ACC
   \   19DB  E8                MOV     A,R0
   \   19DC  C0E0              PUSH    ACC
   \   19DE  22                RET
   1481          
   1482          
   1483          int myStr2Int(const char* str)
   1484          {
   \   19DF            myStr2Int:
   1485              xdata int t = 0;
   \   19DF  900000            MOV     DPTR,#$LOCBX myStr2Int
   \   19E2  E4                CLR     A
   \   19E3  F0                MOVX    @DPTR,A
   \   19E4  A3                INC     DPTR
   \   19E5  F0                MOVX    @DPTR,A
   \   19E6  A3                INC     DPTR
   \   19E7  EF                MOV     A,R7
   \   19E8  F0                MOVX    @DPTR,A
   \   19E9  A3                INC     DPTR
   \   19EA  EE                MOV     A,R6
   \   19EB  F0                MOVX    @DPTR,A
   \   19EC  A3                INC     DPTR
   \   19ED  ED                MOV     A,R5
   \   19EE  F0                MOVX    @DPTR,A
   \   19EF            ?0426:
   1486              
   1487              while ((*(str) >= '0') && (*(str) <= '9')) {
   \   19EF  900000            MOV     DPTR,#$LOCBX myStr2Int+2
   \   19F2  E0                MOVX    A,@DPTR
   \   19F3  FF                MOV     R7,A
   \   19F4  A3                INC     DPTR
   \   19F5  E0                MOVX    A,@DPTR
   \   19F6  FE                MOV     R6,A
   \   19F7  A3                INC     DPTR
   \   19F8  E0                MOVX    A,@DPTR
   \   19F9  FD                MOV     R5,A
   \   19FA  120000            LCALL   ?LD_A_R567_L17
   \   19FD  24D0              ADD     A,#208
   \   19FF  5052              JNC     ?0425
   \   1A01  120000            LCALL   ?LD_A_R567_L17
   \   1A04  24C6              ADD     A,#198
   \   1A06  404B              JC      ?0425
   \   1A08            ?0429:
   \   1A08            ?0428:
   \   1A08            ?0427:
   1488                  t = (10 * t) + *(str++) - '0';
   \   1A08  900000            MOV     DPTR,#$LOCBX myStr2Int
   \   1A0B  E0                MOVX    A,@DPTR
   \   1A0C  A3                INC     DPTR
   \   1A0D  E0                MOVX    A,@DPTR
   \   1A0E  A3                INC     DPTR
   \   1A0F  E0                MOVX    A,@DPTR
   \   1A10  FF                MOV     R7,A
   \   1A11  A3                INC     DPTR
   \   1A12  E0                MOVX    A,@DPTR
   \   1A13  FE                MOV     R6,A
   \   1A14  C083              PUSH    DPH
   \   1A16  A3                INC     DPTR
   \   1A17  E0                MOVX    A,@DPTR
   \   1A18  04                INC     A
   \   1A19  F0                MOVX    @DPTR,A
   \   1A1A  1582              DEC     DPL
   \   1A1C  D083              POP     DPH
   \   1A1E  7003              JNZ     ?0446
   \   1A20  EE                MOV     A,R6
   \   1A21  04                INC     A
   \   1A22  F0                MOVX    @DPTR,A
   \   1A23            ?0446:
   \   1A23  120000            LCALL   ?LD_A_R567_L17
   \   1A26  FC                MOV     R4,A
   \   1A27  900000            MOV     DPTR,#$LOCBX myStr2Int
   \   1A2A  E0                MOVX    A,@DPTR
   \   1A2B  FF                MOV     R7,A
   \   1A2C  A3                INC     DPTR
   \   1A2D  E0                MOVX    A,@DPTR
   \   1A2E  75F00A            MOV     B,#10
   \   1A31  A4                MUL     AB
   \   1A32  FE                MOV     R6,A
   \   1A33  E5F0              MOV     A,B
   \   1A35  CF                XCH     A,R7
   \   1A36  75F00A            MOV     B,#10
   \   1A39  A4                MUL     AB
   \   1A3A  2F                ADD     A,R7
   \   1A3B  FF                MOV     R7,A
   \   1A3C  EC                MOV     A,R4
   \   1A3D  2E                ADD     A,R6
   \   1A3E  FC                MOV     R4,A
   \   1A3F  E4                CLR     A
   \   1A40  3F                ADDC    A,R7
   \   1A41  FD                MOV     R5,A
   \   1A42  EC                MOV     A,R4
   \   1A43  24D0              ADD     A,#208
   \   1A45  FC                MOV     R4,A
   \   1A46  ED                MOV     A,R5
   \   1A47  34FF              ADDC    A,#255
   \   1A49  900000            MOV     DPTR,#$LOCBX myStr2Int
   \   1A4C  F0                MOVX    @DPTR,A
   \   1A4D  A3                INC     DPTR
   \   1A4E  CC                XCH     A,R4
   \   1A4F  F0                MOVX    @DPTR,A
   \   1A50  CC                XCH     A,R4
   \   1A51  809C              SJMP    ?0426
   \   1A53            ?0425:
   1489              }
   1490              return t;
   \   1A53  900000            MOV     DPTR,#$LOCBX myStr2Int
   \   1A56  E0                MOVX    A,@DPTR
   \   1A57  FD                MOV     R5,A
   \   1A58  A3                INC     DPTR
   \   1A59  E0                MOVX    A,@DPTR
   \   1A5A  FC                MOV     R4,A
   1491          }
   \   1A5B  22                RET
   1492          
   1493          /*
   1494          void    ReadSpare( void )
   1495          {
   1496              xdata int     i;
   1497              xdata char    c;
   1498                     
   1499              readAddress = 0;
   1500              SetupSpareReadSeq();
   1501              
   1502              SendStringEOLRS232("Reading from flash spare area...");
   1503              c = WaitAndReceiveRS232();
   1504          
   1505              for (i=0 ; i<16 ; i++) {
   1506                  sprintf(msg, "Address: %04X, Data: ", (int) readAddress);
   1507                  SendStringRS232(msg);
   1508                  c = ReadFLASH();
   1509                  sprintf(msg, "%02X", c);
   1510                  SendStringEOLRS232(msg);
   1511              }
   1512              TerminateReadSeq();
   1513          }
   1514           
   1515          
   1516          void    WF1( void )
   1517          {
   1518              int         i;
   1519              FILE*       fp;
   1520          
   1521              SendStringEOLRS232("Creating file...");
   1522           
   1523              fp = fopen("Hej.txt", "w");
   1524          
   1525              if (fp) {
   1526                  i = fp->startAddress; 
   1527                  sprintf(msg, "Startaddress: %04X", i);
   1528                  SendStringEOLRS232(msg);
   1529          
   1530                  SendStringEOLRS232("Putting 1200 characters...");
   1531                  for (i=0 ; i<1200 ; i++) {
   1532                      fputc(fp, i & 0xFF);
   1533                  }
   1534                  SendStringEOLRS232("Closing file...");
   1535                  fclose(fp);
   1536                  SendStringEOLRS232("Done");
   1537              } else {
   1538                  SendStringEOLRS232("Unable to open file");
   1539              }
   1540          }
   1541           
   1542          
   1543          void    WF2( void )
   1544          {
   1545              FILE*       fp;
   1546              int         i;
   1547              
   1548              SendStringEOLRS232("Creating file...");
   1549           
   1550              fp = fopen("Hejsan02.txt", "w");
   1551          
   1552              if (fp) {
   1553                  i = fp->startAddress; 
   1554                  sprintf(msg, "Startaddress: %04X", i);
   1555                  SendStringEOLRS232(msg);
   1556          
   1557                  SendStringEOLRS232("Putting five characters...");
   1558                  fputc(fp, 10);
   1559                  fputc(fp, 11);
   1560                  fputc(fp, 12);
   1561                  fputc(fp, 13);
   1562                  fputc(fp, 14);
   1563           
   1564                  SendStringEOLRS232("Closing file...");
   1565                  fclose(fp);
   1566                  SendStringEOLRS232("Done");
   1567              } else {
   1568                  SendStringEOLRS232("Unable to open file");
   1569              }
   1570          }
   1571          
   1572          
   1573          void    RF1( void )
   1574          {
   1575              FILE*       fp;
   1576              char        c;
   1577              int         i, j;
   1578           
   1579              SendStringEOLRS232("Opening file...");
   1580           
   1581              fp = fopen("Hej.txt", "r");
   1582          
   1583              if (fp) {
   1584                  i = fp->startAddress; 
   1585                  sprintf(msg, "Startaddress: %04X", i);
   1586                  SendStringEOLRS232(msg);
   1587          
   1588                  SendStringEOLRS232("Pulling 1200 characters...");
   1589                  for (i=0 ; i<100 ; i++) {
   1590                      for (j=0 ; j<11 ; j++) {
   1591                          c = fgetc(fp) & 0xFF;
   1592                          sprintf(msg, "%02X ", c);
   1593                          SendStringRS232(msg);
   1594                      }
   1595                      c = fgetc(fp) & 0xFF;
   1596                      sprintf(msg, "%02X", c);
   1597                      SendStringEOLRS232(msg);
   1598                  }
   1599           
   1600                  SendStringEOLRS232("Closing file...");
   1601                  fclose(fp);
   1602                  SendStringEOLRS232("Done");
   1603              } else {
   1604                  SendStringEOLRS232("Unable to open file");
   1605              }
   1606          }
   1607           
   1608          void    RF2( void )
   1609          {
   1610              FILE*       fp;
   1611              FILE*       fp1;
   1612              char        c;
   1613              int         i;
   1614          
   1615              SendStringEOLRS232("Opening file...");
   1616           
   1617              fp = fopen("Hejsan02.txt", "r");
   1618          
   1619              if (fp) {     
   1620                  i = fp->startAddress; 
   1621                  sprintf(msg, "Startaddress: %04X", i);
   1622                  SendStringEOLRS232(msg);
   1623           
   1624                  SendStringEOLRS232("Pulling five characters...");
   1625           
   1626                  fp1 = fopen("Hej.txt", "r");
   1627          
   1628                  if (fp1) {
   1629                      SendStringEOLRS232("Second file...");
   1630                      c = fgetc(fp1) & 0xFF;
   1631                      sprintf(msg, "%02X", c);
   1632                      SendStringEOLRS232(msg);
   1633                      c = fgetc(fp1) & 0xFF;
   1634                      sprintf(msg, "%02X", c);
   1635                      SendStringEOLRS232(msg);
   1636                      c = fgetc(fp1) & 0xFF;
   1637                      sprintf(msg, "%02X", c);
   1638                      SendStringEOLRS232(msg);
   1639                      fclose(fp1);
   1640                      SendStringEOLRS232("Second done");
   1641                  }
   1642          
   1643                  c = fgetc(fp) & 0xFF;
   1644                  sprintf(msg, "%02X", c);
   1645                  SendStringEOLRS232(msg);
   1646                  c = fgetc(fp) & 0xFF;
   1647                  sprintf(msg, "%02X", c);
   1648                  SendStringEOLRS232(msg);
   1649                  c = fgetc(fp) & 0xFF;
   1650                  sprintf(msg, "%02X", c);
   1651                  SendStringEOLRS232(msg);
   1652           
   1653                  i = ftell(fp);
   1654                  sprintf(msg, "Current pos: %d", i);
   1655                  SendStringEOLRS232(msg);
   1656                  
   1657                  SendStringEOLRS232("Setting pos one up...");
   1658                  
   1659                  fSetPos(fp, i-1);
   1660                  
   1661                  c = fgetc(fp) & 0xFF;
   1662                  sprintf(msg, "%02X", c);
   1663                  SendStringEOLRS232(msg);
   1664                  c = fgetc(fp) & 0xFF;
   1665                  sprintf(msg, "%02X", c);
   1666                  SendStringEOLRS232(msg);
   1667                  
   1668                  SendStringEOLRS232("Rewinding...");
   1669                  
   1670                  Rewind(fp);
   1671                  
   1672                  c = fgetc(fp) & 0xFF;
   1673                  sprintf(msg, "%02X", c);
   1674                  SendStringEOLRS232(msg);
   1675                  c = fgetc(fp) & 0xFF;
   1676                  sprintf(msg, "%02X", c);
   1677                  SendStringEOLRS232(msg);
   1678          
   1679                  SendStringEOLRS232("Closing file...");
   1680                  fclose(fp);
   1681                  SendStringEOLRS232("Done");
   1682              } else {
   1683                  SendStringEOLRS232("Unable to open file");
   1684              }
   1685          }
   1686          
   1687          void    RF3( void )
   1688          {
   1689              FILE*       fp;
   1690              int         i;
   1691           
   1692              SendStringEOLRS232("Opening file...");
   1693           
   1694              fp = fopen("Rader.txt", "r");
   1695          
   1696              if (fp) {
   1697                  i = fp->startAddress; 
   1698                  sprintf(msg, "Startaddress: %04X", i);
   1699                  SendStringEOLRS232(msg);
   1700           
   1701                  SendStringEOLRS232("Reading 5 rows...");
   1702                  fgetLine(fp, msg, 50);
   1703                  SendStringEOLRS232(msg);
   1704                  fgetLine(fp, msg, 50);
   1705                  SendStringEOLRS232(msg);
   1706                  fgetLine(fp, msg, 50);
   1707                  SendStringEOLRS232(msg);
   1708                  fgetLine(fp, msg, 50);
   1709                  SendStringEOLRS232(msg);
   1710                  fgetLine(fp, msg, 26);
   1711                  SendStringEOLRS232(msg);
   1712                  fgetLine(fp, msg, 50);
   1713                  SendStringEOLRS232(msg);
   1714                  fgetLine(fp, msg, 50);
   1715                  SendStringEOLRS232(msg);
   1716                  
   1717                  SendStringEOLRS232("Closing file...");
   1718                  fclose(fp);
   1719                  SendStringEOLRS232("Done");
   1720              } else {
   1721                  SendStringEOLRS232("Unable to open file");
   1722              }
   1723          }
   1724          
   1725          
   1726          
   1727          void    CreateLong( void )
   1728          {
   1729              SendStringEOLRS232("Creating long filehead at 0...");
   1730          
   1731              writeAddress = 0;
   1732          
   1733              SetupSpareWriteSeq();
   1734          
   1735              WriteFLASH(0xAA);
   1736              WriteFLASH(0x00);    //Fillängd = 4194294 bytes
   1737              WriteFLASH(0x3F);
   1738              WriteFLASH(0xFF);
   1739              WriteFLASH(0xF6);
   1740          
   1741              WriteFLASH('L');
   1742              WriteFLASH('o');
   1743              WriteFLASH('n');
   1744              WriteFLASH('g');
   1745              WriteFLASH(0);
   1746              WriteFLASH(0);
   1747              WriteFLASH(0);
   1748              WriteFLASH(0);
   1749              WriteFLASH('t');
   1750              WriteFLASH('x');
   1751              WriteFLASH('t');
   1752              
   1753              PerformWriteSeq();
   1754              TerminateWriteSeq();
   1755          }
   1756          
   1757          
   1758          
   1759          
   1760          void    ReadSpare2( void )
   1761          {
   1762              xdata int     i;
   1763              xdata char    c;
   1764                     
   1765              readAddress = 0x400000;
   1766              SetupSpareReadSeq();
   1767              
   1768              SendStringEOLRS232("Reading from flash spare area 400000...");
   1769              c = WaitAndReceiveRS232();
   1770          
   1771              for (i=0 ; i<16 ; i++) {
   1772                  sprintf(msg, "Address: %04X, Data: ", (int) readAddress);
   1773                  SendStringRS232(msg);
   1774                  c = ReadFLASH();
   1775                  sprintf(msg, "%02X", c);
   1776                  SendStringEOLRS232(msg);
   1777              }
   1778              TerminateReadSeq();
   1779          }
   1780          */
   1781          
   1782          
   1783          void    Append( void )
   1784          {
   \   1A5C            Append:
   1785          /*
   1786              FILE*       fp;
   1787          
   1788              SendStringEOLRS232("Writing to append file");
   1789              fp = fopenA("Append.txt", 8192, -1);
   1790              
   1791              if (fp) {
   1792                  fputLine(fp, commandLine[1]);
   1793                  fclose(fp);
   1794              } else {
   1795                  SendStringEOLRS232("Unable to open file");
   1796              }
   1797              SendStringEOLRS232("Done    ");
   1798          */
   1799          }
   \   1A5C  22                RET
   1800          
   1801          
   1802          
   1803          
   1804          
   1805          
   1806          
   1807          
   1808          
   1809          interrupt void T0_int (void)
   1810          //När man skall använda timer 0 sätter man först några register så att önskad tid ställs in 
   1811          //(se InitialiseComputer()). Sedan sätter man igång timer 0. Om timer 0 slår över så sätts 
   1812          //timeout till 1 och räknaren stängs av.
   1813          {
   \   1A5D            T0_int:
   \   1A5D  C0E0              PUSH    ACC
   \   1A5F  C082              PUSH    DPL
   \   1A61  C083              PUSH    DPH
   1814              timeout = 1;               
   \   1A63  7401              MOV     A,#1
   \   1A65  9001E8            MOV     DPTR,#timeout
   \   1A68  F0                MOVX    @DPTR,A
   1815              TR0 = 0;                                            //Stoppar timer0
   \   1A69  C28C              CLR     TCON.4
   1816          }
   \   1A6B  D083              POP     DPH
   \   1A6D  D082              POP     DPL
   \   1A6F  D0E0              POP     ACC
   \   1A71  32                RETI
   1817          
   1818          
   1819          
   1820          
   \   0000                    RSEG    CSTR
   \   0000            ?0002:
   \   0000  54686520          DB      'The SuperComputer and FRHA welcomes you, ver2',0
   \   0004  53757065
   \   0008  72436F6D
   \   000C  70757465
   \   0010  7220616E
   \   0014  64204652
   \   0018  48412077
   \   001C  656C636F
   \   0020  6D657320
   \   0024  796F752C
   \   0028  20766572
   \   002C  3200
   \   002E            ?0004:
   \   002E  446F6767          DB      'Dogged!!!!!',0
   \   0032  65642121
   \   0036  21212100
   \   003A            ?0005:
   \   003A  57616974          DB      'Waiting for',0
   \   003E  696E6720
   \   0042  666F7200
   \   0046            ?0006:
   \   0046  7465726D          DB      'terminal wakeup...',0
   \   004A  696E616C
   \   004E  2077616B
   \   0052  6575702E
   \   0056  2E2E00
   \   0059            ?0007:
   \   0059  54656C65          DB      'Telestation 3.5       (c) 2004-09-19 FRHA',0
   \   005D  73746174
   \   0061  696F6E20
   \   0065  332E3520
   \   0069  20202020
   \   006D  20202863
   \   0071  29203230
   \   0075  30342D30
   \   0079  392D3139
   \   007D  20465248
   \   0081  4100
   \   0083            ?0008:
   \   0083  53656E64          DB      'Send char for prompt...',0
   \   0087  20636861
   \   008B  7220666F
   \   008F  72207072
   \   0093  6F6D7074
   \   0097  2E2E2E00
   \   009B            ?0016:
   \   009B  52756E6E          DB      'Running phone answer application',0
   \   009F  696E6720
   \   00A3  70686F6E
   \   00A7  6520616E
   \   00AB  73776572
   \   00AF  20617070
   \   00B3  6C696361
   \   00B7  74696F6E
   \   00BB  00
   \   00BC            ?0017:
   \   00BC  616E732E          DB      'ans.bat',0
   \   00C0  62617400
   \   00C4            ?0018:
   \   00C4  54656C65          DB      'TeleStation is under',0
   \   00C8  53746174
   \   00CC  696F6E20
   \   00D0  69732075
   \   00D4  6E646572
   \   00D8  00
   \   00D9            ?0019:
   \   00D9  7465726D          DB      'terminal control',0
   \   00DD  696E616C
   \   00E1  20636F6E
   \   00E5  74726F6C
   \   00E9  00
   \   00EA            ?0020:
   \   00EA  4C434420          DB      'LCD init...',0
   \   00EE  696E6974
   \   00F2  2E2E2E00
   \   00F6            ?0021:
   \   00F6  466C6173          DB      'Flash init...',0
   \   00FA  6820696E
   \   00FE  69742E2E
   \   0102  2E00
   \   0104            ?0022:
   \   0104  46696C65          DB      'Filesys init...',0
   \   0108  73797320
   \   010C  696E6974
   \   0110  2E2E2E00
   \   0114            ?0023:
   \   0114  57415620          DB      'WAV init...',0
   \   0118  696E6974
   \   011C  2E2E2E00
   \   0120            ?0024:
   \   0120  44544D46          DB      'DTMF init...',0
   \   0124  20696E69
   \   0128  742E2E2E
   \   012C  00
   \   012D            ?0025:
   \   012D  50686F6E          DB      'Phone init...',0
   \   0131  6520696E
   \   0135  69742E2E
   \   0139  2E00
   \   013B            ?0026:
   \   013B  54696D65          DB      'Timer init...',0
   \   013F  7220696E
   \   0143  69742E2E
   \   0147  2E00
   \   0149            ?0027:
   \   0149  43616C65          DB      'Calender init...',0
   \   014D  6E646572
   \   0151  20696E69
   \   0155  742E2E2E
   \   0159  00
   \   015A            ?0028:
   \   015A  4B657962          DB      'Keyboard init...',0
   \   015E  6F617264
   \   0162  20696E69
   \   0166  742E2E2E
   \   016A  00
   \   016B            ?0029:
   \   016B  44504F54          DB      'DPOT init...',0
   \   016F  20696E69
   \   0173  742E2E2E
   \   0177  00
   \   0178            ?0030:
   \   0178  50686F6E          DB      'Phone Answering init...',0
   \   017C  6520416E
   \   0180  73776572
   \   0184  696E6720
   \   0188  696E6974
   \   018C  2E2E2E00
   \   0190            ?0031:
   \   0190  4C6F6720          DB      'Log file init...',0
   \   0194  66696C65
   \   0198  20696E69
   \   019C  742E2E2E
   \   01A0  00
   \   01A1            ?0032:
   \   01A1  42617463          DB      'Batch file init...',0
   \   01A5  68206669
   \   01A9  6C652069
   \   01AD  6E69742E
   \   01B1  2E2E00
   \   01B4            ?0033:
   \   01B4  4D656D6F          DB      'Memo file init...',0
   \   01B8  2066696C
   \   01BC  6520696E
   \   01C0  69742E2E
   \   01C4  2E00
   \   01C6            ?0052:
   \   01C6  7200              DB      'r',0
   \   01C8            ?0056:
   \   01C8  556E7265          DB      'Unrecognized command or BAT-file',0
   \   01CC  636F676E
   \   01D0  697A6564
   \   01D4  20636F6D
   \   01D8  6D616E64
   \   01DC  206F7220
   \   01E0  4241542D
   \   01E4  66696C65
   \   01E8  00
   \   01E9            ?0059:
   \   01E9  4572726F          DB      'Error code: ',0
   \   01ED  7220636F
   \   01F1  64653A20
   \   01F5  00
   \   01F6            ?0074:
   \   01F6  48454C4C          DB      'HELLO',0
   \   01FA  4F00
   \   01FC            ?0078:
   \   01FC  45524153          DB      'ERASE',0
   \   0200  4500
   \   0202            ?0082:
   \   0202  43524541          DB      'CREATEDYNAMIC',0
   \   0206  54454459
   \   020A  4E414D49
   \   020E  4300
   \   0210            ?0086:
   \   0210  45524153          DB      'ERASEDYNAMIC',0
   \   0214  4544594E
   \   0218  414D4943
   \   021C  00
   \   021D            ?0090:
   \   021D  44495200          DB      'DIR',0
   \   0221            ?0094:
   \   0221  54595045          DB      'TYPE',0
   \   0225  00
   \   0226            ?0098:
   \   0226  54595045          DB      'TYPEA',0
   \   022A  4100
   \   022C            ?0102:
   \   022C  4543484F          DB      'ECHOMIC',0
   \   0230  4D494300
   \   0234            ?0106:
   \   0234  4543484F          DB      'ECHOPHONE',0
   \   0238  50484F4E
   \   023C  4500
   \   023E            ?0110:
   \   023E  5245434D          DB      'RECMIC',0
   \   0242  494300
   \   0245            ?0114:
   \   0245  52454350          DB      'RECPHONE',0
   \   0249  484F4E45
   \   024D  00
   \   024E            ?0118:
   \   024E  544F4E45          DB      'TONE',0
   \   0252  00
   \   0253            ?0122:
   \   0253  504C4159          DB      'PLAY',0
   \   0257  00
   \   0258            ?0126:
   \   0258  44544D46          DB      'DTMF',0
   \   025C  00
   \   025D            ?0130:
   \   025D  504400            DB      'PD',0
   \   0260            ?0134:
   \   0260  505500            DB      'PU',0
   \   0263            ?0138:
   \   0263  57414954          DB      'WAITFOR',0
   \   0267  464F5200
   \   026B            ?0142:
   \   026B  414E534F          DB      'ANSON',0
   \   026F  4E00
   \   0271            ?0146:
   \   0271  414E534F          DB      'ANSOFF',0
   \   0275  464600
   \   0278            ?0150:
   \   0278  43524541          DB      'CREATELOG',0
   \   027C  54454C4F
   \   0280  4700
   \   0282            ?0151:
   \   0282  4C6F6720          DB      'Log created here too!',0
   \   0286  63726561
   \   028A  74656420
   \   028E  68657265
   \   0292  20746F6F
   \   0296  2100
   \   0298            ?0155:
   \   0298  454E5445          DB      'ENTERCODE',0
   \   029C  52434F44
   \   02A0  4500
   \   02A2            ?0159:
   \   02A2  524300            DB      'RC',0
   \   02A5            ?0167:
   \   02A5  4572726F          DB      'Error in read',0
   \   02A9  7220696E
   \   02AD  20726561
   \   02B1  6400
   \   02B3            ?0169:
   \   02B3  496C6C65          DB      'Illegal address',0
   \   02B7  67616C20
   \   02BB  61646472
   \   02BF  65737300
   \   02C3            ?0173:
   \   02C3  574300            DB      'WC',0
   \   02C6            ?0180:
   \   02C6  4572726F          DB      'Error in write',0
   \   02CA  7220696E
   \   02CE  20777269
   \   02D2  746500
   \   02D5            ?0185:
   \   02D5  474F544F          DB      'GOTO',0
   \   02D9  00
   \   02DA            ?0189:
   \   02DA  4E6F2042          DB      'No BAT-file is running!',0
   \   02DE  41542D66
   \   02E2  696C6520
   \   02E6  69732072
   \   02EA  756E6E69
   \   02EE  6E672100
   \   02F2            ?0193:
   \   02F2  42524143          DB      'BRACATEQU',0
   \   02F6  41544551
   \   02FA  5500
   \   02FC            ?0202:
   \   02FC  5245434D          DB      'RECMSG',0
   \   0300  534700
   \   0303            ?0206:
   \   0303  51554553          DB      'QUESTION',0
   \   0307  54494F4E
   \   030B  00
   \   030C            ?0210:
   \   030C  504C4159          DB      'PLAYNEW',0
   \   0310  4E455700
   \   0314            ?0214:
   \   0314  57414954          DB      'WAITCALL',0
   \   0318  43414C4C
   \   031C  00
   \   031D            ?0218:
   \   031D  52454144          DB      'READPB',0
   \   0321  504200
   \   0324            ?0222:
   \   0324  4C4F4F4B          DB      'LOOKUP',0
   \   0328  555000
   \   032B            ?0223:
   \   032B  43616C6C          DB      'Caller: ',0
   \   032F  65723A20
   \   0333  00
   \   0334            ?0224:
   \   0334  43617465          DB      'Category: ',0
   \   0338  676F7279
   \   033C  3A2000
   \   033F            ?0225:
   \   033F  2000              DB      ' ',0
   \   0341            ?0229:
   \   0341  53455457          DB      'SETWIPER',0
   \   0345  49504552
   \   0349  00
   \   034A            ?0230:
   \   034A  52657475          DB      'Returned: ',0
   \   034E  726E6564
   \   0352  3A2000
   \   0355            ?0234:
   \   0355  53504541          DB      'SPEAKVOL',0
   \   0359  4B564F4C
   \   035D  00
   \   035E            ?0235:
   \   035E  53706561          DB      'Speaker volume set to: ',0
   \   0362  6B657220
   \   0366  766F6C75
   \   036A  6D652073
   \   036E  65742074
   \   0372  6F3A2000
   \   0376            ?0239:
   \   0376  53455444          DB      'SETDPREG',0
   \   037A  50524547
   \   037E  00
   \   037F            ?0243:
   \   037F  54524654          DB      'TRFTOWIPER',0
   \   0383  4F574950
   \   0387  455200
   \   038A            ?0247:
   \   038A  52454144          DB      'READWIPER',0
   \   038E  57495045
   \   0392  5200
   \   0394            ?0248:
   \   0394  56616C75          DB      'Value: ',0
   \   0398  653A2000
   \   039C            ?0252:
   \   039C  443100            DB      'D1',0
   \   039F            ?0256:
   \   039F  443000            DB      'D0',0
   \   03A2            ?0260:
   \   03A2  433100            DB      'C1',0
   \   03A5            ?0264:
   \   03A5  433000            DB      'C0',0
   \   03A8            ?0268:
   \   03A8  4341544A          DB      'CATJUMP',0
   \   03AC  554D5000
   \   03B0            ?0274:
   \   03B0  54434A00          DB      'TCJ',0
   \   03B4            ?0277:
   \   03B4  43617465          DB      'Category Hit',0
   \   03B8  676F7279
   \   03BC  20486974
   \   03C0  00
   \   03C1            ?0279:
   \   03C1  43617465          DB      'Category Miss',0
   \   03C5  676F7279
   \   03C9  204D6973
   \   03CD  7300
   \   03CF            ?0283:
   \   03CF  504C4159          DB      'PLAYMEMO',0
   \   03D3  4D454D4F
   \   03D7  00
   \   03D8            ?0287:
   \   03D8  5245434D          DB      'RECMEMO',0
   \   03DC  454D4F00
   \   03E0            ?0291:
   \   03E0  53455453          DB      'SETSIGNALS',0
   \   03E4  49474E41
   \   03E8  4C5300
   \   03EB            ?0322:
   \   03EB  4241543A          DB      'BAT: Unrecognized command or BAT-file',0
   \   03EF  20556E72
   \   03F3  65636F67
   \   03F7  6E697A65
   \   03FB  6420636F
   \   03FF  6D6D616E
   \   0403  64206F72
   \   0407  20424154
   \   040B  2D66696C
   \   040F  6500
   \   0411            ?0325:
   \   0411  4241543A          DB      'BAT: Error code: ',0
   \   0415  20457272
   \   0419  6F722063
   \   041D  6F64653A
   \   0421  2000
   \   0423            ?0326:
   \   0423  4241542D          DB      'BAT-file finished',0
   \   0427  66696C65
   \   042B  2066696E
   \   042F  69736865
   \   0433  6400
   \   0435            ?0364:
   \   0435  48656C6C          DB      'Hello!',0
   \   0439  6F2100
   \   043C            ?0409:
   \   043C  3E203235          DB      '> 255',0
   \   0440  3500
   \   0442            ?0413:
   \   0442  3C202D32          DB      '< -255',0
   \   0446  353500
   \   0449            ?0423:
   \   0449  504F00            DB      'PO',0
   \   0000                    RSEG    CONST
   \   0000            ?0060:
   \   0000  200900            DB      ' ',9,0
   \   0003  00                DB      0
   \   0004            ?0327:
   \   0004  20093A00          DB      ' ',9,':',0
   \   0008  00                DB      0
   \   0000                    COMMON  INTVEC
   \   000B                    DS      11
   \   000B  02                DB      2
   \   000C  1A5D              DB      HIGH(T0_int),LOW(T0_int)
   \   0000                    RSEG    X_UDATA
   \   0000            commandLine:
   \   0180                    DS      384
   \   0180            nrCommandParameters:
   \   0182                    DS      2
   \   0182            error:
   \   0184                    DS      2
   \   0184            msg:
   \   01E8                    DS      100
   \   01E8            timeout:
   \   01E9                    DS      1
   \   01E9            batFilePtr:
   \   01EC                    DS      3
   \   01EC            batLabelName:
   \   03EC                    DS      512
   \   03EC            batLabelPos:
   \   04EC                    DS      256
   \   04EC                    END


                                       S Y M B O L - T A B L E
                                       =======================


            #include file(s):

       [1]       c:\iar\ew\8051\inc\io517a.h
       [2]       c:\iar\ew\8051\inc\stdio.h
       [3]       c:\iar\ew\8051\inc\stdlib.h
       [4]       c:\iar\ew\8051\inc\string.h
       [5]       commands.h
       [6]       errorcodes.h
       [7]       filesystem.h
       [8]       phone.h
       [9]       calender.h
      [10]       dpot.h
      [11]       main.h
      [12]       filesystem.h
      [13]       rs232.h
      [14]       wav.h
      [15]       dtmf.h
      [16]       phone.h
      [17]       timer.h
      [18]       phoneans.h
      [19]       main.h
      [20]       calender.h
      [21]       lcd.h
      [22]       keyboard.h
      [23]       logfile.h
      [24]       filesystem.h


            Symbol                     Type     Mem     Class   Defline   Refline(s)
            ------                     ----     ---     -----   -------   ----------

?0002                                 array    code    static      127        127
?0004                                 array    code    static      129        129
?0005                                 array    code    static      134        134
?0006                                 array    code    static      134        134
?0007                                 array    code    static      135        135
?0008                                 array    code    static      137        137
?0016                                 array    code    static      147        147
?0017                                 array    code    static      149        149
?0018                                 array    code    static      152        152
?0019                                 array    code    static      152        152
?0020                                 array    code    static      184        184
?0021                                 array    code    static      190        190
?0022                                 array    code    static      196        196
?0023                                 array    code    static      202        202
?0024                                 array    code    static      208        208
?0025                                 array    code    static      214        214
?0026                                 array    code    static      220        220
?0027                                 array    code    static      226        226
?0028                                 array    code    static      232        232
?0029                                 array    code    static      238        238
?0030                                 array    code    static      281        281
?0031                                 array    code    static      287        287
?0032                                 array    code    static      293        293
?0033                                 array    code    static      299        299
?0052                                 array    code    static      339        339      882
?0056                                 array    code    static      346        346
?0059                                 array    code    static      360        360
?0074                                 array    code    static      460        460
?0078                                 array    code    static      472        472
?0082                                 array    code    static      476        476
?0086                                 array    code    static      480        480
?0090                                 array    code    static      512        512
?0094                                 array    code    static      536        536
?0098                                 array    code    static      540        540
?0102                                 array    code    static      544        544
?0106                                 array    code    static      549        549
?0110                                 array    code    static      554        554
?0114                                 array    code    static      559        559
?0118                                 array    code    static      569        569
?0122                                 array    code    static      573        573
?0126                                 array    code    static      578        578
?0130                                 array    code    static      586        586
?0134                                 array    code    static      590        590
?0138                                 array    code    static      600        600
?0142                                 array    code    static      605        605
?0146                                 array    code    static      611        611
?0150                                 array    code    static      617        617
?0151                                 array    code    static      619        619
?0155                                 array    code    static      620        620
?0159                                 array    code    static      622        622
?0167                                 array    code    static      630        630
?0169                                 array    code    static      633        633      644
?0173                                 array    code    static      636        636
?0180                                 array    code    static      641        641
?0185                                 array    code    static      654        654
?0189                                 array    code    static      659        659      667
?0193                                 array    code    static      662        662
?0202                                 array    code    static      669        669
?0206                                 array    code    static      671        671
?0210                                 array    code    static      673        673
?0214                                 array    code    static      677        677
?0218                                 array    code    static      679        679
?0222                                 array    code    static      681        681
?0223                                 array    code    static      683        683
?0224                                 array    code    static      685        685
?0225                                 array    code    static      687        687
?0229                                 array    code    static      689        689
?0230                                 array    code    static      693        693      709
?0234                                 array    code    static      697        697
?0235                                 array    code    static      701        701
?0239                                 array    code    static      704        704
?0243                                 array    code    static      705        705
?0247                                 array    code    static      706        706
?0248                                 array    code    static      712        712
?0252                                 array    code    static      715        715
?0256                                 array    code    static      717        717
?0260                                 array    code    static      719        719
?0264                                 array    code    static      721        721
?0268                                 array    code    static      723        723
?0274                                 array    code    static      727        727
?0277                                 array    code    static      729        729
?0279                                 array    code    static      731        731
?0283                                 array    code    static      733        733
?0287                                 array    code    static      735        735
?0291                                 array    code    static      737        737
?0322                                 array    code    static      894        894
?0325                                 array    code    static      898        898
?0326                                 array    code    static      908        908
?0364                                 array    code    static     1320       1320
?0409                                 array    code    static     1440       1440
?0413                                 array    code    static     1442       1442
?0423                                 array    code    static     1471       1471
AC                                      bit             ---      166:1  
ACC                                     sfr             ---       14:1  
ADCON0                                  sfr             ---       99:1  
ADCON1                                  sfr             ---      100:1  
ADDATH                                  sfr             ---      101:1  
ADDATL                                  sfr             ---      102:1  
ADEX                                    bit             ---      133:1  
ADM                                     bit             ---      135:1  
ARCON                                   sfr             ---      105:1  
Append                             function    code    public     1784     115:11
AskQuestionMsg                     function    code    extern    50:18        672
B                                       sfr             ---       15:1  
BD                                      bit             ---      131:1  
BSY                                     bit             ---      134:1  
CC4EN                                   sfr             ---       34:1  
CCEN                                    sfr             ---       33:1  
CCH1                                    sfr             ---       36:1  
CCH2                                    sfr             ---       38:1  
CCH3                                    sfr             ---       40:1  
CCH4                                    sfr             ---       42:1  
CCL1                                    sfr             ---       35:1  
CCL2                                    sfr             ---       37:1  
CCL3                                    sfr             ---       39:1  
CCL4                                    sfr             ---       41:1  
CLK                                     bit             ---      132:1  
CLRMSK                                  sfr             ---       74:1  
CMEN                                    sfr             ---       43:1  
CMH0                                    sfr             ---       45:1  
CMH1                                    sfr             ---       47:1  
CMH2                                    sfr             ---       49:1  
CMH3                                    sfr             ---       51:1  
CMH4                                    sfr             ---       53:1  
CMH5                                    sfr             ---       55:1  
CMH6                                    sfr             ---       57:1  
CMH7                                    sfr             ---       59:1  
CML0                                    sfr             ---       44:1  
CML1                                    sfr             ---       46:1  
CML2                                    sfr             ---       48:1  
CML3                                    sfr             ---       50:1  
CML4                                    sfr             ---       52:1  
CML5                                    sfr             ---       54:1  
CML6                                    sfr             ---       56:1  
CML7                                    sfr             ---       58:1  
CMSEL                                   sfr             ---       60:1  
COMCLRH                                 sfr             ---       72:1  
COMCLRL                                 sfr             ---       71:1  
COMSETH                                 sfr             ---       70:1  
COMSETL                                 sfr             ---       69:1  
CRCH                                    sfr             ---       62:1  
CRCL                                    sfr             ---       61:1  
CTCON                                   sfr             ---       63:1  
CTRELH                                  sfr             ---       65:1  
CTRELL                                  sfr             ---       64:1  
CY                                      bit             ---      165:1  
CategoryHit                        function    code    extern    63:18        724      728
ClearLabelList                     function    code    public      867     118:11      905
CreateLog                          function    code    extern    42:23        618
DPH                                     sfr             ---       18:1  
DPL                                     sfr             ---       17:1  
DPSEL                                   sfr             ---       19:1  
DecodeAndPerform                   function    code    public      375        332    99:11      893
Dir                                function    code    extern    113:7        514
DispInfoBox                        function    code    extern    71:21        134      152
DisplayMenu                        function    code    extern    72:21        135
EADC                                    bit             ---      205:1  
EAL                                     bit             ---      187:1        270
ES0                                     bit             ---      190:1  
ET0                                     bit             ---      193:1        177
ET1                                     bit             ---      191:1  
ET2                                     bit             ---      189:1  
EX0                                     bit             ---      194:1  
EX1                                     bit             ---      192:1  
EX2                                     bit             ---      204:1  
EX3                                     bit             ---      203:1  
EX4                                     bit             ---      202:1  
EX5                                     bit             ---      201:1  
EX6                                     bit             ---      200:1  
EXEN2                                   bit             ---      198:1  
EXF2                                    bit             ---      143:1  
EchoMic                            function    code    extern    53:14        547
EchoPhone                          function    code    extern    54:14        552
EnterCode                          function    code    extern    51:18        621
EraseAll                           function    code    extern    109:7        474
EraseDynamic                       function    code    extern    111:7        482
ExecuteBatFile                     function    code    public      878        149      343   119:11
F0                                      bit             ---      167:1  
F1                                      bit             ---      171:1  
FindLabel                          function    code    public      982     121:11     1032     1046
GotoLabel                          function    code    public     1024        657      665      725   122:11
HangUp                             function    code    extern     81:8        588
Hello                              function    code    public     1262        462   101:11
I2FR                                    bit             ---      156:1  
I3FR                                    bit             ---      155:1  
IADC                                    bit             ---      150:1  
IE0                                     bit             ---      182:1  
IE1                                     bit             ---      180:1  
IEN0                                    sfr             ---      114:1  
IEN1                                    sfr             ---      116:1  
IEN2                                    sfr             ---      118:1  
IEX2                                    bit             ---      149:1  
IEX3                                    bit             ---      148:1  
IEX4                                    bit             ---      147:1  
IEX5                                    bit             ---      146:1  
IEX6                                    bit             ---      145:1  
INT0                                    bit             ---      214:1  
INT1                                    bit             ---      213:1  
IP0                                     sfr             ---      115:1        126
IP1                                     sfr             ---      117:1  
IRCON0                                  sfr             ---      119:1  
IRCON1                                  sfr             ---      120:1  
IT0                                     bit             ---      183:1  
IT1                                     bit             ---      181:1  
InitializeCalender                 function    code    extern     65:9        227
InitializeComputer1                function    code    public      157        132    96:11
InitializeDPot                     function    code    extern    58:10        239
InitializeDTMF                     function    code    extern    43:15        209
InitializeFileSystem               function    code    extern     84:7        197
InitializeFlash                    function    code    extern     85:7        191
InitializeKeyboard                 function    code    extern    52:22        233
InitializeLCD                      function    code    extern    65:21        185
InitializeLogFile                  function    code    extern    41:23        288
InitializePhone                    function    code    extern     80:8        215
InitializePhoneAns                 function    code    extern    46:18        282
InitializePhoneAnsApp              function    code    public      277        148    97:11
InitializeRS232                    function    code    extern    35:13        124
InitializeTimer                    function    code    extern    36:17        221
InitializeWAV                      function    code    extern    46:14        203
InsertLabel                        function    code    public      915        891   120:11     1041
IntitializeMemo                    function    code    extern    59:18        300
KillTimer                          function    code    extern    38:17        144
LiftPhone                          function    code    extern     82:8        592
LookUpCaller                       function    code    extern    58:18        682
MD0                                     sfr             ---      106:1  
MD1                                     sfr             ---      107:1  
MD2                                     sfr             ---      108:1  
MD3                                     sfr             ---      109:1  
MD4                                     sfr             ---      110:1  
MD5                                     sfr             ---      111:1  
MS_ERASEQST                         #define             ---      32:23      32:23
MS_LOG                              #define             ---      29:23      29:23
MS_MENU                             #define             ---      30:23      30:23
MS_TIMEDATE                         #define             ---      31:23      31:23
MX0                                     bit             ---      138:1  
MX1                                     bit             ---      137:1  
MX2                                     bit             ---      136:1  
MainShell                          function    code    public      308        153    98:11
MakeDTMFTones                      function    code    extern    44:15        580
OV                                      bit             ---      170:1  
P                                       bit             ---      172:1  
P0                                      sfr             ---       77:1  
P1                                      sfr             ---       78:1  
P2                                      sfr             ---       79:1  
P3                                      sfr             ---       80:1        608      614      716      718
                                                                              720      722
P4                                      sfr             ---       81:1  
P5                                      sfr             ---       82:1  
P6                                      sfr             ---       83:1  
P7                                      sfr             ---       84:1  
P8                                      sfr             ---       85:1  
PCON                                    sfr             ---       88:1  
PSW                                     sfr             ---       20:1  
PlayFile                           function    code    extern    52:14        576
PlayMemo                           function    code    extern    61:18        734
PlayNewMessages                    function    code    extern    49:23        674
RB80                                    bit             ---      225:1  
RD                                      bit             ---      209:1  
REN0                                    bit             ---      223:1  
RI0                                     bit             ---      227:1  
RS0                                     bit             ---      169:1  
RS1                                     bit             ---      168:1  
RXD                                     bit             ---      216:1  
ReadCalenderByte                   function    code    extern     69:9        626
ReadDPWiper                        function    code    extern    63:10        708
ReadPhoneBookFile                  function    code    extern    57:18        680
RecMicFile                         function    code    extern    49:14        557
RecPhoneFile                       function    code    extern    50:14        562
ReceiveLineRS232                   function    code    extern    41:13        319
RecordCallerMessage                function    code    extern    49:18        670
RecordMemo                         function    code    extern    60:18        736
ResetDTMFIndex                     function    code    extern    47:15        676
S0BUF                                   sfr             ---       90:1  
S0CON                                   sfr             ---       89:1  
S0RELH                                  sfr             ---       94:1  
S0RELL                                  sfr             ---       93:1  
S1BUF                                   sfr             ---       92:1  
S1CON                                   sfr             ---       91:1        140      146      151
S1RELH                                  sfr             ---       96:1  
S1RELL                                  sfr             ---       95:1  
SETMSK                                  sfr             ---       73:1  
SM0                                     bit             ---      220:1  
SM1                                     bit             ---      221:1  
SM20                                    bit             ---      222:1  
SP                                      sfr             ---       16:1  
SWDT                                    bit             ---      199:1        142      937      989     1038
SYSCON                                  sfr             ---       22:1  
SendRS232                          function    code    extern    36:13        315      686
SendStringEOLRS232                 function    code    extern    38:13        127      129      137      147
                                                                              184      190      196      202
                                                                              208      214      220      226
                                                                              232      238      281      287
                                                                              293      299      346      362
                                                                              619      628      630      633
                                                                              641      644      659      667
                                                                              684      687      695      703
                                                                              711      714      729      731
                                                                              888      894      900      908
                                                                             1320
SendStringRS232                    function    code    extern    37:13        360      683      685      693
                                                                              701      709      712      898
SetDPWiper                         function    code    extern    62:10        692
SetupBatFile                       function    code    public      798        294   117:11
StartDynamic                       function    code    extern    110:7        478
StartTimer                         function    code    extern    37:17        139
T0                                      bit             ---      212:1  
T0_int                             function    code    public     1813      234:1
T1                                      bit             ---      211:1  
T2CM                                    bit             ---      159:1  
T2CON                                   sfr             ---       68:1  
T2I0                                    bit             ---      161:1  
T2I1                                    bit             ---      160:1  
T2PS                                    bit             ---      154:1  
T2R0                                    bit             ---      158:1  
T2R1                                    bit             ---      157:1  
TB80                                    bit             ---      224:1  
TCON                                    sfr             ---       25:1  
TF0                                     bit             ---      178:1  
TF1                                     bit             ---      176:1  
TF2                                     bit             ---      144:1  
TH0                                     sfr             ---       29:1  
TH1                                     sfr             ---       30:1  
TH2                                     sfr             ---       67:1  
TI0                                     bit             ---      226:1  
TL0                                     sfr             ---       27:1  
TL1                                     sfr             ---       28:1  
TL2                                     sfr             ---       66:1  
TMOD                                    sfr             ---       26:1        175
TR0                                     bit             ---      179:1        176     1815
TR1                                     bit             ---      177:1  
TXD                                     bit             ---      215:1  
TimedOut                           function    code    extern    39:17        140
Type                               function    code    extern    114:7        538
TypeA                              function    code    extern    115:7        542
WDT                                     bit             ---      188:1        141      936      988     1037
WDTREL                                  sfr             ---      124:1        161
WR                                      bit             ---      210:1  
WaitFor                            function    code    extern    40:17        603
WaitForCall                        function    code    extern    47:18        678
WavTone                            function    code    extern    56:14        571
WriteCalenderByte                  function    code    extern     68:9        483      484      609      615
                                                                              640      700      741
XPAGE                                   sfr             ---       21:1  
answerOn                               char   xdata    extern       78        607      609      613      615
batFilePtr                          pointer   xdata    public       91        656      664      801      882
                                                                              883      883      887      891
                                                                              906      907     1039     1041
                                                                             1050     1050     1058
batLabelName                          array   xdata    public       92        872      925      946      986
batLabelPos                           array   xdata    public       93        804      871      925      944
                                                                              947      960      986      991
                                                                             1058
callerCategory                         char   xdata    extern       79        665      724
commandLine                           array   xdata    public       83        333      334      335      336
                                                                              337      338      339      343
                                                                              429      447      460      472
                                                                              476      480      512      536
                                                                              540      544      549      554
                                                                              557      559      562      569
                                                                              573      576      578      580
                                                                              586      590      600      602
                                                                              605      611      617      620
                                                                              622      624      636      637
                                                                              638      654      657      662
                                                                              665      665      669      671
                                                                              673      677      679      681
                                                                              682      689      690      691
                                                                              697      698      704      705
                                                                              706      707      715      717
                                                                              719      721      723      724
                                                                              725      727      728      728
                                                                              733      735      737      738
div_t                                struct           typedef     38:3       96:3
error                                   int   xdata    public       88        243      359      361      363
                                                                              897      899      901      941
                                                                              973     1043     1052
fSetPos                            function    code    extern    107:7       1058
fclose                             function    code    extern    104:7        342      906
fdownLoad                          function    code    extern    103:7        322
fgetLine                           function    code    extern    102:7        887     1039
fopen                              function    code    extern     96:7        339      882
ftell                              function    code    extern    105:7        883      891     1041     1050
fupLoad                            function    code    extern    100:7        325
lastPlayed                              int   xdata    extern       73        485
ldiv_t                               struct           typedef     44:3      100:3
main                               function    code    public      118  
msg                                   array   xdata    public       89        361      362      627      628
                                                                              694      695      702      703
                                                                              710      711      713      714
                                                                              899      900
myInt2DecStr                       function    code    public     1432        694      702      710      713
                                                                           127:11
myInt2DecStr00                     function    code    public     1465     128:11
myLong2HexStr                      function    code    public     1396        361      627      899   126:11
myStr2Int                          function    code    public     1484        602      624      637      638
                                                                              665      690      691      698
                                                                              707      728      738   129:11
myStrCmpNoCase                     function    code    public     1383        460      472      476      480
                                                                              512      536      540      544
                                                                              549      554      559      569
                                                                              573      578      586      590
                                                                              600      605      611      617
                                                                              620      622      636      654
                                                                              662      669      671      673
                                                                              677      679      681      689
                                                                              697      704      705      706
                                                                              715      717      719      721
                                                                              723      727      733      735
                                                                              737      925      986   130:11
myStrCpy                           function    code    public     1349        429      946   124:11     1440
                                                                             1442     1471
myStrLen                           function    code    public     1360        333   125:11
nrCommandParameters                     int   xdata    public       86        390      443
numSignals                             char   xdata    extern       80        740      741
receivedDTMF                           char   xdata    extern       74        546      551      556      561
                                                                              575      675
speakerVolume                          char   xdata    extern       81        699      700
strtok                             function    code    extern     72:4        427      431      922
timeout                                char   xdata    public       90        178     1814


Errors: none
Warnings: none
Code size: 6770
Constant size: 1123
Static variable size: Data(0) Idata(0) Bit(0) Xdata(1260) Pdata(0) Bdata(0)


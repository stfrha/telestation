##############################################################################
#                                                                            #
# IAR 8051 C-Compiler V5.20A/386                                             #
# Front End V4.20N                                       11/Sep/100  09:47:58 #
# Global Optimizer V1.04E                                                    #
#                                                                            #
#       Target option =  8051                                                #
#       Memory model  =  tiny                                                #
#       Source file   =  f:\supercomputer\mjukvara\8051\newprogramccode\program.c#
#       List file     =  f:\supercomputer\mjukvara\8051\newprogramccode\release\list\program.lst#
#       Object file   =  f:\supercomputer\mjukvara\8051\newprogramccode\release\obj\program.r03#
#       Command line  =  -v0 -mt                                             #
#                        -OF:\SuperComputer\Mjukvara\8051\NewProgramCCode\Release\Obj\ #
#                        -e -K -gA -z9 -RCODE                                #
#                        -LF:\SuperComputer\Mjukvara\8051\NewProgramCCode\Release\List\ #
#                        -q -i -t8 -ID:\IAR\EW\8051\inc\                     #
#                        F:\SuperComputer\Mjukvara\8051\NewProgramCCode\Program.c #
#                                                                            #
#                                             (c) Copyright IAR Systems 1996 #
##############################################################################

   \   0000                    NAME    program(16)
   \   0000                    RSEG    CODE(0)
   \   0000                    RSEG    CSTR(0)
   \   0000                    PUBLIC  InitializeRS232
   \   0000                    $DEFFN  InitializeRS232(0,0,0,0,32768,0,0,0)
   \   0000                    PUBLIC  SendBackAll
   \   0000                    $DEFFN  SendBackAll(0,0,0,0,32768,0,0,0)
   \   0000                    PUBLIC  SendRS232
   \   0000                    $DEFFN  SendRS232(0,0,0,0,32769,0,0,0)
   \   0000                    PUBLIC  SendStringEOLRS232
   \   0000                    $DEFFN  SendStringEOLRS232(4,0,0,0,32771,0,0,0),SendRS232,SendRS232,SendRS232
   \   0000                    PUBLIC  SendStringRS232
   \   0000                    $DEFFN  SendStringRS232(4,0,0,0,32771,0,0,0),SendRS232
   \   0000                    PUBLIC  WaitAndReceiveRS232
   \   0000                    $DEFFN  WaitAndReceiveRS232(1,0,0,0,32768,0,0,0)
   \   0000                    PUBLIC  main
   \   0000                    $DEFFN  main(1,0,0,0,32768,0,0,0),InitializeRS232,SendStringEOLRS232,SendStringEOLRS232,
   \   0000                            WaitAndReceiveRS232,SendStringEOLRS232,programmLowMem,SendStringEOLRS232,
   \   0000                            SendStringEOLRS232
   \   0000                    PUBLIC  programmLowMem
   \   0000                    $DEFFN  programmLowMem(76,0,0,0,32768,0,0,0),SendRS232,WaitAndReceiveRS232,
   \   0000                            WaitAndReceiveRS232,WaitAndReceiveRS232,WaitAndReceiveRS232,WaitAndReceiveRS232,
   \   0000                            WaitAndReceiveRS232,SendRS232,SendRS232,SendRS232,SendStringRS232
   \   0000                    EXTERN  ?STRLEN_R567_L08
   \   0000                    EXTERN  ?LD_A_R567_DISP_L17
   \   0000                    EXTERN  ?CL8051T_5_20_L17
   \   0000                    RSEG    CODE
      1          /*************************************************************
      2          Fil:            Program.c
      3          
      4          Beskrivning:    Självständig applikation för att programmera 
      5                          det låga programminnet. Körs genom att PLD 
      6                          ställs in för programmering genom en strapp 
      7                          (ev en switch på "burken").
      8          
      9          Skapad:         99-09-19
     10          
     11          Ägare:          Fredrik Hoffman
     12          *************************************************************/
     13          
     14          //////////////////////
     15          //Externa definitioner
     16          
     17          #include <io517a.h>
      1          /*                     - IO517A.H -
      2          
      3             Special header for the Siemens SAB 80C517A/83C517A-5 processors.
      4          
      5             Version 5.20 [IMAF]
      6          
      7          */
      8          
      9          #pragma language=extended
     10          
     11          /* Pre-defined SFR byte addresses: */
     12          
     13          /* CPU */
     14          sfr     ACC    = 0xE0;
     15          sfr     B      = 0xF0;
     16          sfr     SP     = 0x81;
     17          sfr     DPL    = 0x82;
     18          sfr     DPH    = 0x83;
     19          sfr     DPSEL  = 0x92;
     20          sfr     PSW    = 0xD0;
     21          sfr     XPAGE  = 0x91;
     22          sfr     SYSCON = 0xB1;
     23          
     24          /* Timer 0/Timer 1 */
     25          sfr     TCON   = 0x88;
     26          sfr     TMOD   = 0x89;
     27          sfr     TL0    = 0x8A;
     28          sfr     TL1    = 0x8B;
     29          sfr     TH0    = 0x8C;
     30          sfr     TH1    = 0x8D;
     31          
     32          /* CCU */
     33          sfr     CCEN   = 0xC1;
     34          sfr     CC4EN  = 0xC9;
     35          sfr     CCL1   = 0xC2;
     36          sfr     CCH1   = 0xC3;
     37          sfr     CCL2   = 0xC4;
     38          sfr     CCH2   = 0xC5;
     39          sfr     CCL3   = 0xC6;
     40          sfr     CCH3   = 0xC7;
     41          sfr     CCL4   = 0xCE;
     42          sfr     CCH4   = 0xCF;
     43          sfr     CMEN   = 0xF6;
     44          sfr     CML0   = 0xD2;
     45          sfr     CMH0   = 0xD3;
     46          sfr     CML1   = 0xD4;
     47          sfr     CMH1   = 0xD5;
     48          sfr     CML2   = 0xD6;
     49          sfr     CMH2   = 0xD7;
     50          sfr     CML3   = 0xE2;
     51          sfr     CMH3   = 0xE3;
     52          sfr     CML4   = 0xE4;
     53          sfr     CMH4   = 0xE5;
     54          sfr     CML5   = 0xE6;
     55          sfr     CMH5   = 0xE7;
     56          sfr     CML6   = 0xF2;
     57          sfr     CMH6   = 0xF3;
     58          sfr     CML7   = 0xF4;
     59          sfr     CMH7   = 0xF5;
     60          sfr     CMSEL  = 0xF7;
     61          sfr     CRCL   = 0xCA;
     62          sfr     CRCH   = 0xCB;
     63          sfr     CTCON  = 0xE1;
     64          sfr     CTRELL = 0xDE;
     65          sfr     CTRELH = 0xDF;
     66          sfr     TL2    = 0xCC;
     67          sfr     TH2    = 0xCD;
     68          sfr     T2CON  = 0xC8;
     69          sfr     COMSETL= 0xA1;
     70          sfr     COMSETH= 0xA2;
     71          sfr     COMCLRL= 0xA3;
     72          sfr     COMCLRH= 0xA4;
     73          sfr     SETMSK = 0xA5;
     74          sfr     CLRMSK = 0xA6;
     75          
     76          /* Ports */
     77          sfr     P0     = 0x80;
     78          sfr     P1     = 0x90;
     79          sfr     P2     = 0xA0;
     80          sfr     P3     = 0xB0;
     81          sfr     P4     = 0xE8;
     82          sfr     P5     = 0xF8;
     83          sfr     P6     = 0xFA;
     84          sfr     P7     = 0xDB;        /* Analog/Digital Input */
     85          sfr     P8     = 0xDD;        /* Analog/Digital Input, 4 Bit */
     86          
     87          /* Serial Channels */
     88          sfr     PCON   = 0x87;
     89          sfr     S0CON  = 0x98;
     90          sfr     S0BUF  = 0x99;
     91          sfr     S1CON  = 0x9B;
     92          sfr     S1BUF  = 0x9C;
     93          sfr     S0RELL = 0xAA;
     94          sfr     S0RELH = 0xBA;
     95          sfr     S1RELL = 0x9D;
     96          sfr     S1RELH = 0xBB;
     97          
     98          /* A/D Converter */
     99          sfr     ADCON0 = 0xD8;
    100          sfr     ADCON1 = 0xDC;
    101          sfr     ADDATH = 0xD9;
    102          sfr     ADDATL = 0xDA;
    103          
    104          /* MUL/DIV Unit */
    105          sfr     ARCON  = 0xEF;
    106          sfr     MD0    = 0xE9;
    107          sfr     MD1    = 0xEA;
    108          sfr     MD2    = 0xEB;
    109          sfr     MD3    = 0xEC;
    110          sfr     MD4    = 0xED;
    111          sfr     MD5    = 0xEE;
    112          
    113          /* Interrupt System */
    114          sfr     IEN0   = 0xA8;
    115          sfr     IP0    = 0xA9;
    116          sfr     IEN1   = 0xB8;
    117          sfr     IP1    = 0xB9;
    118          sfr     IEN2   = 0x9A;
    119          sfr     IRCON0 = 0xC0;
    120          sfr     IRCON1 = 0xD1;
    121          
    122          
    123          /* Watchdog */
    124          sfr     WDTREL = 0x86;
    125          
    126          
    127          /* Pre-defined SFR bit addresses */
    128          
    129          /*========ADCON0=======*/
    130          
    131          bit     BD     = 0xDF;
    132          bit     CLK    = 0xDE;
    133          bit     ADEX   = 0xDD;
    134          bit     BSY    = 0xDC;
    135          bit     ADM    = 0xDB;
    136          bit     MX2    = 0xDA;
    137          bit     MX1    = 0xD9;
    138          bit     MX0    = 0xD8;
    139          
    140          
    141          /*========IRCON0=======*/
    142          
    143          bit     EXF2   = 0xC7;
    144          bit     TF2    = 0xC6;
    145          bit     IEX6   = 0xC5;
    146          bit     IEX5   = 0xC4;
    147          bit     IEX4   = 0xC3;
    148          bit     IEX3   = 0xC2;
    149          bit     IEX2   = 0xC1;
    150          bit     IADC   = 0xC0;
    151          
    152          /*========T2CON=======*/
    153          
    154          bit     T2PS   = 0xCF;
    155          bit     I3FR   = 0xCE;
    156          bit     I2FR   = 0xCD;
    157          bit     T2R1   = 0xCC;
    158          bit     T2R0   = 0xCB;
    159          bit     T2CM   = 0xCA;
    160          bit     T2I1   = 0xC9;
    161          bit     T2I0   = 0xC8;
    162          
    163          /*========PSW=========*/
    164          
    165          bit     CY     = 0xD7;
    166          bit     AC     = 0xD6;
    167          bit     F0     = 0xD5;
    168          bit     RS1    = 0xD4;
    169          bit     RS0    = 0xD3;
    170          bit     OV     = 0xD2;
    171          bit     F1     = 0xD1;
    172          bit     P      = 0xD0;
    173          
    174          /*========TCON========*/
    175          
    176          bit     TF1    = 0x8F;
    177          bit     TR1    = 0x8E;
    178          bit     TF0    = 0x8D;
    179          bit     TR0    = 0x8C;
    180          bit     IE1    = 0x8B;
    181          bit     IT1    = 0x8A;
    182          bit     IE0    = 0x89;
    183          bit     IT0    = 0x88;
    184          
    185          /*========IEN0========*/
    186          
    187          bit     EAL    = 0xAF;
    188          bit     WDT    = 0xAE;
    189          bit     ET2    = 0xAD;
    190          bit     ES0    = 0xAC;
    191          bit     ET1    = 0xAB;
    192          bit     EX1    = 0xAA;
    193          bit     ET0    = 0xA9;
    194          bit     EX0    = 0xA8;
    195          
    196          /*========IEN1========*/
    197          
    198          bit     EXEN2  = 0xBF;
    199          bit     SWDT   = 0xBE;
    200          bit     EX6    = 0xBD;
    201          bit     EX5    = 0xBC;
    202          bit     EX4    = 0xBB;
    203          bit     EX3    = 0xBA;
    204          bit     EX2    = 0xB9;
    205          bit     EADC   = 0xB8;
    206          
    207          /*========P3=========*/
    208          
    209          bit     RD     = 0xB7;
    210          bit     WR     = 0xB6;
    211          bit     T1     = 0xB5;
    212          bit     T0     = 0xB4;
    213          bit     INT1   = 0xB3;
    214          bit     INT0   = 0xB2;
    215          bit     TXD    = 0xB1;
    216          bit     RXD    = 0xB0;
    217          
    218          /*========S0CON========*/
    219          
    220          bit     SM0    = 0x9F;
    221          bit     SM1    = 0x9E;
    222          bit     SM20   = 0x9D;
    223          bit     REN0   = 0x9C;
    224          bit     TB80   = 0x9B;
    225          bit     RB80   = 0x9A;
    226          bit     TI0    = 0x99;
    227          bit     RI0    = 0x98;
    228          
    229          
    230          /* Interrupt Vector Definitions */
    231          
    232          interrupt [0x03] void EX0_int (void);     /* External Interrupt 0 */
    233          
    234          interrupt [0x0B] void T0_int (void);      /* Timer 0 Overflow */
    235          
    236          interrupt [0x13] void EX1_int (void);     /* External Interrupt 1 */
    237          
    238          interrupt [0x1B] void T1_int (void);      /* Timer 1 Overflow */
    239          
    240          interrupt [0x23] void SCON0_int (void);   /* Serial Port 0 */
    241          
    242          interrupt [0x2B] void T2_int (void);      /* Timer 2 Overflow */
    243          
    244          interrupt [0x2B] void T2EX_int (void);    /* Negative Transition on T2EX */
    245          
    246          interrupt [0x43] void ADC_int (void);     /* ADC Interrupt */
    247          
    248          interrupt [0x4B] void EX2_int (void);     /* External Interrupt 2 */
    249          
    250          interrupt [0x53] void EX3_int (void);     /* External Interrupt 3 */
    251          
    252          interrupt [0x5B] void EX4_int (void);     /* External Interrupt 4 */
    253          
    254          interrupt [0x63] void EX5_int (void);     /* External Interrupt 5 */
    255          
    256          interrupt [0x6B] void EX6_int (void);     /* External Interrupt 6 */
    257          
    258          interrupt [0x83] void SCON1_int (void);   /* Serial Port 1 */
    259          
    260          interrupt [0x93] void ICMP_int (void);    /* Compare match interrupt */
    261          
    262          interrupt [0x9B] void CT_int (void);      /* Compare Timer Overflow */
    263          
    264          interrupt [0xA3] void ICS_int (void);     /* COMSET interrupt */
    265          
    266          interrupt [0xAB] void ICR_int (void);     /* COMCLR interrupt */
    267          
    268          
     18          #include <stdio.h> 
      1          /*                      - STDIO.H -
      2          
      3             Subset of ANSI standard I/O function declarations.
      4          
      5             Version: 3.30 04/Nov/94 IHAW
      6          
      7          
      8          */
      9          
     10          #ifndef _STDIO_INCLUDED
     11          #define _STDIO_INCLUDED
     12          
     13          #ifndef NULL
     14          #define NULL    (void *) 0
     15          #endif
     16          
     17          #ifndef EOF
     18          #define EOF     (-1)
     19          #endif
     20          
     21          #ifndef size_t
     22          #if     sizeof((char*)0 - (char*)0) <= sizeof(int)
     23          #define size_t  unsigned int
     24          #else
     25          #define size_t  unsigned long 
     26          #endif
     27          #endif
     28          
     29          /* ===
     30          
     31          #if __TID__ & 0x8000
     32          #pragma function=intrinsic(0)
     33          #endif
     34          
     35          === */
     36          
     37          #ifndef MEMORY_ATTRIBUTE
     38          #define MEMORY_ATTRIBUTE
     39          #endif
     40          
     41          MEMORY_ATTRIBUTE int    puts(const char *__s);
     42          MEMORY_ATTRIBUTE int    putchar(int __value);
     43          MEMORY_ATTRIBUTE int    getchar(void);
     44          MEMORY_ATTRIBUTE int    sprintf(char *__s,const char *__format,...);
     45          MEMORY_ATTRIBUTE int    printf(const char *__format,...);
     46          MEMORY_ATTRIBUTE int    scanf(const char *__format,...);
     47          MEMORY_ATTRIBUTE int    sscanf(const char *__s, const char *__format,...);
     48          MEMORY_ATTRIBUTE char   *gets(char *__s);
     49          
     50          #if __TID__ & 0x8000
     51          #pragma function=default
     52          #endif
     53          
     54          #endif
     55          
     56          
     57          
     19          #include <string.h> 
      1          /*                       - STRING.H -
      2          
      3             The ANSI 'string' function declarations.
      4                     
      5             Version: 3.30 04/Nov/94 IHAW
      6                             
      7          */
      8          
      9          #ifndef _STRING_INCLUDED
     10          #define _STRING_INCLUDED
     11          
     12          #ifndef NULL
     13          #define NULL    (void*)0     /* changed from char* 93.01.21 ICLM */
     14          #endif
     15          
     16          #ifndef size_t
     17          #if sizeof((char *)0 - (char *)0) <= sizeof(int)
     18          #define size_t          unsigned int
     19          #else
     20          #define size_t          unsigned long
     21          #endif
     22          #endif
     23          
     24          #if __TID__ & 0x8000
     25          #pragma function=intrinsic(0)
     26          #endif
     27          
     28          #ifndef MEMORY_ATTRIBUTE
     29          #define MEMORY_ATTRIBUTE
     30          #endif
     31          
     32          MEMORY_ATTRIBUTE void *memcpy(void *s1, const void *s2, size_t n);
     33          
     34          MEMORY_ATTRIBUTE void *memmove(void *s1, const void *s2, size_t n);
     35          
     36          MEMORY_ATTRIBUTE void *memchr(const void *s, int c, size_t n);
     37          
     38          MEMORY_ATTRIBUTE void *memset(void *s, int c, size_t n);
     39          
     40          MEMORY_ATTRIBUTE int memcmp(const void *s1, const void *s2, size_t n);
     41          
     42          MEMORY_ATTRIBUTE char *strchr(const char *s, int c);
     43          
     44          MEMORY_ATTRIBUTE int strcmp(const char *s1, const char *s2);
     45          
     46          MEMORY_ATTRIBUTE int strncmp(const char *s1, const char *s2, size_t n);
     47          
     48          MEMORY_ATTRIBUTE int strcoll(const char *s1, const char *s2);
     49          
     50          MEMORY_ATTRIBUTE size_t strlen(const char *s);
     51          
     52          MEMORY_ATTRIBUTE size_t strcspn(const char *s1, const char *s2);
     53          
     54          MEMORY_ATTRIBUTE size_t strspn(const char *s1, const char *s2);
     55          
     56          MEMORY_ATTRIBUTE char *strpbrk(const char *s1, const char *s2);
     57          
     58          MEMORY_ATTRIBUTE char *strrchr(const char *s, int c);
     59          
     60          MEMORY_ATTRIBUTE char *strstr(const char *s1, const char *s2);
     61          
     62          MEMORY_ATTRIBUTE char *strcat(char *s1, const char *s2);
     63          
     64          MEMORY_ATTRIBUTE char *strncat(char *s1, const char *s2, size_t n);
     65          
     66          MEMORY_ATTRIBUTE char *strcpy(char *s1, const char *s2);
     67          
     68          MEMORY_ATTRIBUTE char *strncpy(char *s1, const char *s2, size_t n);
     69          
     70          MEMORY_ATTRIBUTE char *strerror(int errnum);
     71          
     72          MEMORY_ATTRIBUTE char *strtok(char *s1, const char *s2);
     73          
     74          MEMORY_ATTRIBUTE size_t strxfrm(char *s1, const char *s2, size_t n);
     75          
     76          #if __TID__ & 0x8000
     77          #pragma function=default
     78          #endif
     79          
     80          #endif
     81          
     82          
     20          
     21          //////////////////////
     22          //Interna definitioner
     23          
     24          ///////////////////////////////////
     25          //Externa funktioner och procedurer
     26          
     27          
     28          ///////////////////////////
     29          //Externa globala variabler
     30                                     
     31                                     
     32          ///////////////////////////////////
     33          //Interna funktioner och procedurer
     34          void    InitializeRS232( void );
     35          void    SendStringRS232(const char *str);
     36          void    SendStringEOLRS232(const char *str);
     37          char    WaitAndReceiveRS232( void );
     38          void    SendRS232(char tecken);
     39          
     40          void    programmLowMem ( void );
     41          void    SendBackAll( void );
     42           
     43          ///////////////////////////
     44          //Interna globala variabler
     45                                     
     46          //////////////////////////
     47          //Interna lokala variabler
     48                                     
     49          
     50          void main( void )
     51          {
   \   0000            main:
     52              char    c;
     53          
     54              InitializeRS232();
   \   0000  120000            LCALL   $REFFN InitializeRS232
     55          
     56              if ((IP0 & 1<<6) == 0) {
   \   0003  E5A9              MOV     A,169
   \   0005  20E60B            JB      ACC.6,?0001
   \   0008            ?0000:
     57                  SendStringEOLRS232("The SuperComputer Programmer and FRHA welcomes you, ver2");
   \   0008  7D00              MOV     R5,#LOW(?0002)
   \   000A  7E00              MOV     R6,#HIGH(?0002)
   \   000C  7F02              MOV     R7,#2
   \   000E  120000            LCALL   $REFFN SendStringEOLRS232
     58              } else {
   \   0011  8009              SJMP    ?0003
   \   0013            ?0001:
     59                  SendStringEOLRS232("Dogged!!!!!");
   \   0013  7D39              MOV     R5,#LOW(?0004)
   \   0015  7E00              MOV     R6,#HIGH(?0004)
   \   0017  7F02              MOV     R7,#2
   \   0019  120000            LCALL   $REFFN SendStringEOLRS232
   \   001C            ?0003:
     60              }
     61              
     62              P4.6 = 0;            //ROM0 default
   \   001C  C2EE              CLR     232.6
   \   001E            ?0006:
     63              
     64              while (1) {
     65                  c = WaitAndReceiveRS232();
   \   001E  120000            LCALL   $REFFN WaitAndReceiveRS232
     66                  switch (c) {
   \   0021  8C00              MOV     $LOCBD main,R4
   \   0023  EC                MOV     A,R4
   \   0024  B4480B            CJNE    A,#72,?0011
   \   0027            ?0009:
     67                  case 'H' :
     68                      SendStringEOLRS232("Hello from the SuperComputer programmer!");
   \   0027  7D45              MOV     R5,#LOW(?0010)
   \   0029  7E00              MOV     R6,#HIGH(?0010)
   \   002B  7F02              MOV     R7,#2
   \   002D  120000            LCALL   $REFFN SendStringEOLRS232
     69                      break;
   \   0030  802D              SJMP    ?0008
   \   0032            ?0011:
   \   0032  B45005            CJNE    A,#80,?0012
     70                  case 'P' :
     71                      programmLowMem();
   \   0035  120000            LCALL   $REFFN programmLowMem
     72                      break;
   \   0038  8025              SJMP    ?0008
   \   003A            ?0012:
   \   003A  B4300D            CJNE    A,#48,?0014
     73                  case '0' :
     74                      P4.6 = 0;                    //Väljer ROM0
   \   003D  C2EE              CLR     232.6
     75                      SendStringEOLRS232("ROM 0 selected");
   \   003F  7D6E              MOV     R5,#LOW(?0013)
   \   0041  7E00              MOV     R6,#HIGH(?0013)
   \   0043  7F02              MOV     R7,#2
   \   0045  120000            LCALL   $REFFN SendStringEOLRS232
     76                      break;
   \   0048  8015              SJMP    ?0008
   \   004A            ?0014:
   \   004A  B4310D            CJNE    A,#49,?0016
     77                  case '1' :
     78                      P4.6 = 1;                    //Väljer ROM1
   \   004D  D2EE              SETB    232.6
     79                      SendStringEOLRS232("ROM 1 selected");
   \   004F  7D7D              MOV     R5,#LOW(?0015)
   \   0051  7E00              MOV     R6,#HIGH(?0015)
   \   0053  7F02              MOV     R7,#2
   \   0055  120000            LCALL   $REFFN SendStringEOLRS232
     80                      break;
   \   0058  8005              SJMP    ?0008
   \   005A            ?0016:
   \   005A  B45602            CJNE    A,#86,?0008
     81                  case 'V' :
     82          //            SendBackAll();
     83                      break;
   \   005D  8000              SJMP    ?0008
   \   005F            ?0008:
     84                  }
     85              }
     86          }    
   \   005F  80BD              SJMP    ?0006
     87              
     88              
     89          
     90          void    InitializeRS232( void )
     91          {
   \   0061            InitializeRS232:
     92              EAL = 0;                                                //Stänger av alla avbrott
   \   0061  C2AF              CLR     IE.7
     93              
     94              S1CON = 0x98;                                //Ställer in mode B = 8-bit UART, nollar flaggor och enablar mottagning
   \   0063  759B98            MOV     155,#152
     95              S1RELH = 0x03;                                //Ställer in baudrate 19200 bytes/s                                
   \   0066  75BB03            MOV     187,#3
     96              S1RELL = 0xEE;
   \   0069  759DEE            MOV     157,#238
     97              ADCON0 = 0x80;                                //Startar baudrate generering
   \   006C  75D880            MOV     216,#128
     98          }    
   \   006F  22                RET
     99          
    100          
    101          void    SendStringRS232(const char *str)
    102          //Skickar en 0-terminerad sträng på RS232 porten.
    103          {
   \   0070            SendStringRS232:
    104              int   i, l;
    105              
    106              l = strlen(str);
   \   0070  8D00              MOV     $LOCBD SendStringRS232+6,R5
   \   0072  8E00              MOV     $LOCBD SendStringRS232+5,R6
   \   0074  8F00              MOV     $LOCBD SendStringRS232+4,R7
   \   0076  120000            LCALL   ?STRLEN_R567_L08
   \   0079  8E00              MOV     $LOCBD SendStringRS232+3,R6
   \   007B  8F00              MOV     $LOCBD SendStringRS232+2,R7
    107              for (i = 0 ; i < l ; i++) {
   \   007D  E4                CLR     A
   \   007E  F500              MOV     $LOCBD SendStringRS232+1,A
   \   0080  F500              MOV     $LOCBD SendStringRS232,A
   \   0082            ?0018:
   \   0082  E500              MOV     A,$LOCBD SendStringRS232+1
   \   0084  C3                CLR     C
   \   0085  9500              SUBB    A,$LOCBD SendStringRS232+3
   \   0087  E500              MOV     A,$LOCBD SendStringRS232+2
   \   0089  6480              XRL     A,#128
   \   008B  FA                MOV     R2,A
   \   008C  E500              MOV     A,$LOCBD SendStringRS232
   \   008E  6480              XRL     A,#128
   \   0090  9A                SUBB    A,R2
   \   0091  5021              JNC     ?0017
   \   0093            ?0019:
    108                  SendRS232(*(str + i));                          //Sänder tecken     
   \   0093  AD00              MOV     R5,$LOCBD SendStringRS232+6
   \   0095  AE00              MOV     R6,$LOCBD SendStringRS232+5
   \   0097  AF00              MOV     R7,$LOCBD SendStringRS232+4
   \   0099  850082            MOV     DPL,$LOCBD SendStringRS232+1
   \   009C  850083            MOV     DPH,$LOCBD SendStringRS232
   \   009F  120000            LCALL   ?LD_A_R567_DISP_L17
   \   00A2  FC                MOV     R4,A
   \   00A3  120000            LCALL   $REFFN SendRS232
    109                  WDT = 1;
   \   00A6  D2AE              SETB    IE.6
    110                  SWDT = 1;
   \   00A8  D2BE              SETB    IP.6
   \   00AA  0500              INC     $LOCBD SendStringRS232+1
   \   00AC  E500              MOV     A,$LOCBD SendStringRS232+1
   \   00AE  7002              JNZ     ?0054
   \   00B0  0500              INC     $LOCBD SendStringRS232
   \   00B2            ?0054:
    111              }
    112          }        
   \   00B2  80CE              SJMP    ?0018
   \   00B4            ?0017:
   \   00B4  22                RET
    113          
    114          void    SendStringEOLRS232(const char *str)
    115          //Skickar en 0-terminerad sträng på RS232 porten med "Carrige Return" och "Line Feed" efterråt.
    116          {
   \   00B5            SendStringEOLRS232:
    117              int   i, l;
    118                                                                  
    119              l = strlen(str);                                    //Längden på strängen
   \   00B5  8D00              MOV     $LOCBD SendStringEOLRS232+6,R5
   \   00B7  8E00              MOV     $LOCBD SendStringEOLRS232+5,R6
   \   00B9  8F00              MOV     $LOCBD SendStringEOLRS232+4,R7
   \   00BB  120000            LCALL   ?STRLEN_R567_L08
   \   00BE  8E00              MOV     $LOCBD SendStringEOLRS232+3,R6
   \   00C0  8F00              MOV     $LOCBD SendStringEOLRS232+2,R7
    120              for (i = 0 ; i < l ; i++) {
   \   00C2  E4                CLR     A
   \   00C3  F500              MOV     $LOCBD SendStringEOLRS232+1,A
   \   00C5  F500              MOV     $LOCBD SendStringEOLRS232,A
   \   00C7            ?0022:
   \   00C7  E500              MOV     A,$LOCBD SendStringEOLRS232+1
   \   00C9  C3                CLR     C
   \   00CA  9500              SUBB    A,$LOCBD SendStringEOLRS232+3
   \   00CC  E500              MOV     A,$LOCBD SendStringEOLRS232+2
   \   00CE  6480              XRL     A,#128
   \   00D0  FA                MOV     R2,A
   \   00D1  E500              MOV     A,$LOCBD SendStringEOLRS232
   \   00D3  6480              XRL     A,#128
   \   00D5  9A                SUBB    A,R2
   \   00D6  5021              JNC     ?0021
   \   00D8            ?0023:
    121                  SendRS232(*(str + i));                          //Sänder tecken     
   \   00D8  AD00              MOV     R5,$LOCBD SendStringEOLRS232+6
   \   00DA  AE00              MOV     R6,$LOCBD SendStringEOLRS232+5
   \   00DC  AF00              MOV     R7,$LOCBD SendStringEOLRS232+4
   \   00DE  850082            MOV     DPL,$LOCBD SendStringEOLRS232+1
   \   00E1  850083            MOV     DPH,$LOCBD SendStringEOLRS232
   \   00E4  120000            LCALL   ?LD_A_R567_DISP_L17
   \   00E7  FC                MOV     R4,A
   \   00E8  120000            LCALL   $REFFN SendRS232
    122                  WDT = 1;
   \   00EB  D2AE              SETB    IE.6
    123                  SWDT = 1;
   \   00ED  D2BE              SETB    IP.6
   \   00EF  0500              INC     $LOCBD SendStringEOLRS232+1
   \   00F1  E500              MOV     A,$LOCBD SendStringEOLRS232+1
   \   00F3  7002              JNZ     ?0055
   \   00F5  0500              INC     $LOCBD SendStringEOLRS232
   \   00F7            ?0055:
   \   00F7  80CE              SJMP    ?0022
   \   00F9            ?0021:
    124              }
    125              SendRS232(13);                                      //"Carrige Return"
   \   00F9  7C0D              MOV     R4,#13
   \   00FB  120000            LCALL   $REFFN SendRS232
    126              SendRS232(10);                                      //"Line Feed"
    127          }        
   \   00FE  7C0A              MOV     R4,#10
   \   0100  020000            LJMP    $REFFN SendRS232
    128          
    129          
    130          char   WaitAndReceiveRS232( void )
    131          //Väntar tills det finns ett tecken på RS232 porten redo för mottagning. Retunerar det tecknet.
    132          {
   \   0103            WaitAndReceiveRS232:
   \   0103            ?0026:
    133              char    tecken;
    134          
    135              while(!(S1CON & 1)) {                               //Väntar på mottagning
   \   0103  E59B              MOV     A,155
   \   0105  20E006            JB      ACC.0,?0025
   \   0108            ?0027:
    136                  WDT = 1;
   \   0108  D2AE              SETB    IE.6
    137                  SWDT = 1;
   \   010A  D2BE              SETB    IP.6
   \   010C  80F5              SJMP    ?0026
   \   010E            ?0025:
    138              }
    139              tecken = S1BUF;                                     //Läser mottaget tecken   
   \   010E  859C00            MOV     $LOCBD WaitAndReceiveRS232,156
    140              S1CON &= ~(1);                                   //Nollar mottagnings-interrupt-flagga          
   \   0111  539BFE            ANL     155,#254
    141          
    142              return tecken;
   \   0114  AC00              MOV     R4,$LOCBD WaitAndReceiveRS232
    143          }
   \   0116  22                RET
    144          
    145          void    SendRS232(char tecken)
    146          //Sänder ett tecken på RS232-porten och väntar tills det är sänt.
    147          {
   \   0117            SendRS232:
    148              S1BUF = tecken;                                     //Sänder tecken 
   \   0117  8C9C              MOV     156,R4
   \   0119  8C00              MOV     $LOCBD SendRS232,R4
   \   011B            ?0029:
    149              while(!(S1CON & 2));                                //Väntar på att alla bitar sänts
   \   011B  E59B              MOV     A,155
   \   011D  20E102            JB      ACC.1,?0028
   \   0120            ?0030:
   \   0120  80F9              SJMP    ?0029
   \   0122            ?0028:
    150              S1CON &= ~(2);                                      //Nollar sändnings-interrupt-flagga      
   \   0122  539BFD            ANL     155,#253
    151          }
   \   0125  22                RET
    152          
    153              
    154              
    155              
    156          void programmLowMem ( void )
    157          {
   \   0126            programmLowMem:
    158              char            command;
    159              char            packLen;
    160              char xdata *    address;
    161              unsigned int    adrTmp;
    162              char            c;
    163              char            cs;
    164              char            cc;
    165              char            checkSum;
    166              char            index;
    167              char            buffer[65];
    168          //    char            msg[25];
    169          
    170              SendRS232('P');
   \   0126  7C50              MOV     R4,#80
   \   0128  120000            LCALL   $REFFN SendRS232
   \   012B            ?0033:
    171          
    172              do {
    173                  command = WaitAndReceiveRS232();
   \   012B  120000            LCALL   $REFFN WaitAndReceiveRS232
    174          
    175                  if (command == 'F') {
   \   012E  8C00              MOV     $LOCBD programmLowMem,R4
   \   0130  EC                MOV     A,R4
   \   0131  B44602            CJNE    A,#70,$+5
   \   0134  8003              SJMP    $+5
   \   0136  0201E7            LJMP    ?0035
   \   0139            ?0034:
    176                      c = WaitAndReceiveRS232();          //Väntar på adress (MSB) från PC
   \   0139  120000            LCALL   $REFFN WaitAndReceiveRS232
    177                      
    178                      adrTmp = (c * 256);                  //MSB av adrespekaren
   \   013C  EC                MOV     A,R4
   \   013D  750000            MOV     $LOCBD programmLowMem+5,#0
   \   0140  F500              MOV     $LOCBD programmLowMem+4,A
    179           
    180                      c = WaitAndReceiveRS232();          //Väntar på adress (LSB) från PC
   \   0142  8C00              MOV     $LOCBD programmLowMem+6,R4
   \   0144  120000            LCALL   $REFFN WaitAndReceiveRS232
    181                      
    182                      adrTmp += c;
   \   0147  8C00              MOV     $LOCBD programmLowMem+6,R4
   \   0149  E500              MOV     A,$LOCBD programmLowMem+5
   \   014B  2C                ADD     A,R4
   \   014C  F500              MOV     $LOCBD programmLowMem+5,A
   \   014E  E500              MOV     A,$LOCBD programmLowMem+4
   \   0150  3400              ADDC    A,#0
   \   0152  F500              MOV     $LOCBD programmLowMem+4,A
    183                      address = (char xdata *) adrTmp;
   \   0154  850000            MOV     $LOCBD programmLowMem+3,$LOCBD programmLowMem+5
   \   0157  850000            MOV     $LOCBD programmLowMem+2,$LOCBD programmLowMem+4
    184           
    185                      packLen = WaitAndReceiveRS232();          //Väntar på paketlängd från PC
   \   015A  120000            LCALL   $REFFN WaitAndReceiveRS232
   \   015D  8C00              MOV     $LOCBD programmLowMem+1,R4
    186                                              
    187                      checkSum = 0xFF;
    188                       
    189                      for (index = 0 ; index < packLen ; index++) {            
   \   015F  7500FF            MOV     $LOCBD programmLowMem+9,#255
   \   0162  750000            MOV     $LOCBD programmLowMem+10,#0
   \   0165            ?0037:
   \   0165  E500              MOV     A,$LOCBD programmLowMem+10
   \   0167  C3                CLR     C
   \   0168  9500              SUBB    A,$LOCBD programmLowMem+1
   \   016A  5013              JNC     ?0036
   \   016C            ?0038:
    190                          c = WaitAndReceiveRS232();        //Väntar på databyte från PC
   \   016C  120000            LCALL   $REFFN WaitAndReceiveRS232
    191                          checkSum ^= c;                  //Beräkna checksum
   \   016F  EC                MOV     A,R4
   \   0170  6200              XRL     $LOCBD programmLowMem+9,A
    192                          buffer[index] = c;
   \   0172  E500              MOV     A,$LOCBD programmLowMem+10
   \   0174  2400              ADD     A,#$LOCBD programmLowMem+11
   \   0176  F8                MOV     R0,A
   \   0177  EC                MOV     A,R4
   \   0178  F6                MOV     @R0,A
   \   0179  8C00              MOV     $LOCBD programmLowMem+6,R4
   \   017B  0500              INC     $LOCBD programmLowMem+10
   \   017D  80E6              SJMP    ?0037
   \   017F            ?0036:
    193                      }
    194           
    195                      cs = WaitAndReceiveRS232();          //Väntar på checksum från PC
   \   017F  120000            LCALL   $REFFN WaitAndReceiveRS232
    196                      
    197                      checkSum ^= cs;                      //Beräkna checksum
   \   0182  EC                MOV     A,R4
   \   0183  8C00              MOV     $LOCBD programmLowMem+7,R4
   \   0185  6200              XRL     $LOCBD programmLowMem+9,A
    198          
    199                      if (checkSum == 0) {
   \   0187  E500              MOV     A,$LOCBD programmLowMem+9
   \   0189  7055              JNZ     ?0041
   \   018B            ?0040:
    200                          for (index = 0 ; index < packLen ; index++) {            
   \   018B  7F00              MOV     R7,#0
   \   018D            ?0043:
   \   018D  EF                MOV     A,R7
   \   018E  C3                CLR     C
   \   018F  9500              SUBB    A,$LOCBD programmLowMem+1
   \   0191  5020              JNC     ?0042
   \   0193            ?0044:
    201                              *(address++) = buffer[index];//Skriv databyte i minnet
   \   0193  EF                MOV     A,R7
   \   0194  2400              ADD     A,#$LOCBD programmLowMem+11
   \   0196  F8                MOV     R0,A
   \   0197  E6                MOV     A,@R0
   \   0198  850082            MOV     DPL,$LOCBD programmLowMem+3
   \   019B  850083            MOV     DPH,$LOCBD programmLowMem+2
   \   019E  FC                MOV     R4,A
   \   019F  0500              INC     $LOCBD programmLowMem+3
   \   01A1  E500              MOV     A,$LOCBD programmLowMem+3
   \   01A3  7002              JNZ     ?0056
   \   01A5  0500              INC     $LOCBD programmLowMem+2
   \   01A7            ?0056:
   \   01A7  EC                MOV     A,R4
   \   01A8  F0                MOVX    @DPTR,A
    202                              c = buffer[index];
   \   01A9  EF                MOV     A,R7
   \   01AA  2400              ADD     A,#$LOCBD programmLowMem+11
   \   01AC  F8                MOV     R0,A
   \   01AD  E6                MOV     A,@R0
   \   01AE  F500              MOV     $LOCBD programmLowMem+6,A
   \   01B0  0F                INC     R7
   \   01B1  80DA              SJMP    ?0043
   \   01B3            ?0042:
   \   01B3  8F00              MOV     $LOCBD programmLowMem+10,R7
    203                          }
    204                          address--;                          //Senaste address för polling
   \   01B5  E500              MOV     A,$LOCBD programmLowMem+3
   \   01B7  1500              DEC     $LOCBD programmLowMem+3
   \   01B9  7002              JNZ     ?0057
   \   01BB  1500              DEC     $LOCBD programmLowMem+2
   \   01BD            ?0057:
    205                               
    206                          cc = c & 0x01;     //Maska fram LSB ur senaste skrivna datat
   \   01BD  AF00              MOV     R7,$LOCBD programmLowMem+6
   \   01BF  EF                MOV     A,R7
   \   01C0  5401              ANL     A,#1
   \   01C2  F500              MOV     $LOCBD programmLowMem+8,A
   \   01C4            ?0048:
    207          
    208                          do {
    209                              c = *(address) & 0x01;          //Hämtar den senast inskrivna byten
   \   01C4  850082            MOV     DPL,$LOCBD programmLowMem+3
   \   01C7  850083            MOV     DPH,$LOCBD programmLowMem+2
   \   01CA  E0                MOVX    A,@DPTR
   \   01CB  5401              ANL     A,#1
   \   01CD  FF                MOV     R7,A
    210                              WDT = 1;                        //Nollställer watchdog
   \   01CE  D2AE              SETB    IE.6
    211                              SWDT = 1;        
   \   01D0  D2BE              SETB    IP.6
    212                          } while (c != cc);                  //Blir lika när minnet är klart
   \   01D2  EF                MOV     A,R7
   \   01D3  6500              XRL     A,$LOCBD programmLowMem+8
   \   01D5  70ED              JNZ     ?0048
   \   01D7            ?0046:
   \   01D7  8F00              MOV     $LOCBD programmLowMem+6,R7
    213                          SendRS232('F');                 //Sänder "proceed" till PC
   \   01D9  7C46              MOV     R4,#70
   \   01DB  120000            LCALL   $REFFN SendRS232
    214                      } else {
   \   01DE  8005              SJMP    ?0049
   \   01E0            ?0041:
    215                          SendRS232('R');                 //Sänder "resend" till PC
   \   01E0  7C52              MOV     R4,#82
   \   01E2  120000            LCALL   $REFFN SendRS232
   \   01E5            ?0049:
   \   01E5  8009              SJMP    ?0050
   \   01E7            ?0035:
    216                      }
    217                  } else if (command != 'D') {
   \   01E7  6444              XRL     A,#68
   \   01E9  6005              JZ      ?0052
   \   01EB            ?0051:
    218                      SendRS232('?');                        //Känner inte igen kommandot. Sänder fråga till PC
   \   01EB  7C3F              MOV     R4,#63
   \   01ED  120000            LCALL   $REFFN SendRS232
   \   01F0            ?0052:
   \   01F0            ?0050:
    219                  }
    220              } while (command != 'D');                   //Fortsätt tills kommando för låga minnet kommer
   \   01F0  E500              MOV     A,$LOCBD programmLowMem
   \   01F2  B44402            CJNE    A,#68,$+5
   \   01F5  8003              SJMP    $+5
   \   01F7  02012B            LJMP    ?0033
   \   01FA            ?0031:
    221              
    222              SendStringRS232("D1D2");
   \   01FA  7D8C              MOV     R5,#LOW(?0053)
   \   01FC  7E00              MOV     R6,#HIGH(?0053)
   \   01FE  7F02              MOV     R7,#2
   \   0200  020000            LJMP    $REFFN SendStringRS232
    223          
    224          //----------------------
    225          //Debuggavdelning:
    226          /*
    227          
    228              SendStringEOLRS232("From EEPROM 0x8000:");
    229              address = (char xdata *) 0x8000;
    230              for (index = 0 ; index < 64 ; index++ ) {
    231                  c = *(address++);
    232                  sprintf(msg, "At %X, Read: ", (int) address);
    233                  SendStringRS232(msg);    
    234                  sprintf(msg, "%X", c);
    235                  SendStringEOLRS232(msg);    
    236              }
    237          */ 
    238          //Slut på debuggavdelning
    239          //----------------------
    240          
    241          }
    242          
    243          
    244          void    SendBackAll( void )
    245          {
   \   0203            SendBackAll:
    246          
    247          }  
   \   0203  22                RET
    248          
    249          
   \   0000                    RSEG    CSTR
   \   0000            ?0002:
   \   0000  54686520          DB      'The SuperComputer Programmer and FRHA welcomes you, ver2',0
   \   0004  53757065
   \   0008  72436F6D
   \   000C  70757465
   \   0010  72205072
   \   0014  6F677261
   \   0018  6D6D6572
   \   001C  20616E64
   \   0020  20465248
   \   0024  41207765
   \   0028  6C636F6D
   \   002C  65732079
   \   0030  6F752C20
   \   0034  76657232
   \   0038  00
   \   0039            ?0004:
   \   0039  446F6767          DB      'Dogged!!!!!',0
   \   003D  65642121
   \   0041  21212100
   \   0045            ?0010:
   \   0045  48656C6C          DB      'Hello from the SuperComputer programmer!',0
   \   0049  6F206672
   \   004D  6F6D2074
   \   0051  68652053
   \   0055  75706572
   \   0059  436F6D70
   \   005D  75746572
   \   0061  2070726F
   \   0065  6772616D
   \   0069  6D657221
   \   006D  00
   \   006E            ?0013:
   \   006E  524F4D20          DB      'ROM 0 selected',0
   \   0072  30207365
   \   0076  6C656374
   \   007A  656400
   \   007D            ?0015:
   \   007D  524F4D20          DB      'ROM 1 selected',0
   \   0081  31207365
   \   0085  6C656374
   \   0089  656400
   \   008C            ?0053:
   \   008C  44314432          DB      'D1D2',0
   \   0090  00
   \   0091                    END

Errors: none
Warnings: none
Code size: 516
Constant size: 145
Static variable size: Data(0) Idata(0) Bit(0) Xdata(0) Pdata(0) Bdata(0)

